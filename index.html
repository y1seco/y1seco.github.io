<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Y1secoのblog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Y1secoのblog"><meta name="msapplication-TileImage" content="./img/avatar1.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Y1secoのblog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="Y1seco"><meta property="og:url" content="https://y1seco.github.io/"><meta property="og:site_name" content="Y1seco"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://y1seco.github.io/img/og_image.png"><meta property="article:author" content="Y1seco"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://y1seco.github.io"},"headline":"Y1secoのblog","image":["https://y1seco.github.io/img/og_image.png"],"author":{"@type":"Person","name":"y1seco"},"description":""}</script><link rel="icon" href="/./img/avatar1.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Y1secoのblog" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/./img/avatar1.jpg" alt="Y1secoのblog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Join Gitter" href="https://gitter.im/hexo-theme-amazing/community"><i class="fab fa-gitter"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/05/14/LMK/"><img class="fill" src="https://w.wallhaven.cc/full/y8/wallhaven-y8oewl.jpg" alt="Android--LMK机制分析"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-05-14  <a class="commentCountImg" href="/2022/05/14/LMK/#comment-container"><span class="display-none-class">51838ce62c692ed94be64d640c462ba7</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="51838ce62c692ed94be64d640c462ba7">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>3 h  <i class="fas fa-pencil-alt"> </i>24.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/14/LMK/">Android--LMK机制分析</a></h1><div class="content"><span id="more"></span>
<p>Android——LMK 机制源代码研究分析</p>
<h1 id="一-目标"><a class="markdownIt-Anchor" href="#一-目标">#</a> 一、目标</h1>
<p>​	本篇文章主要分析 Andoird 核心机制与服务中的 ——LMK 机制，低内存管理机制（根据需要杀死进程来释放需要的内存）。源码分析主要通过 http://androidxref.com/，Android 版本为 Marshmallow-Android 6.0.1_r10, 内核版本为 3.18，机制架构如下：</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205141101950.png" alt="image-20220514110126445"></p>
<p>源码位置如下：</p>
<table>
<thead>
<tr>
<th>源代码名称</th>
<th>路径位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>lowmemorykiller.c</td>
<td>/drivers/staging/android/lowmemorykiller.c</td>
</tr>
<tr>
<td>lmkd.c</td>
<td>/system/core/lmkd/lmkd.c</td>
</tr>
<tr>
<td>ProcessList.java</td>
<td>/frameworks/base/services/core/java/com/android/server/am/ProcessList.java</td>
</tr>
<tr>
<td>ActivityManagerService.java</td>
<td>/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</td>
</tr>
</tbody>
</table>
<h1 id="二-核心服务原理分析"><a class="markdownIt-Anchor" href="#二-核心服务原理分析">#</a> 二、核心服务原理分析</h1>
<h2 id="一-lmk简介"><a class="markdownIt-Anchor" href="#一-lmk简介">#</a> （一） LMK 简介</h2>
<p>为了防止剩余内存过低，Android 在内核空间采用 <code>LMK(Low Memory Killer)</code>  机制，LMK 是通过注册 shrinker 来触发低内存回收的，但是这个机制可能会拖慢 Shrinkers 内存扫描速度，已从内核 4.12 中移除，后续会采用用户空间的 LMKD + memory cgroups 机制。</p>
<p>进程刚启动时，ADJ 等于 INVALID_ADJ，当执行完 attachApplication ()，该进程的 curAdj 和 setAdj 不相等，则会触发执行 setOomAdj () 将该进程的节点 /proc/pid/oom_score_adj 写入 oomadj 的值。下图参数为 Android 原生阈值，当系统剩余空闲内存抵御某阈值（比如 147MB），则从 ADJ 大于或等于相应阈值（比如 900）的进程中，选择 ADJ 值最大的进程，如果存在多个 ADJ 相同的进程，则选择内存最大的进程。如下是 64 位机器，LMK 默认阈值图：</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205080957542.png" alt="img"></p>
<h2 id="二lmkd"><a class="markdownIt-Anchor" href="#二lmkd">#</a> （二）lmkd</h2>
<p>​		 <code>lmkd</code> ，全称为 Low Memory Killer Daemon，用以监控正在运行的 Android 系统的内存) 状态，以及通过杀死最不重要进程来应对高内存压力，以保持系统在可接受的水平上运行。</p>
<p>过去，Android 使用内存 LMK 驱动程序来监控系统内存的压力，这是一种依赖于硬编码值的硬件机制。从 Kernel 4.12 开始，LMK 驱动程序从上游内核中移除，由应用空间的 lmkd 执行内存监控和进程终止任务。</p>
<p>Android 10 以及更高版本支持新的 lmkd 模式，它使用 PSI 监视器来检测内存压力。PSI  用以测量由于内存不足导致任务延迟的时间。由于这些岩石会直接影响到用户体验，因此它们代表了确定内存压力严重的便捷指标。PSI  监视器允许特权用户进程（例如 lmkd）指定这些延迟的阈值，然后订阅当突破阈值时来自 kernel 的事件。</p>
<h2 id="三原理分析"><a class="markdownIt-Anchor" href="#三原理分析">#</a> （三）原理分析</h2>
<p>​		于 Linux 系统来说，底层内核的内存监控机制为 OOMKiller。一旦发现系统的可用内存达到临界值，OOM 的管理者就会自动回收内存。根据策略的不同，OOM 的处理手段略有差异。它的核心思想是按照优先级顺序，从低到高逐步杀掉进程，回收内存。优先级的设定策略一方面要考虑对系统的损害程度（例如系统的核心进程，优先级通常较高），另一方面也希望尽可能多地释放无用内存。一个合理的策略至少要综合一下几个因素：进程消耗的内存；进程占用的 CPU 时间；oom_adj（OOM 权重）。对于 Linux 内核中的 OOM Killer，内核所管理的进程都有一个衡量其 oom 权重的值，存储在 /proc/<PID>/oom_adj 中。根据这一权重值以及其他若干因素，系统会实时给每个进程评分，以决定 OOM 应该杀死哪些进程。比如 oom_score 分数越低的进程，杀死的概率越小，或者说被杀死的时间越晚。</p>
<p>对于 Android 系统来说，我们常常在使用的过程中从一个应用返回到桌面，然后再打开其他的应用进行使用。而此时前一个应用会驻留在内存中，当再次打开该应用时就可以直接显示使用。通过这种方法可以提升用户体验以及提高应用打开速度。但是系统内存是有限的，不可能一直将全部应用驻留在系统内存中。基于 Linux 内核 OOM Killer 的核心思想，Android 系统扩展出了自己的内存监控体系。因为 Linux 下的杀死内存要等到系统资源快要不够用的时候才会产生效果。而 Android 实现了不同梯级的 Killer，名为 Low Memory Killer（LMK）。所以 Low Memory Killer 的作用就是当内存处于低水平时，杀死系统中余留的暂时还不使用的进程，来释放内存。</p>
<p>我们知道，从 Zygote 中孵化出来的进程都会记录在 ActivityManagerService.mLruProcesses 列表中，ActivityManagerService 的核心业务之一就是实时更新进程的状态，根据状态计算出进程对应的 OomAdj 值，这个值会传递到 kernel 中，在 kernel 中有一个低内存回收机制，在内存达到一定阈值时会触发清理 OomAdj 值高的进程，这就是 LMK 的工作原理。</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205141149506.jpeg" alt="img"></p>
<p>用户在启动一个进程之后，通常伴随着启动一个 Activity 游览页面或者一个 Service 播放音乐等等，这个时候此进程的 adj 被 AMS 提高，LMK 就不会杀死这个进程，当这个进程要做的事情做完了，退出后台了，此进程的 adj 很快又被 AMS 降低。当需要杀死一个进程释放内存时，一般先根据当前手机剩余内存的状态，在 minfree 节点中找到当前等级，再根据这个等级去 adj 节点中找到这个等级应该杀掉的进程的优先级， 之后遍历所有进程并比较进程优先级 adj 与优先级阈值，并杀死优先级低于阈值的进程，达到释放内存的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205121659479.jpg) </span><br><span class="line"></span><br><span class="line">AMS负责了系统中四大组件的启动、切换、调度以及应用进程管理和调度工作。在应用程序的使用过程中，AMS会根据四大组件关键生命周期，在mLruProcesses中时时地设定对应进程的adj值（更新进程优先级），在内存低于阈值时，LMK会选择adj优先级最大（如果adj相等则选择同adj中内存占用最大）的进程杀掉，释放内存。</span><br><span class="line"></span><br><span class="line">总的来说，```Framework层通过调整adj的值和阈值数组，输送给kernel中的lmk，为lmk提供杀进程的原材料```，因为用户空间和内核空间相互隔离，就采用了文件节点进行通讯，用socket将adj的值与阈值数组传给lmkd(5.0之后不在由AMS直接与lmk通信，引入lmkd守护进程)，lmkd将这些值写到内核节点中。lmk通过读取这些节点，实现进程的kill。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 三、源代码分析</span><br><span class="line"></span><br><span class="line">## （一） ActivityManagerService.java</span><br><span class="line"></span><br><span class="line">### 1. updateConfiguration方法</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public void updateConfiguration(Configuration values) &#123;</span><br><span class="line">        enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,</span><br><span class="line">                &quot;updateConfiguration()&quot;);</span><br><span class="line"></span><br><span class="line">        synchronized(this) &#123;</span><br><span class="line">            if (values == null &amp;&amp; mWindowManager != null) &#123;</span><br><span class="line">                values = mWindowManager.computeNewConfiguration();</span><br><span class="line">            &#125;</span><br><span class="line">            if (mWindowManager != null) &#123;</span><br><span class="line">                mProcessList.applyDisplaySize(mWindowManager);</span><br><span class="line">            &#125;</span><br><span class="line">            final long origId = Binder.clearCallingIdentity();</span><br><span class="line">            if (values != null) &#123;</span><br><span class="line">                Settings.System.clearConfiguration(values);</span><br><span class="line">            &#125;</span><br><span class="line">            updateConfigurationLocked(values, null, false, false);</span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里 updateConfiguration 是 ActivityManagerService (AMS) 对外提供的 binder 接口，调用后可以更新窗口的配置。</p>
<h3 id="2-applyoomadjlocked方法"><a class="markdownIt-Anchor" href="#2-applyoomadjlocked方法">#</a> 2. applyOomAdjLocked 方法</h3>
<p>2.1 applyOomAdjLocked 方法执行在 updateOomAdjLocked 中，最终通过它把 computeOomAdjLocked 和 updateOomAdjLocked 计算好的 adj 更新并保存。时序图如下：</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205141614729.jpg" alt="img"></p>
<p>2.2 源码分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">applyOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="type">boolean</span> doingAll, <span class="type">long</span> now,</span></span><br><span class="line"><span class="params">            <span class="type">long</span> nowElapsed)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (app.curRawAdj != app.setRawAdj) &#123;</span><br><span class="line">            app.setRawAdj = app.curRawAdj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">changes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//curAdj是computeOomAdjLocked计算出的adj值，赋值给setAdj，</span></span><br><span class="line">        <span class="comment">//并且调用ProcessList.setOomAdj方法        </span></span><br><span class="line">        <span class="keyword">if</span> (app.curAdj != app.setAdj) &#123;</span><br><span class="line">            ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                    <span class="string">&quot;Set &quot;</span> + app.pid + <span class="string">&quot; &quot;</span> + app.processName + <span class="string">&quot; adj &quot;</span> + app.curAdj + <span class="string">&quot;: &quot;</span></span><br><span class="line">                    + app.adjType);</span><br><span class="line">            app.setAdj = app.curAdj;</span><br><span class="line">        &#125;</span><br><span class="line">          </span><br><span class="line">        <span class="comment">//当schedGroup在ProcessList.SCHED_GROUP_TOP_APP跟非ProcessList.SCHED_GROUP_TOP_APP间切换时调用Process.setThreadPriority(int tid,int priority)，即应用进入前台和退出前台时改变UI相关线程优先级，这里的UI相关线程包括主线程和RenderThread，以提升用户界面的响应速度。</span></span><br><span class="line">        <span class="keyword">if</span> (app.setSchedGroup != app.curSchedGroup) &#123;</span><br><span class="line">            app.setSchedGroup = app.curSchedGroup;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                    <span class="string">&quot;Setting process group of &quot;</span> + app.processName</span><br><span class="line">                    + <span class="string">&quot; to &quot;</span> + app.curSchedGroup);</span><br><span class="line">            <span class="keyword">if</span> (app.waitingToKill != <span class="literal">null</span> &amp;&amp; app.curReceiver == <span class="literal">null</span></span><br><span class="line">                    &amp;&amp; app.setSchedGroup == Process.THREAD_GROUP_BG_NONINTERACTIVE) &#123;</span><br><span class="line">                app.kill(app.waitingToKill, <span class="literal">true</span>);</span><br><span class="line">                success = <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">oldId</span> <span class="operator">=</span> Binder.clearCallingIdentity();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Process.setProcessGroup(app.pid, app.curSchedGroup);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">&quot;Failed setting process group of &quot;</span> + app.pid</span><br><span class="line">                                + <span class="string">&quot; to &quot;</span> + app.curSchedGroup);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        Binder.restoreCallingIdentity(oldId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            app.thread.setSchedulingGroup(app.curSchedGroup);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Process.setSwappiness(app.pid,</span><br><span class="line">                        app.curSchedGroup &lt;= Process.THREAD_GROUP_BG_NONINTERACTIVE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用了进程ApplicationThread的setProcessState方法</span></span><br><span class="line">        <span class="comment">//调用Process.setProcessGroup(int pid,int group)设置进程调度策略，native层代码原理就是利用linux的cgroup机制，将进程根据状态放入预先设定的cgroup分组中，这些分组包含了对cpu使用率、cpuset、cpu调频等子资源的配置，已满足特定状态进程对系统资源的需求。        </span></span><br><span class="line">        <span class="keyword">if</span> (app.repProcState != app.curProcState) &#123;</span><br><span class="line">            app.repProcState = app.curProcState;</span><br><span class="line">            changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;</span><br><span class="line">            <span class="keyword">if</span> (app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="comment">//RuntimeException h = new RuntimeException(&quot;here&quot;);</span></span><br><span class="line">                        Slog.i(TAG, <span class="string">&quot;Sending new process state &quot;</span> + app.repProcState</span><br><span class="line">                                + <span class="string">&quot; to &quot;</span> + app <span class="comment">/*, h*/</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    app.thread.setProcessState(app.repProcState);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-updateoomadjlocked无参方法"><a class="markdownIt-Anchor" href="#3-updateoomadjlocked无参方法">#</a> 3. updateOomAdjLocked 无参方法</h3>
<p>updateOomAdjLocked 方法在应用进程的组件运行状态发生改变时被调用，比如有 Service 启动，有广播接收者收到广播，有 Activity 启动等。因为进程的重要性的计算就依赖于组件运行状态，既然组件运行状态发生了改变，就应该实时更新。</p>
<p>3.1 执行 oom 更新之前一些基本参数的初始化重置:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">updateOomAdjLocked</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ActivityRecord</span> <span class="variable">TOP_ACT</span> <span class="operator">=</span> resumedAppLocked(); <span class="comment">//获取当前</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">TOP_APP</span> <span class="operator">=</span> TOP_ACT != <span class="literal">null</span> ? TOP_ACT.app : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> SystemClock.uptimeMillis(); <span class="comment">//系统开机不包括睡眠时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">nowElapsed</span> <span class="operator">=</span> SystemClock.elapsedRealtime(); <span class="comment">//系统开机时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">oldTime</span> <span class="operator">=</span> now - ProcessList.MAX_EMPTY_TIME; <span class="comment">//MAX_EMPTY_TIME是系统控制空进程能够保存的最大时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> mLruProcesses.size(); <span class="comment">//lru集合中进程的数量</span></span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    mAdjSeq++; <span class="comment">//记录执行该方法的次数</span></span><br><span class="line">    mNewNumServiceProcs = <span class="number">0</span>;</span><br><span class="line">    mNewNumAServiceProcs = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//系统默认CUR_MAX_EMPTY_PROCESSES=16,CUR_MAX_CACHED_PROCESSES=32</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">emptyProcessLimit</span> <span class="operator">=</span> mConstants.CUR_MAX_EMPTY_PROCESSES;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">cachedProcessLimit</span> <span class="operator">=</span> mConstants.CUR_MAX_CACHED_PROCESSES - emptyProcessLimit;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//将adj在900～906之间的进程分为numSlots部分</span></span><br><span class="line">    <span class="comment">//900～906只有7个数字可用，但是adj位于该范围的进程数量往往远远不只</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numSlots</span> <span class="operator">=</span> (ProcessList.CACHED_APP_MAX_ADJ</span><br><span class="line">            - ProcessList.CACHED_APP_MIN_ADJ + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//=3</span></span><br><span class="line">    <span class="comment">//N = mNumNonCachedProcs + mNumCachedHiddenProcs + numEmptyProcs</span></span><br><span class="line">    <span class="comment">//lru集合的大小 = 非缓存进程+缓存进程+空进程</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numEmptyProcs</span> <span class="operator">=</span> N - mNumNonCachedProcs - mNumCachedHiddenProcs;</span><br><span class="line">    <span class="keyword">if</span> (numEmptyProcs &gt; cachedProcessLimit) &#123;</span><br><span class="line">        numEmptyProcs = cachedProcessLimit;<span class="comment">//保证空进程的数量在阈值内</span></span><br><span class="line">    &#125;</span><br><span class="line">    mEmptyRemainingCapacity = emptyProcessLimit - numEmptyProcs;<span class="comment">//空进程剩余的容量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">emptyFactor</span> <span class="operator">=</span> numEmptyProcs/numSlots;<span class="comment">//空进程的计算因子</span></span><br><span class="line">    <span class="keyword">if</span> (emptyFactor &lt; <span class="number">1</span>) emptyFactor = <span class="number">1</span>;<span class="comment">//保证最小为1</span></span><br><span class="line">    <span class="comment">//缓存进程的计算因子</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cachedFactor</span> <span class="operator">=</span> (mNumCachedHiddenProcs &gt; <span class="number">0</span> ? mNumCachedHiddenProcs : <span class="number">1</span>)/numSlots;</span><br><span class="line">    <span class="keyword">if</span> (cachedFactor &lt; <span class="number">1</span>) cachedFactor = <span class="number">1</span>;<span class="comment">//保证最小为1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stepCached</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//代表每一个slot的深度，下同</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">stepEmpty</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">numCached</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//缓存进程的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numEmpty</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//空进程的数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numTrimming</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//重要性低于home的后台进程数量</span></span><br><span class="line">    <span class="comment">//以上的一些计算因子，都是动态变化的，会随着对应的进程数量变化，决定着每一个slot中进程的step</span></span><br><span class="line"> </span><br><span class="line">    mNumNonCachedProcs = <span class="number">0</span>;<span class="comment">//重设全局变量非缓存进程大小为0</span></span><br><span class="line">    mNumCachedHiddenProcs = <span class="number">0</span>;<span class="comment">//重设全局变量缓存进程大小为0</span></span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> <span class="variable">curCachedAdj</span> <span class="operator">=</span> ProcessList.CACHED_APP_MIN_ADJ;<span class="comment">//在计算开始时，缓存进程的adj开始为900</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextCachedAdj</span> <span class="operator">=</span> curCachedAdj+<span class="number">1</span>;<span class="comment">//下一个为901</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curEmptyAdj</span> <span class="operator">=</span> ProcessList.CACHED_APP_MIN_ADJ;<span class="comment">//在计算开始时，空进程的adj开始900</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">nextEmptyAdj</span> <span class="operator">=</span> curEmptyAdj+<span class="number">2</span>;<span class="comment">//下一个为902</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">retryCycles</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//标记再次进行循环</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>3.2 调用 computeOomAdjLocked 方法计算进程的 oom</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> mLruProcesses.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!app.killedByAm &amp;&amp; app.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">                app.procStateChanged = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">//计算app进程的adj</span></span><br><span class="line">                computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, <span class="literal">true</span>, now);</span><br><span class="line">                <span class="comment">//当执行完computeOomAdjLocked之后，对于缓存进程和空进程的app，如果发现还未进行adj设置，需要修改成正确的adj值</span></span><br><span class="line">                <span class="keyword">if</span> (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (app.curProcState) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</span><br><span class="line">                        <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</span><br><span class="line">                        <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_RECENT:</span><br><span class="line">                            <span class="comment">//处理缓存进程</span></span><br><span class="line">                            app.curRawAdj = curCachedAdj;</span><br><span class="line">                            app.curAdj = app.modifyRawOomAdj(curCachedAdj);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_LRU &amp;&amp; <span class="literal">false</span>) Slog.d(TAG_LRU, <span class="string">&quot;Assigning activity LRU #&quot;</span> + i  + <span class="string">&quot; adj: &quot;</span> + app.curAdj + <span class="string">&quot; (curCachedAdj=&quot;</span> + curCachedAdj + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">                            <span class="keyword">if</span> (curCachedAdj != nextCachedAdj) &#123;</span><br><span class="line">                                stepCached++;</span><br><span class="line"><span class="comment">//从这部分逻辑可以看出stepCached应该是表示一个深度</span></span><br><span class="line">                                <span class="keyword">if</span> (stepCached &gt;= cachedFactor) &#123;<span class="comment">//cachedFactor用来表示每一个slot的最大深度</span></span><br><span class="line">                                    stepCached = <span class="number">0</span>;<span class="comment">//在一个slot内，他们的adj值是一样的</span></span><br><span class="line">                                    curCachedAdj = nextCachedAdj;<span class="comment">//下一个slot的adj值</span></span><br><span class="line">                                    nextCachedAdj += <span class="number">2</span>;</span><br><span class="line">                                    <span class="keyword">if</span> (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</span><br><span class="line">                                        <span class="comment">//保证缓存进程和空进程的adj在900～906之间</span></span><br><span class="line">                                        nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:<span class="comment">//处理空进程</span></span><br><span class="line">                            app.curRawAdj = curEmptyAdj;</span><br><span class="line">                            app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</span><br><span class="line">                            ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cycle strategy:循环策略</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cycleCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (retryCycles) &#123;</span><br><span class="line">            cycleCount++;</span><br><span class="line">            retryCycles = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> mLruProcesses.get(i);</span><br><span class="line">                <span class="keyword">if</span> (!app.killedByAm &amp;&amp; app.thread != <span class="literal">null</span> &amp;&amp; app.containsCycle == <span class="literal">true</span>) &#123;</span><br><span class="line">                    app.adjSeq--;</span><br><span class="line">                    app.completedAdjSeq--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>
<p>3.3 调用 applyOomAdjLocked 设置进程的 oom</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算完毕之后，进行设置app的oom</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i=N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">     ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">     <span class="keyword">if</span> (!app.killedByAm &amp;&amp; app.thread != null) &#123;</span><br><span class="line">         applyOomAdjLocked(app, <span class="literal">true</span>, now, nowElapsed);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//计算各个类型进程的数量</span></span><br><span class="line">         <span class="keyword">switch</span> (app.curProcState) &#123;</span><br><span class="line">             <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</span><br><span class="line">                 mNumCachedHiddenProcs++;</span><br><span class="line">                 numCached++;</span><br><span class="line">                 <span class="comment">//超过限制，杀进程回收资源</span></span><br><span class="line">                 <span class="keyword">if</span> (numCached &gt; cachedProcessLimit) &#123;</span><br><span class="line">                     app.kill(<span class="string">&quot;cached #&quot;</span> + numCached, <span class="literal">true</span>);</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_EMPTY:</span><br><span class="line">                 <span class="comment">//超过限制，杀进程回收资源</span></span><br><span class="line">                 <span class="keyword">if</span> (numEmpty &gt; mConstants.CUR_TRIM_EMPTY_PROCESSES</span><br><span class="line">                         &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</span><br><span class="line">                     app.kill(<span class="string">&quot;empty for &quot;</span></span><br><span class="line">                             + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime) / <span class="number">1000</span>) + <span class="string">&quot;s&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     numEmpty++;</span><br><span class="line">                     <span class="keyword">if</span> (numEmpty &gt; emptyProcessLimit) &#123;</span><br><span class="line">                         app.kill(<span class="string">&quot;empty #&quot;</span> + numEmpty, <span class="literal">true</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             <span class="keyword">default</span>:</span><br><span class="line">                 mNumNonCachedProcs++;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">          ...</span><br><span class="line">          <span class="keyword">if</span> (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</span><br><span class="line">                 &amp;&amp; !app.killedByAm) &#123;</span><br><span class="line">             numTrimming++;<span class="comment">//重要性低于Home的进程</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>1.1 当执行完上述代码后，根据执行结果设置当前的内存等级，并根据当前的内存等级主动去回收内存</p>
<ul>
<li>
<p>public static final int ADJ_MEM_FACTOR_NORMAL=0;// 正常等级</p>
</li>
<li>
<p>public static final int ADJ_MEM_FACTOR_MODERATE=1;// 中等等级</p>
</li>
<li>
<p>public static final int ADJ_MEM_FACTOR_LOW=2;// 存在低内存</p>
</li>
<li>
<p>public static final int ADJ_MEM_FACTOR_CRITICAL=3;// 严重低内存</p>
</li>
</ul>
<p>对应的更细节的内存回收策略如下：</p>
<ul>
<li>
<p>TRIM_MEEMORY_COMPLETTE=80</p>
</li>
<li>
<p>TRIM_MEEMORY_MODERATE=60</p>
</li>
<li>
<p>TRIM_MEEMORY_BACKGROUND=40</p>
</li>
<li>
<p>TRIM_MEEMORY_UI_HIDDEN=20</p>
</li>
<li>
<p>TRIM_MEEMORY_RUNNING_CRITICAL=15，对应 ADJ_MEM_FACTOR_CRITICAL</p>
</li>
<li>
<p>TRIM_MEEMORY_RUNNING_LOW=10，对应 ADJ_MEM_FACTOR_LOW</p>
</li>
<li>
<p>TRIM_MEEMORY_RUNNING_MODERATE=5，对应 ADJ_MEM_FACTOR_MODERATE 和 ADJ_MEM_FACTOR_NORMAL</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">        mNumServiceProcs = mNewNumServiceProcs;</span><br><span class="line">        final <span class="type">int</span> numCachedAndEmpty = numCached + numEmpty;<span class="comment">//缓存进程和空进程的数量和</span></span><br><span class="line">        <span class="type">int</span> memFactor;<span class="comment">//内存等级计算因子</span></span><br><span class="line">        <span class="keyword">if</span> (numCached &lt;= mConstants.CUR_TRIM_CACHED_PROCESSES</span><br><span class="line">                &amp;&amp; numEmpty &lt;= mConstants.CUR_TRIM_EMPTY_PROCESSES) &#123;<span class="comment">//缓存进程和空进程的数量都低于对应的规定阀值</span></span><br><span class="line">            <span class="keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) &#123;<span class="comment">//同时他们的总和低于极端情况下的阀值</span></span><br><span class="line">                <span class="comment">//缓存进程和空进程的数量很少，并且总和也很少，此情况很极端</span></span><br><span class="line">                memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;<span class="comment">//设置内存等级严重</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">//缓存进程和空进程的数量很少，但总和还行，我们认为此时的情况仅次于极端情况</span></span><br><span class="line">                memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//缓存进程和空进程的数量很少，但总和不错，认为该情况为中级</span></span><br><span class="line">                memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//缓存进程和空进程的数量正常，该情况为正常</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, <span class="string">&quot;oom: memFactor=&quot;</span> + memFactor</span><br><span class="line">                + <span class="string">&quot; last=&quot;</span> + mLastMemoryLevel + <span class="string">&quot; allowLow=&quot;</span> + mAllowLowerMemLevel</span><br><span class="line">                + <span class="string">&quot; numProcs=&quot;</span> + mLruProcesses.size() + <span class="string">&quot; last=&quot;</span> + mLastNumProcesses);</span><br><span class="line">        <span class="comment">//memFactor取值在0-3之间，越大代表内存越紧张</span></span><br><span class="line">        <span class="keyword">if</span> (memFactor &gt; mLastMemoryLevel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) &#123;</span><br><span class="line">                memFactor = mLastMemoryLevel;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, <span class="string">&quot;Keeping last mem factor!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (memFactor != mLastMemoryLevel) &#123;</span><br><span class="line">            EventLogTags.writeAmMemFactor(memFactor, mLastMemoryLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        mLastMemoryLevel = memFactor;</span><br><span class="line">        mLastNumProcesses = mLruProcesses.size();</span><br><span class="line">        <span class="comment">//设置内存等级成功返回true</span></span><br><span class="line">        boolean allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now);</span><br><span class="line">        final <span class="type">int</span> trackerMemFactor = mProcessStats.getMemFactorLocked();</span><br><span class="line">        <span class="keyword">if</span> (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) &#123;<span class="comment">//当前的内存等级不正常</span></span><br><span class="line">            <span class="keyword">if</span> (mLowRamStartTime == <span class="number">0</span>) &#123;</span><br><span class="line">                mLowRamStartTime = now;<span class="comment">//记录时间</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> step = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> fgTrimLevel;</span><br><span class="line">            <span class="keyword">switch</span> (memFactor) &#123;</span><br><span class="line">                <span class="keyword">case</span> ProcessStats.ADJ_MEM_FACTOR_CRITICAL:</span><br><span class="line">                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ProcessStats.ADJ_MEM_FACTOR_LOW:</span><br><span class="line">                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> factor = numTrimming/<span class="number">3</span>;<span class="comment">//原理同上</span></span><br><span class="line">            <span class="type">int</span> minFactor = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (mHomeProcess != null) minFactor++;</span><br><span class="line">            <span class="keyword">if</span> (mPreviousProcess != null) minFactor++;</span><br><span class="line">            <span class="keyword">if</span> (factor &lt; minFactor) factor = minFactor;</span><br><span class="line">            <span class="type">int</span> curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;</span><br><span class="line"><span class="comment">//默认设置最高的回收等级</span></span><br><span class="line">            <span class="comment">//这个循环为逆序遍历。因为LRU集合中越在后面的进程，优先级越高，代表用户使用的频率高 </span></span><br><span class="line">            <span class="comment">//该进程在LRU集合的位置就越靠后，也就意味着其占有的内存也较多，因此他就越需要进行内存回收。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=N<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">                <span class="keyword">if</span> (allChanged || app.procStateChanged) &#123;</span><br><span class="line">                    setProcessTrackerStateLocked(app, trackerMemFactor, now);</span><br><span class="line">                    app.procStateChanged = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</span><br><span class="line">                        &amp;&amp; !app.killedByAm) &#123;<span class="comment">//procstate &gt;= 13</span></span><br><span class="line">                    <span class="comment">//进程优先级大于Home进程，也可以认为adj&gt;=600，也就是相对于用户重要程度低于Home进程</span></span><br><span class="line">                    <span class="keyword">if</span> (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != null) &#123;</span><br><span class="line">                        <span class="comment">//当前进程的内存回收等级小于当前的内存回收等级，说明之前内存情况较好，现在需要进行内存回收</span></span><br><span class="line">                        try &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                    <span class="string">&quot;Trimming memory of &quot;</span> + app.processName + <span class="string">&quot; to &quot;</span> + curLevel);</span><br><span class="line">                            app.thread.scheduleTrimMemory(curLevel);</span><br><span class="line">                        &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ...</span><br><span class="line"></span><br><span class="line">                    app.trimMemoryLevel = curLevel;</span><br><span class="line">                    step++;</span><br><span class="line">                    <span class="keyword">if</span> (step &gt;= factor) &#123;<span class="comment">//回收一定程度(即处理完一个slot之后)，按需要降低内存回收等级</span></span><br><span class="line">                        step = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">switch</span> (curLevel) &#123;</span><br><span class="line">                            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE:</span><br><span class="line">                                curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                                curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">                ...</span><br></pre></td></tr></table></figure>
<p>3.5 重新计算进程的 PSS 值，外加一些额外的结束工作</p>
<table>
<thead>
<tr>
<th>Item</th>
<th>全称</th>
<th>含义</th>
<th>等价</th>
</tr>
</thead>
<tbody>
<tr>
<td>USS</td>
<td>Unique Set Size</td>
<td>物理内存</td>
<td>进程独占的内存</td>
</tr>
<tr>
<td>PSS</td>
<td>Proportional Set Size</td>
<td>物理内存</td>
<td>PSS=USS + 按比例包含共享库</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size</td>
<td>物理内存</td>
<td>RSS=USS + 包含共享库</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size</td>
<td>虚拟内存</td>
<td>VSS=RSS + 未分配实际物理内存</td>
</tr>
</tbody>
</table>
<p>以 SystemUI 进程来说：</p>
<ul>
<li>
<p>USS：SytemUI 进程实际占用的物理内存</p>
</li>
<li>
<p>PSS：SystemUI 进程实际占用的物理内存加上 SystemUI 的共享库占用的内存</p>
</li>
<li>
<p>RSS：SystemUI 进程实际占用的物理内存加上所有共享库占用的内存</p>
</li>
<li>
<p>VSS：通常不关注</p>
</li>
</ul>
<p>一般来说内存占用大小有如下规律：VSS&gt;=RSS&gt;=PSS&gt;=USS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mAlwaysFinishActivities) &#123;</span><br><span class="line">    mStackSupervisor.scheduleDestroyAllActivities(null, <span class="string">&quot;always-finish&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;UidRecord&gt; becameIdle = null;</span><br><span class="line"><span class="keyword">if</span> (mLocalPowerManager != null) &#123;</span><br><span class="line">    mLocalPowerManager.startUidChanges();</span><br><span class="line">&#125;</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">if</span> (becameIdle != null) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = becameIdle.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        mServices.stopInBackgroundLocked(becameIdle.get(i).uid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="4-computeoomadjlocked方法"><a class="markdownIt-Anchor" href="#4-computeoomadjlocked方法">#</a> 4. computeOomAdjLocked 方法</h3>
<p>​		computeOomAdjLocked 函数根据一定规则计算出三个状态值，这个规则与 Android 将进程划分的 5 个优先级有关系，即前台进程、可见进程、服务进程、后台进程、空进程。下面我们对 computeOomAdjLocked 函数进行分段研究。</p>
<p>4.1 根据参数及进程的状态，决定是否需要进行后续的计算，并初始化一些变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">computeOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="type">int</span> cachedAdj, ProcessRecord TOP_APP,</span></span><br><span class="line"><span class="params">        <span class="type">boolean</span> doingAll, <span class="type">long</span> now)</span> &#123;</span><br><span class="line">    <span class="comment">//updateOomAdjLocked函数每次更新oom_adj时，都会分配一个序号</span></span><br><span class="line">    <span class="comment">//此处就是根据序号判断是否已经处理过命令</span></span><br><span class="line">    <span class="keyword">if</span> (mAdjSeq == app.adjSeq) &#123;</span><br><span class="line">        <span class="comment">// This adjustment has already been computed.</span></span><br><span class="line">        <span class="keyword">return</span> app.curRawAdj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//ProcessRecord对应的ActivityThread不存在了</span></span><br><span class="line">    <span class="comment">//修改其中的一些变量，此时的oom_adj为CACHED_APP_MAX_ADJ，</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="literal">null</span>) &#123;</span><br><span class="line">        app.adjSeq = mAdjSeq;</span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">        <span class="keyword">return</span> (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化一些变量</span></span><br><span class="line">    app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;</span><br><span class="line">    app.adjSource = <span class="literal">null</span>;</span><br><span class="line">    app.adjTarget = <span class="literal">null</span>;</span><br><span class="line">    app.empty = <span class="literal">false</span>;</span><br><span class="line">    app.cached = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">activitiesSize</span> <span class="operator">=</span> app.activities.size();</span><br><span class="line">    <span class="comment">// ProcessRecord中只有初始化时为maxAdj赋值</span></span><br><span class="line">    <span class="comment">//maxAdj取值为UNKNOWN_ADJ，即最大的1001</span></span><br><span class="line">    <span class="keyword">if</span> (app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">        <span class="comment">//这部分代码就是修改app的curSchedGroup，并将oom_adj设置为maxAdj</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存当前TOP Activity的状态</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROCESS_STATE_CUR_TOP</span> <span class="operator">=</span> mTopProcessState;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.2 1.1 这部分代码包含前台 Activity 的进程，运行测试类的进程、处理广播的进程以及包含正在运行服务的进程，其中 oom_adj 都被赋值为 FOREGROUND_APP_ADJ。从 LMK 的角度看，它们的重要性是一致的，但这些进程的 proState 不同，于是从 AMS 主动回收内存的角度来看，它们的重要性不同。</p>
<p>对于其它种类的进程，这部分代码先将它们的 oom_adj 设置为 UNKNOW_ADJ，proc_state 设置为 PROCESS_STATE_CACHED_EMPTY，在后续的流程中再作进一步处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="type">int</span> adj;</span><br><span class="line"><span class="type">int</span> schedGroup;</span><br><span class="line"><span class="type">int</span> procState;</span><br><span class="line">boolean foregroundActivities = <span class="literal">false</span>;</span><br><span class="line">BroadcastQueue <span class="built_in">queue</span>;</span><br><span class="line"><span class="comment">//若进程包含正在前台显示的Activity</span></span><br><span class="line"><span class="keyword">if</span> (app == TOP_APP) &#123;</span><br><span class="line">    <span class="comment">// The last app on the list is the foreground app.</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    <span class="comment">//单独的一种schedGroup</span></span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">    app.adjType = <span class="string">&quot;top-activity&quot;</span>;</span><br><span class="line">    <span class="comment">//当前处理的是包含前台Activity的进程时，才会将该值置为true</span></span><br><span class="line">    foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">    procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instrumentationClass != null) &#123;</span><br><span class="line">    <span class="comment">//处理正在进行测试的进程</span></span><br><span class="line">    <span class="comment">// Don&#x27;t want to kill running instrumentation.</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.adjType = <span class="string">&quot;instrumentation&quot;</span>;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="built_in">queue</span> = isReceivingBroadcast(app)) != null) &#123;</span><br><span class="line">    <span class="comment">//处理正在处理广播的进程</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    <span class="comment">//根据处理广播的Queue，决定调度策略</span></span><br><span class="line">    schedGroup = (<span class="built_in">queue</span> == mFgBroadcastQueue)</span><br><span class="line">            ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">&quot;broadcast&quot;</span>;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_RECEIVER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.executingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//处理Service正在运行的进程</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = app.execServicesFg ?</span><br><span class="line">            ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//其它进程，在后续过程中再进一步处理  </span></span><br><span class="line">    <span class="comment">// 先将adj临时赋值为cachedAdj，即参数传入的UNKNOW_ADJ</span></span><br><span class="line">    adj = cachedAdj;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">    app.cached = <span class="literal">true</span>;</span><br><span class="line">    app.empty = <span class="literal">true</span>;</span><br><span class="line">    app.adjType = <span class="string">&quot;cch-empty&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4.3  这部分代码主要处理包含 Activity，但是 Activity 不在前台的进程。注意到这些进程包括之前提到的正在处理广播、服务或测试的进程以及 oom_adj 暂时为 UNKNOW_ADJ 的进程。不过只有 UNKNOW_ADJ 对应的进程，才有可能进行实际的更新。进程中若存在可见 Activity 时，进程的 oom_adj 为 VISIBLE_APP_ADJ；否则若进程中存在处于 PAUSING、PAUSED 或 STOPPING 状态的 Activity 时，进程的 oom_adj 为 PERCEPTIBLE_APP_ADJ；其余的进程仍是 UNKNOW_ADJ。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//rankTaskLayersIfNeeded函数会更新包含Activity的Task的rankLayer</span></span><br><span class="line">    <span class="comment">//按照显示层次从上到下，rankLayer逐渐增加，对应的最大值就是VISIBLE_APP_LAYER_MAX</span></span><br><span class="line">    <span class="type">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;</span><br><span class="line">    <span class="comment">//依次轮询进程中的Activity</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123;</span><br><span class="line">        final ActivityRecord r = app.activities.get(j);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果进程包含可见Activity，即该进程是个可见进程</span></span><br><span class="line">        <span class="keyword">if</span> (r.visible) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">                <span class="comment">//之前提到的正在处理广播、服务或测试的进程，adj为FOREGROUND，是小于VISIBLE_APP_ADJ</span></span><br><span class="line">                <span class="comment">//因此不会在此更新</span></span><br><span class="line">                adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">&quot;visible&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123;</span><br><span class="line">                <span class="comment">//与oom_adj类似，在条件满足时，更新procState</span></span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//正在处理广播、服务或测试的进程，如果它们的调度策略为BACKGROUND</span></span><br><span class="line">            <span class="comment">//但又包含了可见Activity时，调度策略变更为DEFAULT</span></span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">            app.cached = <span class="literal">false</span>;</span><br><span class="line">            app.empty = <span class="literal">false</span>;</span><br><span class="line">            foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.task != null &amp;&amp; minLayer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                 final <span class="type">int</span> layer = r.task.mLayerRank;</span><br><span class="line">                 <span class="keyword">if</span> (layer &gt;= <span class="number">0</span> &amp;&amp; minLayer &gt; layer) &#123;</span><br><span class="line">                     <span class="comment">//更新ranklayer</span></span><br><span class="line">                     minLayer = layer;</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//发现可见Activity时，直接可以结束循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) &#123;</span><br><span class="line">            <span class="comment">//如果进程包含处于PAUSING或PAUSED状态的Activity时</span></span><br><span class="line">            <span class="comment">//将其oom_adj调整为“用户可察觉”的的等级，这个等级还是很高的</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">&quot;pausing&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123;</span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">            &#125;</span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">            app.cached = <span class="literal">false</span>;</span><br><span class="line">            app.empty = <span class="literal">false</span>;</span><br><span class="line">            foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//注意并不会break</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.STOPPING) &#123;</span><br><span class="line">            <span class="comment">//包含处于Stopping状态Activity的进程，其oom_adj也被置为PERCEPTIBLE_APP_ADJ</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">&quot;stopping&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 这种进程将被看作潜在的cached或empty进程</span></span><br><span class="line">            <span class="keyword">if</span> (!r.finishing) &#123;</span><br><span class="line">                <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">                    procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            app.cached = <span class="literal">false</span>;</span><br><span class="line">            app.empty = <span class="literal">false</span>;</span><br><span class="line">            foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//只是含有cached-activity的进程，仅调整procState</span></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;</span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;</span><br><span class="line">                app.adjType = <span class="string">&quot;cch-act&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adj == ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">            <span class="comment">//不同可见进程的oom_adj有一定的差异，处在下层的oom_adj越大</span></span><br><span class="line">            <span class="comment">//即存在时间越长的Activity所在进程，重要性越低</span></span><br><span class="line">            adj += minLayer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>4.4 该部分代码主要用于处理一些特殊的进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ</span><br><span class="line">        || procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) &#123;</span><br><span class="line">    <span class="comment">//进程包含前台服务或被强制在前台运行时</span></span><br><span class="line">    <span class="comment">//oom_adj被调整为PERCEPTIBLE_APP_ADJ，只是procState略有不同</span></span><br><span class="line">    <span class="keyword">if</span> (app.foregroundServices) &#123;</span><br><span class="line">        adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;fg-service&quot;</span>;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.forcingToForeground != null) &#123;</span><br><span class="line">        adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;force-fg&quot;</span>;</span><br><span class="line">        app.adjSource = app.forcingToForeground;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AMS的HeavyWeight进程单独处理</span></span><br><span class="line"><span class="keyword">if</span> (app == mHeavyWeightProcess) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.HEAVY_WEIGHT_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;heavy&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//home进程特殊处理</span></span><br><span class="line"><span class="keyword">if</span> (app == mHomeProcess) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.HOME_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.HOME_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line"></span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;home&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_HOME) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_HOME;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//前台进程之前的一个进程</span></span><br><span class="line"><span class="keyword">if</span> (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;previous&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.adjSeq = mAdjSeq;</span><br><span class="line">app.curRawAdj = adj;</span><br><span class="line">app.hasStartedServices = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//处理正在进行backup工作的进程</span></span><br><span class="line"><span class="keyword">if</span> (mBackupTarget != null &amp;&amp; app == mBackupTarget.app) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.BACKUP_APP_ADJ) &#123;</span><br><span class="line">        ...</span><br><span class="line">        adj = ProcessList.BACKUP_APP_ADJ;</span><br><span class="line">        <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;</span><br><span class="line">        &#125;</span><br><span class="line">        app.adjType = <span class="string">&quot;backup&quot;</span>;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>至此，我们可以看出 computeOomAdjLocked 处理一个进程时，按照重要性由高到低的顺序，逐步判断该进程是否满足对应的条件。尽管计算一个进程的 oom_adj 时会经过上述所有的判断，但当一个进程已经满足重要性较高的条件时，后续的判断实际上不会更改它已经获得的 oom_adj。上述代码的逻辑图如下所示：</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205141709842.png" alt="image-20220514170953732"></p>
<p>4.5  该部分代码主要是处理包含服务的进程，进一步分段说明。</p>
<p>4.5.1 Unbounded Service 的处理</p>
<p>当进程中包含 Unbounded Service 时，进程的 oom_adj 先按照 Unbounded Service 的处理方式进行调整。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//依次处理进程中的每一个Service</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> is = app.services.size()<span class="number">-1</span>;</span><br><span class="line">    is &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">            || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">            || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">    is--) &#123;</span><br><span class="line">    ServiceRecord s = app.services.valueAt(is);</span><br><span class="line">    <span class="comment">//Service被已Unbounded Service的方式启动过</span></span><br><span class="line">    <span class="keyword">if</span> (s.startRequested) &#123;</span><br><span class="line">        app.hasStartedServices = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//调整procState</span></span><br><span class="line">        <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line">            <span class="comment">// 仅有含有服务且显示过UI的进程，由于其占用内存可能较多，因此需要尽早回收</span></span><br><span class="line">            <span class="comment">// 故此处不调整其oom_adj</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                app.adjType = <span class="string">&quot;cch-started-ui-services&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line">                <span class="comment">//MAX_SERVICE_INACTIVITY为activity启动service后，系统最多保留Service的时间</span></span><br><span class="line">                <span class="comment">//此时进程的oom_adj就可以被调整为后台服务对应的SERVICE_ADJ</span></span><br><span class="line">                <span class="comment">//adj大于500的进程均会受此判断的影响</span></span><br><span class="line">                <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                    adj = ProcessList.SERVICE_ADJ;</span><br><span class="line">                    app.adjType = <span class="string">&quot;started-services&quot;</span>;</span><br><span class="line">                    app.cached = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理Service存在超时的情况，可见超时时也不会调整oom_adj</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                app.adjType = <span class="string">&quot;cch-started-services&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出，当进程中含有 Unbounded Service 时，如果进程之前没有启动过 UI，且 Unbounded Service 存活的时间没有超时，进程的 oom_adj 才能被调整为 SERVICE_ADJ；否则进程的 oom_adj 仍然是 UNKNOW_ADJ 或其他大于 500 的值。</p>
<p>4.5.2 Bounded Service 的处理</p>
<p>该部分代码表示进程按照 Unbounded Service 的方式调增 oom_adj，然后再按照 Bouneded Service 的方式进一步调整。若 Service 仅为 Unbounded Service 或 Bounded Service 中的一种时，computeOomAdjLocked 函数的第五部分只会按照一种方式调增 oom_adj。Bounded Service 的处理方式，远比 Unbounded Service 复杂，依赖于客户端的 oom_adj 和绑定服务时使用的 flag。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="comment">//如果该Service还被客户端Bounded，即是Bounded Service时</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> conni = s.connections.size()<span class="number">-1</span>;</span><br><span class="line">            conni &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                    || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                    || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">            conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni);</span><br><span class="line">        <span class="comment">//客户端可以通过一个Connection以不同的参数绑定Service</span></span><br><span class="line">        <span class="comment">//因此，一个Service可以对应多个Connection，一个Connection又对应多个ConnectionRecord</span></span><br><span class="line">        <span class="comment">//这里依次处理每一个ConnectionRecord</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">                i &lt; clist.size() &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                        || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                        || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                i++) &#123;</span><br><span class="line">            ConnectionRecord cr = clist.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cr.binding.client == app) &#123;</span><br><span class="line">                <span class="comment">// Binding to ourself is not interesting.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当BIND_WAIVE_PRIORITY为1时，客户端就不会影响服务端</span></span><br><span class="line">            <span class="comment">//if中的流程就可以略去；否则，客户端就会影响服务端</span></span><br><span class="line">            <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span>) &#123;</span><br><span class="line">                ProcessRecord client = cr.binding.client;</span><br><span class="line">                <span class="comment">//计算出客户端进程的oom_adj</span></span><br><span class="line">                <span class="comment">//由此可看出Android oom_adj的计算多么麻烦</span></span><br><span class="line">                <span class="comment">//要是客户端进程中，又有个服务进程被绑定，那么将再计算其客户端进程的oom_adj</span></span><br><span class="line">                <span class="type">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj,</span><br><span class="line">                        TOP_APP, doingAll, now);</span><br><span class="line">                <span class="type">int</span> clientProcState = client.curProcState;</span><br><span class="line">                <span class="keyword">if</span> (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;</span><br><span class="line">                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">                &#125;</span><br><span class="line">                String adjType = null;</span><br><span class="line">                <span class="comment">//BIND_ALLOW_OOM_MANAGEMENT置为1时，先按照通常的处理方式，调整服务端进程的adjType</span></span><br><span class="line">                <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_ALLOW_OOM_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//与前面分析Unbounded Service基本一致，若进程显示过UI或Service超时</span></span><br><span class="line">                    <span class="comment">//会将clientAdj修改为当前进程的adj，即不需要考虑客户端进程了</span></span><br><span class="line">                    <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                            adjType = <span class="string">&quot;cch-bound-ui-services&quot;</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        app.cached = <span class="literal">false</span>;</span><br><span class="line">                        clientAdj = adj;</span><br><span class="line">                        clientProcState = procState;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (now &gt;= (s.lastActivity</span><br><span class="line">                                + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                                adjType = <span class="string">&quot;cch-bound-services&quot;</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            clientAdj = adj;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据情况，按照clientAdj调整当前进程的adj</span></span><br><span class="line">                <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                            &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                        adjType = <span class="string">&quot;cch-bound-ui-services&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//以下的流程表明，client和flag将同时影响Service进程的adj</span></span><br><span class="line">                        <span class="keyword">if</span> ((cr.flags&amp;(Context.BIND_ABOVE_CLIENT</span><br><span class="line">                                |Context.BIND_IMPORTANT)) != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//从这里再次可以看出，Service重要性小于等于Client</span></span><br><span class="line">                            adj = clientAdj &gt;= ProcessList.PERSISTENT_SERVICE_ADJ</span><br><span class="line">                                    ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;</span><br><span class="line">                        <span class="comment">//BIND_NOT_VISIBLE表示不将服务端当作visible进程看待</span></span><br><span class="line">                        <span class="comment">//于是，即使客户端的adj小于PERCEPTIBLE_APP_ADJ，service也只能取到PERCEPTIBLE_APP_ADJ</span></span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_VISIBLE) != <span class="number">0</span></span><br><span class="line">                                &amp;&amp; clientAdj &lt; ProcessList.PERCEPTIBLE_APP_ADJ</span><br><span class="line">                                &amp;&amp; adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                            adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientAdj &gt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                            adj = clientAdj;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">                                adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//进一步更具client调整当前进程的procState、schedGroup等</span></span><br><span class="line">                    ...</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ...</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">                <span class="keyword">if</span> (procState &gt; clientProcState) &#123;</span><br><span class="line">                    procState = clientProcState;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//其它参数的赋值</span></span><br><span class="line">                ...</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                app.treatLikeActivity = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取出ConnectionRecord所在的Activity</span></span><br><span class="line">            final ActivityRecord a = cr.activity;</span><br><span class="line">            <span class="comment">//BIND_ADJUST_WITH_ACTIVITY值为1时，表示服务端可以根据客户端Activity的oom_adj作出相应的调整</span></span><br><span class="line">            <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a != null &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp;</span><br><span class="line">                        (a.visible || a.state == ActivityState.RESUMED ||</span><br><span class="line">                                a.state == ActivityState.PAUSING)) &#123;</span><br><span class="line">                <span class="comment">//BIND_ADJUST_WITH_ACTIVITY置为1，且绑定的activity可见或在前台时，</span></span><br><span class="line">                <span class="comment">//Service进程的oom_adj可以变为FOREGROUND_APP_ADJ</span></span><br><span class="line">                adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">              <span class="comment">//BIND_NOT_FOREGROUND为0时，才准许调整Service进程的调度优先级</span></span><br><span class="line">                <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</span><br><span class="line">                        schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//改变其它参数</span></span><br><span class="line">                app.cached = <span class="literal">false</span>;</span><br><span class="line">                app.adjType = <span class="string">&quot;service&quot;</span>;</span><br><span class="line">                app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                        .REASON_SERVICE_IN_USE;</span><br><span class="line">                app.adjSource = a;</span><br><span class="line">                app.adjSourceProcState = procState;</span><br><span class="line">                app.adjTarget = s.name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以上就是计算含有 Service 进程的 oom_adj 的全部过程。从代码上看进程仅含有 Unbounded Service 时，整个计算过程比较简单，只要进程没有显示 UI 且 Service 的存在没有超时时，进程的 oom_adj 就被调整为 SERVICE_ADJ。当进程含有 Bounded Service 时，整个计算的复杂度就大大提高，它将考虑到 Bound 使用 flag 以及客户端的情况，综合调整进程的 oom_adj。</p>
<p>4.6 这部分代码主要是用来处理含有 ContentProvider 的进程。由于 ContentProvider 也有客户端，因此同样需要根据客户端进程调整到当前进程的 oom_adj。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//依次处理进程中的ContentProvider</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> provi = app.pubProviders.size()<span class="number">-1</span>;</span><br><span class="line">                provi &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                        || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                        || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                provi--) &#123;</span><br><span class="line">    ContentProviderRecord cpr = app.pubProviders.valueAt(provi);</span><br><span class="line">    <span class="comment">//依次处理ContentProvider的客户端</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cpr.connections.size()<span class="number">-1</span>;</span><br><span class="line">            i &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                    || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                    || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">            i--) &#123;</span><br><span class="line">        ContentProviderConnection conn = cpr.connections.get(i);</span><br><span class="line">        ProcessRecord client = conn.client;</span><br><span class="line">        <span class="keyword">if</span> (client == app) &#123;</span><br><span class="line">            <span class="comment">// Being our own client is not interesting.</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算客户端的oom_adj</span></span><br><span class="line">        <span class="type">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);</span><br><span class="line">        <span class="type">int</span> clientProcState = client.curProcState;</span><br><span class="line">        <span class="keyword">if</span> (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;        </span><br><span class="line">            clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//与Unbounded Service的处理基本类似</span></span><br><span class="line">        <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                    &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                app.adjType = <span class="string">&quot;cch-ui-provider&quot;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//根据clientAdj，调整当前进程的adj</span></span><br><span class="line">                adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                        ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">                        app.adjType = <span class="string">&quot;provider&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//调整其它变量</span></span><br><span class="line">            app.cached &amp;= client.cached;</span><br><span class="line">            app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                    .REASON_PROVIDER_IN_USE;</span><br><span class="line">            app.adjSource = client;</span><br><span class="line">            app.adjSourceProcState = clientProcState;</span><br><span class="line">            app.adjTarget = cpr.name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进一步调整调度策略和procState</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//特殊情况的处理</span></span><br><span class="line">        <span class="keyword">if</span> (cpr.hasExternalProcessHandles()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">                adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">                schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">                app.cached = <span class="literal">false</span>;</span><br><span class="line">                app.adjType = <span class="string">&quot;provider&quot;</span>;</span><br><span class="line">                app.adjTarget = cpr.name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123;</span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果进程之前运行过ContentProvider，同时ContentProvider的存活时间没有超时</span></span><br><span class="line"><span class="comment">//那么进程的adj可以变为PREVIOUS_APP_ADJ</span></span><br><span class="line"><span class="keyword">if</span> (app.lastProviderTime &gt; <span class="number">0</span> &amp;&amp; (app.lastProviderTime+CONTENT_PROVIDER_RETAIN_TIME) &gt; now) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;provider&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>从代码上看，处理含有 ContentProvider 进程时，相对比较简单。基本上与处理含有 Unbounded Service 的进程一致，只是最后增加了一些特殊情况的处理。</p>
<p>4.7 这部分代码主要是针对 Service 进程作一些处理，同时判断的依据与前一次记录的 Service 进程总数有关。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据进程信息，进一步调整procState</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//对Service进程做一些特殊处理</span></span><br><span class="line"><span class="keyword">if</span> (adj == ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doingAll) &#123;</span><br><span class="line">        <span class="comment">//每次updateOomAdj时，将mNewNumAServiceProcs置为0</span></span><br><span class="line">        <span class="comment">//然后LRU list中，从后往前数，前1/3的service进程就是AService</span></span><br><span class="line">        <span class="comment">//其余的就是bService</span></span><br><span class="line">        <span class="comment">//mNumServiceProcs为上一次update时，service进程的数量</span></span><br><span class="line">        app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs/<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//记录这一次update后，service进程的数量</span></span><br><span class="line">        <span class="comment">//update完毕后，该值将赋给mNumServiceProcs</span></span><br><span class="line">        mNewNumServiceProcs++;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!app.serviceb) &#123;</span><br><span class="line">            <span class="comment">// 如果不是bService，但内存回收等级过高，也被视为bService</span></span><br><span class="line">            <span class="keyword">if</span> (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL</span><br><span class="line">                    &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) &#123;</span><br><span class="line">                app.serviceHighRam = <span class="literal">true</span>;</span><br><span class="line">                app.serviceb = <span class="literal">true</span>;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//LRU中后1/3的Service，都是AService</span></span><br><span class="line">                mNewNumAServiceProcs++;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app.serviceHighRam = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将bService的oom_adj调整为SERVICE_B_ADJ</span></span><br><span class="line">    <span class="keyword">if</span> (app.serviceb) &#123;</span><br><span class="line">        adj = ProcessList.SERVICE_B_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算完毕</span></span><br><span class="line">app.curRawAdj = adj;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//if基本没有用，maxAdj已经是最大的UNKNOW_ADJ</span></span><br><span class="line"><span class="keyword">if</span> (adj &gt; app.maxAdj) &#123;</span><br><span class="line">    adj = app.maxAdj;</span><br><span class="line">    <span class="keyword">if</span> (app.maxAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最后做一些记录和调整</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> app.curRawAdj;</span><br></pre></td></tr></table></figure>
<h2 id="二processlistjava"><a class="markdownIt-Anchor" href="#二processlistjava">#</a> （二）ProcessList.java</h2>
<h3 id="1-updataoomlevels方法"><a class="markdownIt-Anchor" href="#1-updataoomlevels方法">#</a> 1. updataOomLevels 方法</h3>
<p>updateOomLevels 方法只是简单的计算出 oomMinFree 数组的值和 oomAdj 值，然后通过 writeLmkd 将数据发送给 lmkd。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> <span class="title function_">updateOomLevels</span><span class="params">(<span class="type">int</span> displayWidth, <span class="type">int</span> displayHeight, boolean write)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算memory的scale数值</span></span><br><span class="line">        <span class="type">float</span> scaleMem = ((<span class="type">float</span>)(mTotalMemMb<span class="number">-350</span>))/(<span class="number">700</span><span class="number">-350</span>);</span><br><span class="line">        <span class="comment">// 计算显示屏的scale值</span></span><br><span class="line">        <span class="type">int</span> minSize = <span class="number">480</span>*<span class="number">800</span>;  <span class="comment">//  384000</span></span><br><span class="line">        <span class="type">int</span> maxSize = <span class="number">1280</span>*<span class="number">800</span>; <span class="comment">// 1024000  230400 870400  .264</span></span><br><span class="line">        <span class="type">float</span> scaleDisp = ((<span class="type">float</span>)(displayWidth*displayHeight)-minSize)/(maxSize-minSize);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            Slog.i(<span class="string">&quot;XXXXXX&quot;</span>, <span class="string">&quot;scaleMem=&quot;</span> + scaleMem);</span><br><span class="line">            Slog.i(<span class="string">&quot;XXXXXX&quot;</span>, <span class="string">&quot;scaleDisp=&quot;</span> + scaleDisp + <span class="string">&quot; dw=&quot;</span> + displayWidth</span><br><span class="line">                    + <span class="string">&quot; dh=&quot;</span> + displayHeight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//比较memory和显示屏scale值的大小，取较大值</span></span><br><span class="line">        <span class="type">float</span> scale = scaleMem &gt; scaleDisp ? scaleMem : scaleDisp;</span><br><span class="line">        <span class="keyword">if</span> (scale &lt; <span class="number">0</span>) scale = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (scale &gt; <span class="number">1</span>) scale = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> minfree_adj = Resources.getSystem().getInteger(</span><br><span class="line">    com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAdjust);</span><br><span class="line">        <span class="type">int</span> minfree_abs = Resources.getSystem().getInteger(</span><br><span class="line">                com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAbsolute);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">            Slog.i(<span class="string">&quot;XXXXXX&quot;</span>, <span class="string">&quot;minfree_adj=&quot;</span> + minfree_adj + <span class="string">&quot; minfree_abs=&quot;</span> + minfree_abs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否为64位系统</span></span><br><span class="line">        final boolean is64bit = Build.SUPPORTED_64_BIT_ABIS.length &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//根据mOomMinFreeLow、mOomMinFreeHigh和scale值填充mOomMinFree数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mOomAdj.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> low = mOomMinFreeLow[i];</span><br><span class="line">            <span class="type">int</span> high = mOomMinFreeHigh[i];</span><br><span class="line">            <span class="comment">//如果是64位系统，第四和第五级的数值会稍大一点</span></span><br><span class="line">            <span class="keyword">if</span> (is64bit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">4</span>) high = (high*<span class="number">3</span>)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) high = (high*<span class="number">7</span>)/<span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mOomMinFree[i] = (<span class="type">int</span>)(low + ((high-low)*scale));</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        mCachedRestoreLevel = (getMemLevel(ProcessList.CACHED_APP_MAX_ADJ)/<span class="number">1024</span>) / <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> reserve = displayWidth * displayHeight * <span class="number">4</span> * <span class="number">3</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="type">int</span> reserve_adj = Resources.getSystem().getInteger(com.android.internal.R.integer.config_extraFreeKbytesAdjust);</span><br><span class="line">        <span class="type">int</span> reserve_abs = Resources.getSystem().getInteger(com.android.internal.R.integer.config_extraFreeKbytesAbsolute);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果需要写入则调用writelmkd将buf写入到lowmemoryKiller中</span></span><br><span class="line">        <span class="keyword">if</span> (write) &#123;</span><br><span class="line">            ByteBuffer buf = ByteBuffer.allocate(<span class="number">4</span> * (<span class="number">2</span>*mOomAdj.length + <span class="number">1</span>));</span><br><span class="line">            buf.putInt(LMK_TARGET);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;mOomAdj.length; i++) &#123;</span><br><span class="line">                buf.putInt((mOomMinFree[i]*<span class="number">1024</span>)/PAGE_SIZE);</span><br><span class="line">                buf.putInt(mOomAdj[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            writeLmkd(buf);</span><br><span class="line">            SystemProperties.<span class="built_in">set</span>(<span class="string">&quot;sys.sysctl.extra_free_kbytes&quot;</span>, Integer.toString(reserve));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// GB: 2048,3072,4096,6144,7168,8192</span></span><br><span class="line">        <span class="comment">// HC: 8192,10240,12288,14336,16384,20480</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-writelmkd方法"><a class="markdownIt-Anchor" href="#2-writelmkd方法">#</a> 2. writeLmkd 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeLmkd</span><span class="params">(ByteBuffer buf)</span> &#123;</span><br><span class="line">        <span class="comment">//尝试打开lmkd socket端口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sLmkdSocket == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (openLmkdSocket() == <span class="literal">false</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//将数据写到socket端口中</span></span><br><span class="line">                sLmkdOutputStream.write(buf.array(), <span class="number">0</span>, buf.position());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">&quot;Error writing to lowmemorykiller socket&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sLmkdSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex2) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                sLmkdSocket = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">openLmkdSocket</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建本地socket句柄，尝试连接socket</span></span><br><span class="line">            sLmkdSocket = <span class="keyword">new</span> <span class="title class_">LocalSocket</span>(LocalSocket.SOCKET_SEQPACKET);</span><br><span class="line">            <span class="comment">//连接本地名为lmkd的本地socket</span></span><br><span class="line">            sLmkdSocket.connect(</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">LocalSocketAddress</span>(<span class="string">&quot;lmkd&quot;</span>,</span><br><span class="line">                        LocalSocketAddress.Namespace.RESERVED));</span><br><span class="line">            <span class="comment">//获取lmkd socket的输出流，用于向对端写入数据</span></span><br><span class="line">            sLmkdOutputStream = sLmkdSocket.getOutputStream();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">&quot;lowmemorykiller daemon socket open failed&quot;</span>);</span><br><span class="line">            sLmkdSocket = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三lmkdc"><a class="markdownIt-Anchor" href="#三lmkdc">#</a> （三）lmkd.c</h2>
<p>lmk 与大多数守护进程一样，由 init 进程启动：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">service lmkd /system/bin/lmkd</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">core</span></span><br><span class="line">    user lmkd</span><br><span class="line">    group lmkd system readproc</span><br><span class="line">    capabilities DAC_OVERRIDE KILL IPC_LOCK SYS_NICE SYS_RESOURCE</span><br><span class="line">    critical</span><br><span class="line">    socket lmkd seqpacket+passcred <span class="number">0660</span> system system</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line"></span><br><span class="line">on property:lmkd.reinit=<span class="number">1</span></span><br><span class="line">    exec_background /system/bin/lmkd --reinit</span><br></pre></td></tr></table></figure>
<p>这里创建的 socket lmkd 的 user/group 都是 system，而它的权限是 0660，所以只有 system 应用才能读写（一般是 activity manager）。</p>
<h3 id="1-main函数"><a class="markdownIt-Anchor" href="#1-main函数">#</a> 1. main 函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span> **argv __unused)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123; <span class="comment">//添加调度策略，即先进先出</span></span><br><span class="line">            .sched_priority = <span class="number">1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    mlockall(MCL_FUTURE); <span class="comment">//给虚拟空间上锁，防止内存交换</span></span><br><span class="line">    sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param);</span><br><span class="line">    <span class="keyword">if</span> (!init()) <span class="comment">//init 处理所有核心的初始化工作</span></span><br><span class="line">        mainloop();</span><br><span class="line"></span><br><span class="line">    ALOGI(<span class="string">&quot;exiting&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新版供对比</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    update_props(); <span class="comment">//step 1，进程最初，需要获取所有的lmkd 的prop，为init 做准备</span></span><br><span class="line"> </span><br><span class="line">    ctx = create_android_logger(KILLINFO_LOG_TAG);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!init()) &#123; <span class="comment">//step 2，init 处理所有核心的初始化工作</span></span><br><span class="line">        <span class="keyword">if</span> (!use_inkernel_interface) &#123; <span class="comment">//step 3，如果不再使用旧的LMK 驱动程序</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//step4, 给虚拟空间上锁，防止内存交换</span></span><br><span class="line">            <span class="keyword">if</span> (mlockall(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; (errno != EINVAL)) &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;mlockall failed %s&quot;</span>, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//step 4，添加调度策略，即先进先出</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">param</span> =</span> &#123;</span><br><span class="line">                    .sched_priority = <span class="number">1</span>,</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">if</span> (sched_setscheduler(<span class="number">0</span>, SCHED_FIFO, &amp;param)) &#123;</span><br><span class="line">                ALOGW(<span class="string">&quot;set SCHED_FIFO failed %s&quot;</span>, strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        mainloop(); <span class="comment">//step 5， 进入循环，等待polling</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    android_log_destroy(&amp;ctx);</span><br><span class="line"> </span><br><span class="line">    ALOGI(<span class="string">&quot;exiting&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 shed_setscheduler () 中，设置此线程的调度策略为 SCHED_FIFO，即为先进先出；通过 SHED_FIFO 这种实时调度策略，优先级从 1 (low)-&gt;99（high）。param 中主要设置 sched_priority，实时线程通常比普通线程有更高的优先级。然后就调用 init 进行初始化，进入 mainloop () 中循环监听 socket。</p>
<p>在新版代码中可以看到 lmkd 的核心部分在 step2（init）和 step5（mainloop），之后将单独说明</p>
<p>这里需注意到 mlockall 函数，在新的 LMK 驱动程序中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">mlockall</span>(MCL_CURRENT | MCL_FUTURE | MCL_ONFAULT) &amp;&amp; (errno != EINVAL)) &#123;</span><br><span class="line">    <span class="built_in">ALOGW</span>(<span class="string">&quot;mlockall failed %s&quot;</span>, <span class="built_in">strerror</span>(errno));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>mlockall 函数将调用进程的全部虚拟地址空间加锁。防止出现内存交换，将该进程的地址空间交换到外存上。</li>
<li>mlockall 将所有映射到进程地址空间的内存上锁。这些页包括： 代码段，数据段，栈段，共享库，共享内存，user space kernel data,memory-mapped file. 当函数成功返回的时候，所有的被映射的页都在内存中。</li>
<li>flags 可取两个值：MCL_CURRENT,MCL_FUTURE
<ul>
<li>MCL_CURRENT: 表示对所有已经映射到进程地址空间的页上锁</li>
<li>MCL_FUTURE: 表示对所有将来映射到进程地空间的页都上锁。</li>
</ul>
</li>
<li>函数返回： 成功返回 0，出错返回 - 1</li>
<li>此函数有两个重要的应用： real-time algorithms (实时算法) 和 high-security data processing (机密数据的处理)
<ul>
<li>real-time algorithms：对时间要非常高。</li>
</ul>
</li>
<li>如果进程执行了一个 execve 类函数，所有的锁都会被删除。</li>
<li>内存锁不会被子进程继承。</li>
<li>内存锁不会叠加，即使多次调用 mlockall 函数，只调用一次 munlock 就会解锁</li>
</ul>
<h3 id="2-init"><a class="markdownIt-Anchor" href="#2-init">#</a> 2. init</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//epoll事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret;  </span><br><span class="line">    page_k = sysconf(_SC_PAGESIZE);</span><br><span class="line">    <span class="keyword">if</span> (page_k == <span class="number">-1</span>)</span><br><span class="line">        page_k = PAGE_SIZE;</span><br><span class="line">    page_k /= <span class="number">1024</span>;</span><br><span class="line">    <span class="comment">//创建epoll文件句柄</span></span><br><span class="line">    epollfd = epoll_create(MAX_EPOLL_EVENTS);</span><br><span class="line">    <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;epoll_create failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取lmkd socket的控制权</span></span><br><span class="line">    ctrl_lfd = android_get_control_socket(<span class="string">&quot;lmkd&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (ctrl_lfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;get lmkd control socket failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听lmkd socket</span></span><br><span class="line">    ret = listen(ctrl_lfd, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;lmkd control socket listen failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//设置epoll事件的触发方式</span></span><br><span class="line">epev.events = EPOLLIN;</span><br><span class="line"><span class="comment">//设置epoll事件的处理函数</span></span><br><span class="line">epev.data.ptr = (<span class="type">void</span> *)ctrl_connect_handler;</span><br><span class="line"><span class="comment">//在epollfd中添加对lmkd socket文件句柄的监听</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_lfd, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;epoll_ctl for lmkd control socket failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">maxevents++;</span><br><span class="line"><span class="comment">//判断INKERNEL_MINFREE_PATH是否有写权限，INKERNEL_MINFREE_PATH定义如下：</span></span><br><span class="line"><span class="comment">//#define INKERNEL_MINFRE_PATH </span></span><br><span class="line"><span class="comment">//“/sys/module/lowmemorykiller/parameters/minfree”</span></span><br><span class="line">use_inkernel_interface = !access(INKERNEL_MINFREE_PATH, W_OK);</span><br><span class="line"> <span class="keyword">if</span> (use_inkernel_interface) &#123;</span><br><span class="line">      ALOGI(<span class="string">&quot;Using in-kernel low memory killer interface&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       ret = init_mp(MEMPRESSURE_WATCH_LEVEL, (<span class="type">void</span> *)&amp;mp_event);</span><br><span class="line">        <span class="keyword">if</span> (ret)</span><br><span class="line">           ALOGE(<span class="string">&quot;Kernel does not support memory pressure events or in-kernel low memory killer&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= ADJTOSLOT(OOM_SCORE_ADJ_MAX); i++) &#123;</span><br><span class="line">        procadjslot_list[i].next = &amp;procadjslot_list[i];</span><br><span class="line">        procadjslot_list[i].prev = &amp;procadjslot_list[i];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="21-创建epoll"><a class="markdownIt-Anchor" href="#21-创建epoll">#</a> 2.1 创建 epoll</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">epollfd = epoll_create(MAX_EPOLL_EVENTS);</span><br><span class="line">   <span class="keyword">if</span> (epollfd == <span class="number">-1</span>) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;epoll_create failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>整个 lmkd 都是依赖 epoll 机制，这里创建了 9 个 event：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1 ctrl listen socket, 3 ctrl data socket, 3 memory pressure levels,</span></span><br><span class="line"><span class="comment"> * 1 lmk events + 1 fd to wait for process death</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_EPOLL_EVENTS (1 + MAX_DATA_CONN + VMPRESS_LEVEL_COUNT + 1 + 1)</span></span><br></pre></td></tr></table></figure>
<h4 id="22-初始化socket-lmkd"><a class="markdownIt-Anchor" href="#22-初始化socket-lmkd">#</a> 2.2 初始化 socket lmkd</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ctrl_sock.sock = android_get_control_socket(<span class="string">&quot;lmkd&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ctrl_sock.sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;get lmkd control socket failed&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = listen(ctrl_sock.sock, MAX_DATA_CONN);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;lmkd control socket listen failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epev.events = EPOLLIN;</span><br><span class="line">ctrl_sock.handler_info.handler = ctrl_connect_handler;</span><br><span class="line">epev.data.ptr = (<span class="type">void</span> *)&amp;(ctrl_sock.handler_info);</span><br><span class="line"><span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_sock.sock, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">&quot;epoll_ctl for lmkd control socket failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">maxevents++;</span><br></pre></td></tr></table></figure>
<p>ctrl_sock 主要存储的是 socket lmkd 的 fd 和 handle info，主要注意这里的 ctrl_connect_handler ()</p>
<p>该函数时 socket /dev/socket/lmkd 有信息时的处理函数，lmkd 的客户端 AMS.mProcessList 会通过 socket /dev/socket/lmkd 与 lmkd 进行通信。</p>
<h4 id="23-确定是否使用lmk驱动程序"><a class="markdownIt-Anchor" href="#23-确定是否使用lmk驱动程序">#</a> 2.3 确定是否使用 LMK 驱动程序</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INKERNEL_MINFREE_PATH <span class="string">&quot;/sys/module/lowmemorykiller/parameters/minfree&quot;</span></span></span><br><span class="line"></span><br><span class="line">  has_inkernel_module = !access(INKERNEL_MINFREE_PATH, W_OK);</span><br><span class="line">  use_inkernel_interface = has_inkernel_module;</span><br></pre></td></tr></table></figure>
<p>通过 <code>access</code>  函数确认旧的节点是否还存在，用于确认 kernel 是否还在使用 LMK 程序（kernel 4.12 已废弃）</p>
<h4 id="24-init_monitors"><a class="markdownIt-Anchor" href="#24-init_monitors">#</a> 2.4 init_monitors</h4>
<p>该函数是 init 函数中的核心了，这里用来注册 PSI 的监视器策略（Android11 及以后）或者是 common 的 adj 策略 (vmpressure，Android11 之前)，并将其添加到 epoll 中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">init_monitors</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">/* Try to use psi monitor first if kernel has it */</span></span><br><span class="line">    use_psi_monitors = property_get_bool(<span class="string">&quot;ro.lmk.use_psi&quot;</span>, <span class="literal">true</span>) &amp;&amp;</span><br><span class="line">        init_psi_monitors();</span><br><span class="line">    <span class="comment">/* Fall back to vmpressure */</span></span><br><span class="line">    <span class="keyword">if</span> (!use_psi_monitors &amp;&amp;</span><br><span class="line">        (!init_mp_common(VMPRESS_LEVEL_LOW) ||</span><br><span class="line">        !init_mp_common(VMPRESS_LEVEL_MEDIUM) ||</span><br><span class="line">        !init_mp_common(VMPRESS_LEVEL_CRITICAL))) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Kernel does not support memory pressure events or in-kernel low memory killer&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use_psi_monitors) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Using psi monitors for memory pressure detection&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;Using vmpressure for memory pressure detection&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果使用vmpressure，则通过init_mp_common 来初始化kill 策略；</span><br><span class="line">- 如果使用PSI，则通过init_psi_monitors 来初始化kill 策略；</span><br><span class="line"></span><br><span class="line">所以lmkd 中如果使用 PSI ，要求 ro.lmk.use_psi 为 true(注：博主说的其实有点问题，property_get_bool函数中的参数true为默认值，该值不设置即默认返回为true，并不需要设置为true)。</span><br><span class="line"></span><br><span class="line">另外，lmkd 支持旧模式的kill 策略，只要 ro.lmk.use_new_strategy 设为false，或者将ro.lmk.use_minfree_levels 设为true（针对非低内存设备，即ro.config.low_ram 不为true）。</span><br><span class="line"></span><br><span class="line">继续深入分析init_psi_monitors()函数。</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">static bool init_psi_monitors() &#123;</span><br><span class="line">    /*</span><br><span class="line">     * When PSI is used on low-ram devices or on high-end devices without memfree levels</span><br><span class="line">     * use new kill strategy based on zone watermarks, free swap and thrashing stats</span><br><span class="line">     */</span><br><span class="line">    bool use_new_strategy =</span><br><span class="line">        property_get_bool(&quot;ro.lmk.use_new_strategy&quot;, low_ram_device || !use_minfree_levels);</span><br><span class="line"></span><br><span class="line">    /* In default PSI mode override stall amounts using system properties */</span><br><span class="line">    if (use_new_strategy) &#123;</span><br><span class="line">        /* Do not use low pressure level */</span><br><span class="line">        psi_thresholds[VMPRESS_LEVEL_LOW].threshold_ms = 0;</span><br><span class="line">        psi_thresholds[VMPRESS_LEVEL_MEDIUM].threshold_ms = psi_partial_stall_ms;</span><br><span class="line">        psi_thresholds[VMPRESS_LEVEL_CRITICAL].threshold_ms = psi_complete_stall_ms;</span><br><span class="line">    &#125;</span><br><span class="line">    // mp应该时memory pressure的意思</span><br><span class="line">    if (!init_mp_psi(VMPRESS_LEVEL_LOW, use_new_strategy)) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!init_mp_psi(VMPRESS_LEVEL_MEDIUM, use_new_strategy)) &#123;</span><br><span class="line">        destroy_mp_psi(VMPRESS_LEVEL_LOW);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!init_mp_psi(VMPRESS_LEVEL_CRITICAL, use_new_strategy)) &#123;</span><br><span class="line">        destroy_mp_psi(VMPRESS_LEVEL_MEDIUM);</span><br><span class="line">        destroy_mp_psi(VMPRESS_LEVEL_LOW);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数比较简单的，最开始的变量 <code>use_new_strategy</code>  用以确认是使用 PSI 策略还是 vmpressure。如果是使用 PSI 策略， <code>psi_thresholds</code>  数组中的 <code>threshold_ms</code>  需要重新赋值为 prop 指定的值（也就是说支持动态配置）。最后通过 <code>init_mp_psi</code>  为每个级别的 strategy 进行最后的注册，当然对于 PSI，只有 some 和 full 等级，所以与 level 中的 medium 和 critical 分别对应。</p>
<p>这里的 <code>psi_thresholds</code>  数组中 <code>threshold_ms</code>  通过 prop：</p>
<ul>
<li>ro.lmk.psi_partial_stall_ms low_ram 默认为 200ms，PSI 默认为 70ms；</li>
<li>ro.lmk.psi_complete_stall_ms 默认 700ms；</li>
</ul>
<p>对于 <code>init_mp_psi</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">bool</span> <span class="title function_">init_mp_psi</span><span class="params">(<span class="keyword">enum</span> vmpressure_level level, <span class="type">bool</span> use_new_strategy)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Do not register a handler if threshold_ms is not set */</span></span><br><span class="line">    <span class="keyword">if</span> (!psi_thresholds[level].threshold_ms) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里</span></span><br><span class="line">    fd = init_psi_monitor(psi_thresholds[level].stall_type,</span><br><span class="line">        psi_thresholds[level].threshold_ms * US_PER_MS,</span><br><span class="line">        PSI_WINDOW_SIZE_MS * US_PER_MS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vmpressure_hinfo[level].handler = use_new_strategy ? mp_event_psi : mp_event_common;</span><br><span class="line">    vmpressure_hinfo[level].data = level;</span><br><span class="line">    <span class="keyword">if</span> (register_psi_monitor(epollfd, fd, &amp;vmpressure_hinfo[level]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        destroy_psi_monitor(fd);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    maxevents++;</span><br><span class="line">    mpevfd[level] = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 init_psi_monitor 将不同 level 的值写入节点 /proc/pressure/memory，后期阈值如果超过了设定就会触发一次 epoll；</li>
<li>根据 use_new_strategy，选择是新策略 mp_event_psi，还是旧模式 mp_event_common，详细的策略见第 8 节和第 10 节；</li>
<li>通过 register_psi_monitor 将节点 /proc/pressure/memory 添加到 epoll 中监听；</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mp_event_psi</span><span class="params">(<span class="type">int</span> data, <span class="type">uint32_t</span> events, <span class="keyword">struct</span> polling_params *poll_params)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">reclaim_state</span> &#123;</span></span><br><span class="line">        NO_RECLAIM = <span class="number">0</span>,</span><br><span class="line">        KSWAPD_RECLAIM,</span><br><span class="line">        DIRECT_RECLAIM,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="25-标记进入lmkd流程"><a class="markdownIt-Anchor" href="#25-标记进入lmkd流程">#</a> 2.5 标记进入 lmkd 流程</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* let the others know it does support reporting kills */</span></span><br><span class="line">property_set(<span class="string">&quot;sys.lmk.reportkills&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="26-其他初始化"><a class="markdownIt-Anchor" href="#26-其他初始化">#</a> 2.6 其他初始化</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(killcnt_idx, KILLCNT_INVALID_IDX, <span class="keyword">sizeof</span>(killcnt_idx));</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * Read zoneinfo as the biggest file we read to create and size the initial</span></span><br><span class="line"><span class="comment">    * read buffer and avoid memory re-allocations during memory pressure</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (reread_file(&amp;file_data) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       ALOGE(<span class="string">&quot;Failed to read %s: %s&quot;</span>, file_data.filename, strerror(errno));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* check if kernel supports pidfd_open syscall */</span></span><br><span class="line">   pidfd = TEMP_FAILURE_RETRY(pidfd_open(getpid(), <span class="number">0</span>));</span><br><span class="line">   <span class="keyword">if</span> (pidfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       pidfd_supported = (errno != ENOSYS);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       pidfd_supported = <span class="literal">true</span>;</span><br><span class="line">       close(pidfd);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是 <code>reread_file</code>  函数，用来占坑。通过读取  <code>/proc/zoneinfo</code> ，创建一个最大 size 的 buffer，后面的其他节点都直接使用该 buffer，而不用再重新 malloc。详细看 <code>reread_file()</code>  中的 buf 变量。</p>
<p>另外，通过 <code>sys_pidfd_open</code> ，确定是否支持 <code>pidfd_open</code>  的 syscall。</p>
<p>至此，init 基本剖析完成，主要：</p>
<ul>
<li>创建 epoll，用以监听 9 个 event；</li>
<li>初始化 <code>socket /dev/socket/lmkd</code> ，并将其添加到 epoll 中；</li>
<li>根据 prop  <code>ro.lmk.use_psi</code>  确认是否使用 PSI 还是 vmpressure；</li>
<li>根据 prop  <code>ro.lmk.use_new_strategy</code>  或者通过 prop  <code>ro.lmk.use_minfree_levels</code>  和 prop  <code>ro.config.low_ram</code>  使用 PSI 时的新策略还是旧策略；</li>
<li>新、旧策略主要体现在 <code>mp_event_psi</code>  和 <code>mp_event_common</code>  处理，而本质都是通过节点  <code>/proc/pressure/memory</code>  获取内存压力是否达到 some/full 指定来确认是否触发 event；</li>
<li>后期 epoll 触发主要的处理函数是 <code>mp_event_psi</code>  或  <code>mp_event_common</code> ；</li>
</ul>
<h3 id="3-mainloop"><a class="markdownIt-Anchor" href="#3-mainloop">#</a> 3. mainloop</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mainloop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//一直循环等待</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[<span class="title">maxevents</span>];</span></span><br><span class="line">        <span class="type">int</span> nevents;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        ctrl_dfd_reopened = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//在init方法中，我们已经经lmkd socket的listen事件添加到epollfd中</span></span><br><span class="line">        <span class="comment">//并等待epollfd事件除法</span></span><br><span class="line">        nevents = epoll_wait(epollfd, events, maxevents, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (nevents == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            ALOGE(<span class="string">&quot;epoll_wait failed (errno=%d)&quot;</span>, errno);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理listen事件到来</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nevents; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (events[i].events &amp; EPOLLERR)</span><br><span class="line">                ALOGD(<span class="string">&quot;EPOLLERR on event #%d&quot;</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (events[i].data.ptr)</span><br><span class="line">                (*(<span class="type">void</span> (*)(<span class="type">uint32_t</span>))events[i].data.ptr)(events[i].events);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 mainloop 方法中，epoll_wait 在等到 lmkd socket 的 listen 事件到来，然后再调用 event.data.ptr 方法。在 Init 方法中，我们将 event.data.ptr 指向 ctrl_connect_handler 方法。</p>
<h3 id="4ctrl_connect_handler方法"><a class="markdownIt-Anchor" href="#4ctrl_connect_handler方法">#</a> 4.ctrl_connect_handler 方法</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ctrl_connect_handler</span><span class="params">(<span class="type">uint32_t</span> events __unused)</span> &#123;</span><br><span class="line">    <span class="comment">//这里创建了另一个epoll事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> alen;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">epev</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (ctrl_dfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        ctrl_data_close();</span><br><span class="line">        ctrl_dfd_reopened = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接受lmkd socket的连接请求</span></span><br><span class="line">    alen = <span class="keyword">sizeof</span>(addr);</span><br><span class="line">    ctrl_dfd = accept(ctrl_lfd, &amp;addr, &amp;alen);</span><br><span class="line">    <span class="keyword">if</span> (ctrl_dfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;lmkd control socket accept failed; errno=%d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ALOGI(<span class="string">&quot;ActivityManager connected&quot;</span>);</span><br><span class="line">maxevents++;</span><br><span class="line"><span class="comment">//设置empoll监听事件</span></span><br><span class="line">epev.events = EPOLLIN;</span><br><span class="line"><span class="comment">//设置epoll处理函数</span></span><br><span class="line">epev.data.ptr = (<span class="type">void</span> *)ctrl_data_handler;</span><br><span class="line"><span class="comment">//将accept后的socket套接字添加到epollfd中进行监听</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(epollfd, EPOLL_CTL_ADD, ctrl_dfd, &amp;epev) == <span class="number">-1</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;epoll_ctl for data connection socket failed; errno=%d&quot;</span>, errno);</span><br><span class="line">        ctrl_data_close();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ctrl_connect_handler 方法在处理 lmkd socket 的 listen 事件时，会像 epoll 创建另一个 epoll 事件一样，用于处理 lmkd socket 的 accept 事件，accetpt 事件的处理方法为 <code>ctrl_data_handler</code> 。</p>
<h3 id="5-ctrl_data_handler方法"><a class="markdownIt-Anchor" href="#5-ctrl_data_handler方法">#</a> 5. ctrl_data_handler 方法</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ctrl_data_handler</span><span class="params">(<span class="type">uint32_t</span> events)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; EPOLLHUP) &#123;</span><br><span class="line">        ALOGI(<span class="string">&quot;ActivityManager disconnected&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!ctrl_dfd_reopened)</span><br><span class="line">            ctrl_data_close();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events &amp; EPOLLIN) &#123;</span><br><span class="line">    <span class="comment">//处理epoll事件，即文件句柄的读事件</span></span><br><span class="line">        ctrl_command_handler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当时添加到 epoll 时是以 EPOLLIN 添加的，所以这里接着会调用 ctrl_command_handler</p>
<h3 id="6-ctrl_command_handler-方法"><a class="markdownIt-Anchor" href="#6-ctrl_command_handler-方法">#</a> 6. ctrl_command_handler 方法</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ctrl_command_handler</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//读取数据buffer</span></span><br><span class="line">    <span class="type">int</span> ibuf[CTRL_PACKET_MAX / <span class="keyword">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> cmd = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> nargs;</span><br><span class="line">    <span class="type">int</span> targets;</span><br><span class="line">    <span class="comment">//读取数据到ibuf中</span></span><br><span class="line">    len = ctrl_data_read((<span class="type">char</span> *)ibuf, CTRL_PACKET_MAX);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获取数据长度</span></span><br><span class="line">    nargs = len / <span class="keyword">sizeof</span>(<span class="type">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (nargs &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> wronglen;</span><br><span class="line">   <span class="comment">//解析处数据中的comand字段</span></span><br><span class="line">    cmd = ntohl(ibuf[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//根据不同长度的command字段，调用不同的数据处理方法</span></span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">    <span class="keyword">case</span> LMK_TARGET:</span><br><span class="line">        targets = nargs / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nargs &amp; <span class="number">0x1</span> || targets &gt; (<span class="type">int</span>)ARRAY_SIZE(lowmem_adj))</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_target(targets, &amp;ibuf[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LMK_PROCPRIO:</span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_procprio(ntohl(ibuf[<span class="number">1</span>]), ntohl(ibuf[<span class="number">2</span>]), ntohl(ibuf[<span class="number">3</span>]));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> LMK_PROCREMOVE:</span><br><span class="line">        <span class="keyword">if</span> (nargs != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">goto</span> wronglen;</span><br><span class="line">        cmd_procremove(ntohl(ibuf[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ALOGE(<span class="string">&quot;Received unknown command code %d&quot;</span>, cmd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">wronglen:</span><br><span class="line">    ALOGE(<span class="string">&quot;Wrong control socket read length cmd=%d len=%d&quot;</span>, cmd, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要处理从 ProcessList.java 中发出的几个 lmk command：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">lmk_cmd</span> &#123;</span></span><br><span class="line">    LMK_TARGET, <span class="comment">/* Associate minfree with oom_adj_score */</span></span><br><span class="line">    LMK_PROCPRIO,   <span class="comment">/* Register a process and set its oom_adj_score */</span></span><br><span class="line">    LMK_PROCREMOVE, <span class="comment">/* Unregister a process */</span></span><br><span class="line">  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中 LMK_TARGET 用于更新系统 oom_adj，framework 发出该 command 的方法是 PorcessList.updateOomLevels ();LMK_PROCPRIO 用于更新进程 adj，framework 发出该 command 的方法是 PorcessList.setOomAdj ()；LMK_PROCPRIO 用于移除进程，framework 发出该 command 的方法是 PorcessList.remove ()。</p>
<h5 id="61-cmd_target-方法"><a class="markdownIt-Anchor" href="#61-cmd_target-方法">#</a> 6.1 cmd_target 方法</h5>
<p>从 ProcessList.java 中得知在 ProcessList 构造时会初始化一次，另外会在 ATMS.updateConfiguration 是会触发：</p>
<p>frameworks/base/services/core/java/com/android/server/wm/ActivityTaskManagerService.java</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean <span class="title function_">updateConfiguration</span><span class="params">(Configuration values)</span> &#123;</span><br><span class="line">        mAmInternal.enforceCallingPermission(CHANGE_CONFIGURATION, <span class="string">&quot;updateConfiguration()&quot;</span>);</span><br><span class="line">		synchronized (mGlobalLock) &#123;</span><br><span class="line">        ...</span><br><span class="line"> </span><br><span class="line">        mH.sendMessage(PooledLambda.obtainMessage(</span><br><span class="line">                ActivityManagerInternal::updateOomLevelsForDisplay, mAmInternal,</span><br><span class="line">                DEFAULT_DISPLAY));</span><br><span class="line"> </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用到 ProcessList.updateOomLevels ()</p>
<p>frameworks/base/servcies/core/java/com/android/server/am/ProcessList.java</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> <span class="title function_">updateOomLevels</span><span class="params">(<span class="type">int</span> displayWidth, <span class="type">int</span> displayHeight, boolean write)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">4</span> * (<span class="number">2</span> * mOomAdj.length + <span class="number">1</span>));</span><br><span class="line">        buf.putInt(LMK_TARGET);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mOomAdj.length; i++) &#123;</span><br><span class="line">            buf.putInt((mOomMinFree[i] * <span class="number">1024</span>)/PAGE_SIZE);</span><br><span class="line">            buf.putInt(mOomAdj[i]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        writeLmkd(buf, null);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统通过这个函数计算 oom adj 的 minfree，并将各个级别的 minfree 和 oom_adj_score 传入到 lmkd 中，继续跟进 lmkd 的 cmd_target：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmd_target</span><span class="params">(<span class="type">int</span> ntargets, <span class="type">int</span> *params)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (ntargets &gt; (<span class="type">int</span>)ARRAY_SIZE(lowmem_adj))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//将framework传过来的参数保存到lowmem_minfree和lowmem_adj数组中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ntargets; i++) &#123;</span><br><span class="line">        lowmem_minfree[i] = ntohl(*params++);</span><br><span class="line">        lowmem_adj[i] = ntohl(*params++);</span><br><span class="line">    &#125;</span><br><span class="line">    lowmem_targets_size = ntargets;</span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface) &#123;</span><br><span class="line">        <span class="type">char</span> minfreestr[<span class="number">128</span>];</span><br><span class="line">        <span class="type">char</span> killpriostr[<span class="number">128</span>];</span><br><span class="line">        <span class="comment">//根据lowmwm_minfree和lowmwm_adj中的数值，构造出数值字符串</span></span><br><span class="line">        minfreestr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        killpriostr[<span class="number">0</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">            <span class="type">char</span> val[<span class="number">40</span>];</span><br><span class="line">            <span class="keyword">if</span> (i) &#123;</span><br><span class="line">                strlcat(minfreestr, <span class="string">&quot;,&quot;</span>, <span class="keyword">sizeof</span>(minfreestr));</span><br><span class="line">                strlcat(killpriostr, <span class="string">&quot;,&quot;</span>, <span class="keyword">sizeof</span>(killpriostr));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">&quot;%d&quot;</span>, lowmem_minfree[i]);</span><br><span class="line">            strlcat(minfreestr, val, <span class="keyword">sizeof</span>(minfreestr));</span><br><span class="line">            <span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">&quot;%d&quot;</span>, lowmem_adj[i]);</span><br><span class="line">            strlcat(killpriostr, val, <span class="keyword">sizeof</span>(killpriostr));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将上面循环中构造出来的字符串数值写入到/sys/moudle/lowmwmoryykiller/parameters/adj</span></span><br><span class="line">        writefilestring(INKERNEL_MINFREE_PATH, minfreestr);</span><br><span class="line">        <span class="comment">//将上面循环中构造出来的另一字符串数值写入到/sys/modlue/lowmemorykiller/parameters/adj</span></span><br><span class="line">        writefilestring(INKERNEL_ADJ_PATH, killpriostr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cmd_target () 函数的目的就是将 framework 传过来的数值记录到数组中，即将 <code>minfreestr</code>  和 <code>killpriostr</code>  然后将这两个数组拼接成字符串输入，然后写入到内核对应的位置。</p>
<h5 id="62-cmd_procprio方法"><a class="markdownIt-Anchor" href="#62-cmd_procprio方法">#</a> 6.2 cmd_procprio 方法</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmd_procprio</span><span class="params">(<span class="type">int</span> pid, <span class="type">int</span> uid, <span class="type">int</span> oomadj)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line">    <span class="type">char</span> path[<span class="number">80</span>];</span><br><span class="line">    <span class="type">char</span> val[<span class="number">20</span>];</span><br><span class="line">    <span class="comment">//判断oomadj的值是否在规定值内</span></span><br><span class="line">    <span class="keyword">if</span> (oomadj &lt; OOM_DISABLE || oomadj &gt; OOM_ADJUST_MAX) &#123;</span><br><span class="line">        ALOGE(<span class="string">&quot;Invalid PROCPRIO oomadj argument %d&quot;</span>, oomadj);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据进程的pid输出对应的路径</span></span><br><span class="line">    <span class="built_in">snprintf</span>(path, <span class="keyword">sizeof</span>(path), <span class="string">&quot;/proc/%d/oom_score_adj&quot;</span>, pid);</span><br><span class="line"><span class="built_in">snprintf</span>(val, <span class="keyword">sizeof</span>(val), <span class="string">&quot;%d&quot;</span>, lowmem_oom_adj_to_oom_score_adj(oomadj));</span><br><span class="line"><span class="comment">//将oomadj的值写入到对应进程的oom_score_adj中</span></span><br><span class="line">writefilestring(path, val);</span><br><span class="line"><span class="comment">//使用内核接口就直接返回</span></span><br><span class="line"><span class="comment">//这里use_inkernel_interface在初始化的时候设置为1，所以这里直接return</span></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//判断是否有记录到对应的proc结构</span></span><br><span class="line">    procp = pid_lookup(pid);</span><br><span class="line"><span class="keyword">if</span> (!procp) &#123;</span><br><span class="line">        <span class="comment">//如果没有对应的proc结构，表明该进程是新创建的，需要新分配一个结构proc结构记录该进程</span></span><br><span class="line">            procp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> proc));</span><br><span class="line">            <span class="keyword">if</span> (!procp) &#123;</span><br><span class="line">                <span class="comment">// Oh, the irony.  May need to rebuild our state.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            procp-&gt;pid = pid;</span><br><span class="line">            procp-&gt;uid = uid;</span><br><span class="line">            procp-&gt;oomadj = oomadj;</span><br><span class="line">            proc_insert(procp);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果之前已经有proc记录，那么就更新对应的数值</span></span><br><span class="line">        proc_unslot(procp);</span><br><span class="line">        procp-&gt;oomadj = oomadj;</span><br><span class="line">        proc_slot(procp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为现在使用的是内核接口，所以只需要将 oomadj 的数值写入到 <code>/proc/[pid]/oom_source_adj</code>  中即可起到更新进程的 oomadj 的效果。接下来分析 command 处理方法 cmd_procremove 方法。</p>
<h5 id="63-cmd_procremove方法"><a class="markdownIt-Anchor" href="#63-cmd_procremove方法">#</a> 6.3 cmd_procremove 方法</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">cmd_procremove</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">    <span class="comment">//如果使用内核接口直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (use_inkernel_interface)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    pid_remove(pid);</span><br><span class="line">    kill_lasttime = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不使用内核接口的话，就需要更新链表的信息，并删除proc结构占用的内存</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">pid_remove</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hval = pid_hashfn(pid);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">procp</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">prevp</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (procp = pidhash[hval], prevp = <span class="literal">NULL</span>; procp &amp;&amp; procp-&gt;pid != pid;</span><br><span class="line">         procp = procp-&gt;pidhash_next)</span><br><span class="line">            prevp = procp;</span><br><span class="line">    <span class="keyword">if</span> (!procp)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!prevp)</span><br><span class="line">        pidhash[hval] = procp-&gt;pidhash_next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prevp-&gt;pidhash_next = procp-&gt;pidhash_next;</span><br><span class="line">    proc_unslot(procp);</span><br><span class="line">    <span class="built_in">free</span>(procp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果未使用内核接口则调用 <code>pid_remove</code>  进行移除工作。</p>
<p>整理如下：</p>
<table>
<thead>
<tr>
<th>lmkd.c</th>
<th>对应方法</th>
<th>执行动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>LMK_PROCPRIO</td>
<td>cmd_procprio</td>
<td>写 /proc/<pid>oom_score_adj</td>
</tr>
<tr>
<td>LMK_TARGET</td>
<td>cmd_target</td>
<td>写 /sys/moudle/lowmemorykiller/parameters/minfree 写 /sys/module/lowmemorykiller/parameters/adj</td>
</tr>
<tr>
<td>LMK_PROCREMOVE</td>
<td>cmd_procremove</td>
<td>删除 /proc/<pid></td>
</tr>
</tbody>
</table>
<h3 id="7-mp_event_common回收进程"><a class="markdownIt-Anchor" href="#7-mp_event_common回收进程">#</a> 7. mp_event_common（回收进程）</h3>
<p>前面和 socket lmkd 相关的内容主要用于设置 lmk 参数和进程 oomadj。当系统的物理内存不足时，将会触发 mp 事件，这个时候 lmkd 就需要通过杀死一些进程来释放内存页了。</p>
<p>前面我们已经知道，mp 事件发生后，执行的是  <code>mp_event_common</code> 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">mp_event_common</span><span class="params">(<span class="type">int</span> data, <span class="type">uint32_t</span> events __unused)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> evcount;</span><br><span class="line">    <span class="type">int64_t</span> mem_usage, memsw_usage;</span><br><span class="line">    <span class="type">int64_t</span> mem_pressure;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">vmpressure_level</span> <span class="title">lvl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">meminfo</span> <span class="title">mi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">zoneinfo</span> <span class="title">zi</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_report_tm</span>;</span></span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> skip_count = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">vmpressure_level</span> <span class="title">level</span> =</span> (<span class="keyword">enum</span> vmpressure_level)data;</span><br><span class="line">    <span class="type">long</span> other_free = <span class="number">0</span>, other_file = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min_score_adj;</span><br><span class="line">    <span class="type">int</span> pages_to_free = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> minfree = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">mem_usage_file_data</span> =</span> &#123;</span><br><span class="line">        .filename = MEMCG_MEMORY_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">reread_data</span> <span class="title">memsw_usage_file_data</span> =</span> &#123;</span><br><span class="line">        .filename = MEMCG_MEMORYSW_USAGE,</span><br><span class="line">        .fd = <span class="number">-1</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面这一部分是函数用到的变量的定义。在 ANSI C 那个年代，局部变量都要在函数里先声明，但这对代码的可读性其实没有什么帮助（因为定义跟使用他的上下文脱节了）。这里我们先直接忽略它们，后面再在具体的上下文来看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    enum vmpressure_level lvl;</span><br><span class="line">    enum vmpressure_level level = (enum vmpressure_level)data;</span><br><span class="line">    /*</span><br><span class="line">     * Check all event counters from low to critical</span><br><span class="line">     * and upgrade to the highest priority one. By reading</span><br><span class="line">     * eventfd we also reset the event counters.</span><br><span class="line">     */</span><br><span class="line">    for (lvl = VMPRESS_LEVEL_LOW; lvl &lt; VMPRESS_LEVEL_COUNT; lvl++) &#123;</span><br><span class="line">        if (mpevfd[lvl] != -1 &amp;&amp;</span><br><span class="line">            TEMP_FAILURE_RETRY(read(mpevfd[lvl],</span><br><span class="line">                               &amp;evcount, sizeof(evcount))) &gt; 0 &amp;&amp;</span><br><span class="line">            evcount &gt; 0 &amp;&amp; lvl &gt; level) &#123;</span><br><span class="line">            level = lvl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面  <code>init_mp_common</code>  函数里面，我们把  <code>evfd</code>  存在了  <code>mpevfd</code>  数组里，为的就是这个时候能够通过读取它们的来判断是否有更高级别的 mp 事件。至此，变量  <code>level</code>  表示当前发生的最高 level 的 mp 事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    static struct timeval last_report_tm;</span><br><span class="line">    static unsigned long skip_count = 0;</span><br><span class="line"></span><br><span class="line">    if (kill_timeout_ms) &#123;</span><br><span class="line">        struct timeval curr_tm;</span><br><span class="line">        gettimeofday(&amp;curr_tm, NULL);</span><br><span class="line">        if (get_time_diff_ms(&amp;last_report_tm, &amp;curr_tm) &lt; kill_timeout_ms) &#123;</span><br><span class="line">            skip_count++;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (skip_count &gt; 0) &#123;</span><br><span class="line">        ALOGI(&quot;%lu memory pressure events were skipped after a kill!&quot;,</span><br><span class="line">              skip_count);</span><br><span class="line">        skip_count = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>kill_timeout_ms</code>  是我们在  <code>main</code>  函数里通过读系统属性设置的，表示上一次 kill 后，等多  <code>kill_timeout_ms</code>  再杀下一个。 <code>last_report_tm</code>  在后面我们成功回收进程后会更新他的时间。这里要注意， <code>skip_count</code>  和  <code>last_report_tm</code>  都是  <code>static</code>  变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">union zoneinfo &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        int64_t nr_free_pages;</span><br><span class="line">        int64_t nr_file_pages;</span><br><span class="line">        int64_t nr_shmem;</span><br><span class="line">        int64_t nr_unevictable;</span><br><span class="line">        int64_t workingset_refault;</span><br><span class="line">        int64_t high;</span><br><span class="line">        /* fields below are calculated rather than read from the file */</span><br><span class="line">        int64_t totalreserve_pages;</span><br><span class="line">    &#125; field;</span><br><span class="line">    int64_t arr[ZI_FIELD_COUNT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">union meminfo &#123;</span><br><span class="line">    struct &#123;</span><br><span class="line">        int64_t nr_free_pages;</span><br><span class="line">        int64_t cached;</span><br><span class="line">        int64_t swap_cached;</span><br><span class="line">        int64_t buffers;</span><br><span class="line">        int64_t shmem;</span><br><span class="line">        int64_t unevictable;</span><br><span class="line">        int64_t free_swap;</span><br><span class="line">        int64_t dirty;</span><br><span class="line">        /* fields below are calculated rather than read from the file */</span><br><span class="line">        int64_t nr_file_pages;</span><br><span class="line">    &#125; field;</span><br><span class="line">    int64_t arr[MI_FIELD_COUNT];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    union meminfo mi;</span><br><span class="line">    union zoneinfo zi;</span><br><span class="line">    if (meminfo_parse(&amp;mi) &lt; 0 || zoneinfo_parse(&amp;zi) &lt; 0) &#123;</span><br><span class="line">        ALOGE(&quot;Failed to get free memory!&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>union meminfo mi</code>  和  <code>union zoneinfo zi</code>  表示系统当前的内存使用情况。 <code>meminfo_parse</code>  和  <code>zoneinfo_parse</code>  分别读取  <code>/proc/meminfo</code>  和  <code>/proc/zoneinfo</code>  并将解析得到的数据填充到  <code>mi/zi</code> 。（读者可以开个机器，然后  <code>cat /proc/meminfo</code>  看看具体的输出。关于他们解释，参考  <code>man 5 proc</code> ）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    long other_free = 0, other_file = 0;</span><br><span class="line">    int min_score_adj;</span><br><span class="line"></span><br><span class="line">    if (use_minfree_levels) &#123;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        other_free = mi.field.nr_free_pages - zi.field.totalreserve_pages;</span><br><span class="line">        if (mi.field.nr_file_pages &gt; (mi.field.shmem + mi.field.unevictable + mi.field.swap_cached)) &#123;</span><br><span class="line">            other_file = (mi.field.nr_file_pages - mi.field.shmem -</span><br><span class="line">                          mi.field.unevictable - mi.field.swap_cached);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            other_file = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        min_score_adj = OOM_SCORE_ADJ_MAX + 1;</span><br><span class="line">        for (i = 0; i &lt; lowmem_targets_size; i++) &#123;</span><br><span class="line">            minfree = lowmem_minfree[i];</span><br><span class="line">            if (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123;</span><br><span class="line">                min_score_adj = lowmem_adj[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (min_score_adj == OOM_SCORE_ADJ_MAX + 1) &#123;</span><br><span class="line">            if (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(&quot;Ignore %s memory pressure event &quot;</span><br><span class="line">                      &quot;(free memory=%ldkB, cache=%ldkB, limit=%ldkB)&quot;,</span><br><span class="line">                      level_name[level], other_free * page_k, other_file * page_k,</span><br><span class="line">                      (long)lowmem_minfree[lowmem_targets_size - 1] * page_k);</span><br><span class="line">            &#125;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /* Free up enough pages to push over the highest minfree level */</span><br><span class="line">        pages_to_free = lowmem_minfree[lowmem_targets_size - 1] -</span><br><span class="line">            ((other_free &lt; other_file) ? other_free : other_file);</span><br><span class="line">        goto do_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>use_minfree_levels</code>  同样是从系统属性读取的配置，表示使用当我们准备杀死应用的时候，使用系统剩余的内存和文件缓存阈值作为判断依据。</p>
<p><code>other_free</code>  表示系统可用的内存页的数目。</p>
<p><code>nr_file_pages</code>  等于  <code>mi-&gt;field.cached</code> （文件在内存中的缓存）加上  <code>mi-&gt;field.swap_cached</code> （swap 出去又读进了内存的数据）加上  <code>mi-&gt;field.buffers</code> （硬盘的一个临时缓存），</p>
<p><code>mi.shmem</code>  表示 tmpfs 使用的内存数， <code>unevictable</code>  表示那些不能 swap out 的内存。</p>
<p>最后  <code>other_file</code>  基本就等于除 tmpfs 和 unevictable 外的缓存在内存的文件所占用的 page 数。</p>
<p>有了  <code>other_free</code>  和  <code>other_file</code>  后，我们根据  <code>lowmem_minfree</code>  的值来确定  <code>min_score_adj</code> 。 <code>min_score_adj</code>  表示可以回收的最低的 oomadj 值（oomadj 越大，优先级越低，越容易被杀死），oomadj 小于  <code>min_score_adj</code>  的进程在这次回收过程中不会被杀死。</p>
<p>回想一下前面的  <code>cmd_target</code> ， <code>lowmem_minfree</code>  和  <code>lowmem_adj</code>  值就是在他里面设置的。</p>
<p><code>goto do_kill</code>  在函数比较靠后的地方，我们后面再看。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct &#123;</span><br><span class="line">    int64_t min_nr_free_pages; /* recorded but not used yet */</span><br><span class="line">    int64_t max_nr_free_pages;</span><br><span class="line">&#125; low_pressure_mem = &#123; -1, -1 &#125;;</span><br><span class="line"></span><br><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (level == VMPRESS_LEVEL_LOW) &#123;</span><br><span class="line">        record_low_pressure_levels(&amp;mi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void record_low_pressure_levels(union meminfo *mi) &#123;</span><br><span class="line">    if (low_pressure_mem.min_nr_free_pages == -1 ||</span><br><span class="line">        low_pressure_mem.min_nr_free_pages &gt; mi-&gt;field.nr_free_pages) &#123;</span><br><span class="line">        if (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(&quot;Low pressure min memory update from %&quot; PRId64 &quot; to %&quot; PRId64,</span><br><span class="line">                low_pressure_mem.min_nr_free_pages, mi-&gt;field.nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        low_pressure_mem.min_nr_free_pages = mi-&gt;field.nr_free_pages;</span><br><span class="line">    &#125;</span><br><span class="line">    /*</span><br><span class="line">     * Free memory at low vmpressure events occasionally gets spikes,</span><br><span class="line">     * possibly a stale low vmpressure event with memory already</span><br><span class="line">     * freed up (no memory pressure should have been reported).</span><br><span class="line">     * Ignore large jumps in max_nr_free_pages that would mess up our stats.</span><br><span class="line">     */</span><br><span class="line">    if (low_pressure_mem.max_nr_free_pages == -1 ||</span><br><span class="line">        (low_pressure_mem.max_nr_free_pages &lt; mi-&gt;field.nr_free_pages &amp;&amp;</span><br><span class="line">         mi-&gt;field.nr_free_pages - low_pressure_mem.max_nr_free_pages &lt;</span><br><span class="line">         low_pressure_mem.max_nr_free_pages * 0.1)) &#123;</span><br><span class="line">        if (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(&quot;Low pressure max memory update from %&quot; PRId64 &quot; to %&quot; PRId64,</span><br><span class="line">                low_pressure_mem.max_nr_free_pages, mi-&gt;field.nr_free_pages);</span><br><span class="line">        &#125;</span><br><span class="line">        low_pressure_mem.max_nr_free_pages = mi-&gt;field.nr_free_pages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>low_pressure_mem.min_nr_free_pages</code>  记录的是目前遇到的最低可用内存页数， <code>low_pressure_mem.max_nr_free_pages</code>  记录的是目前遇到的最大可用的内存页数。就像代码中注释说的，有时候可用的内存数会突然暴涨，这里过滤掉了这种情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#define MEMCG_MEMORY_USAGE &quot;/dev/memcg/memory.usage_in_bytes&quot;</span><br><span class="line">#define MEMCG_MEMORYSW_USAGE &quot;/dev/memcg/memory.memsw.usage_in_bytes&quot;</span><br><span class="line"></span><br><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    if (level_oomadj[level] &gt; OOM_SCORE_ADJ_MAX) &#123;</span><br><span class="line">        /* Do not monitor this pressure level */</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int64_t mem_usage, memsw_usage;</span><br><span class="line">    static struct reread_data mem_usage_file_data = &#123;</span><br><span class="line">        .filename = MEMCG_MEMORY_USAGE,</span><br><span class="line">        .fd = -1,</span><br><span class="line">    &#125;;</span><br><span class="line">    static struct reread_data memsw_usage_file_data = &#123;</span><br><span class="line">        .filename = MEMCG_MEMORYSW_USAGE,</span><br><span class="line">        .fd = -1,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    if ((mem_usage = get_memory_usage(&amp;mem_usage_file_data)) &lt; 0) &#123;</span><br><span class="line">        goto do_kill;</span><br><span class="line">    &#125;</span><br><span class="line">    if ((memsw_usage = get_memory_usage(&amp;memsw_usage_file_data)) &lt; 0) &#123;</span><br><span class="line">        goto do_kill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int64_t get_memory_usage(struct reread_data *file_data) &#123;</span><br><span class="line">    int ret;</span><br><span class="line">    int64_t mem_usage;</span><br><span class="line">    char buf[32];</span><br><span class="line"></span><br><span class="line">    if (reread_file(file_data, buf, sizeof(buf)) &lt; 0) &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!parse_int64(buf, &amp;mem_usage)) &#123;</span><br><span class="line">        ALOGE(&quot;%s parse error&quot;, file_data-&gt;filename);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (mem_usage == 0) &#123;</span><br><span class="line">        ALOGE(&quot;No memory!&quot;);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    return mem_usage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get_memory_usage</code>  的实现很简单，就是读取  <code>reread_data.filename</code>  的内容并转换为  <code>int64</code> 。这里还需要注意的是  <code>mem_usage_file_data</code>  和  <code>memsw_usage_file_data</code>  是静态变量。第一次打开文件后，会把文件描述符缓存在  <code>reread_data.fd</code>  里。</p>
<p><code>mem_usage</code>  是所用的内存数， <code>memsw_usage</code>  是内存数加上 swap out 的内存数。接下来的代码根据这两个数据来计算内存压力（压力越大，swap 出去的内存就越多）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    // Calculate percent for swappinness.</span><br><span class="line">    int64_t mem_pressure = (mem_usage * 100) / memsw_usage;</span><br><span class="line"></span><br><span class="line">    if (enable_pressure_upgrade &amp;&amp; level != VMPRESS_LEVEL_CRITICAL) &#123;</span><br><span class="line">        // We are swapping too much.</span><br><span class="line">        if (mem_pressure &lt; upgrade_pressure) &#123;</span><br><span class="line">            level = upgrade_level(level);</span><br><span class="line">            if (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(&quot;Event upgraded to %s&quot;, level_name[level]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // If the pressure is larger than downgrade_pressure lmk will not</span><br><span class="line">    // kill any process, since enough memory is available.</span><br><span class="line">    if (mem_pressure &gt; downgrade_pressure) &#123;</span><br><span class="line">        if (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(&quot;Ignore %s memory pressure&quot;, level_name[level]);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125; else if (level == VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">               mem_pressure &gt; upgrade_pressure) &#123;</span><br><span class="line">        if (debug_process_killing) &#123;</span><br><span class="line">            ALOGI(&quot;Downgrade critical memory pressure&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // Downgrade event, since enough memory available.</span><br><span class="line">        level = downgrade_level(level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这里  <code>mem_pressure</code>  计算的是  <code>内存数 / (内存数 + swap)</code> ， <code>mem_pressure</code>  越小，内存压力就越大。</p>
<p><code>enable_pressure_upgrade</code> 、 <code>upgrade_pressure</code>  和  <code>downgrade_pressure</code>  的值是我们在  <code>main</code>  函数里根据系统属性设置的。</p>
<p>在内存压力比较大并且  <code>enable_pressure_upgrade</code>  打开的情况下，我们把内存压力向上提升一个等级（以期释放更多的内存）；在内存压力小于  <code>downgrade_pressure</code>  的时候，内存是充足的，没有必要通过杀死应用来回收内存；如果内存压力中等（upgrade_pressure &lt; mem_pressure &lt; downgrade_pressure）但是 level 却是 critical，就给他降一级。</p>
<p>lmkd 在给 mp level 升级的时候需要打开 enable_pressure_upgrade（默认关闭），而降级却总是可行的，说明 lmkd 尽力在不杀死应用的情况下满足系统的内存需求。</p>
<p>到目前为止，我们得到了三组跟内存压力相关的参数：</p>
<ol>
<li>在  <code>use_minfree_levels</code>  的情况下， <code>min_score_adj</code>  和  <code>pages_to_free</code></li>
<li>内存压力  <code>level</code></li>
</ol>
<p>接下来，我们开始真正的进程回收工作：</p>
<h4 id="kill-process"><a class="markdownIt-Anchor" href="#kill-process">#</a> kill process</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    if (low_ram_device) &#123;</span><br><span class="line">        /* For Go devices kill only one task */</span><br><span class="line">        if (find_and_kill_processes(level, level_oomadj[level], 0) == 0) &#123;</span><br><span class="line">            if (debug_process_killing) &#123;</span><br><span class="line">                ALOGI(&quot;Nothing to kill&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回收对象时分两大类，小内存设备和 “大” 内存设备。小内存设备一次就杀一个进程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">static int find_and_kill_processes(enum vmpressure_level level,</span><br><span class="line">                                   int min_score_adj, int pages_to_free) &#123;</span><br><span class="line">    int i;</span><br><span class="line">    int killed_size;</span><br><span class="line">    int pages_freed = 0;</span><br><span class="line"></span><br><span class="line">    for (i = OOM_SCORE_ADJ_MAX; i &gt;= min_score_adj; i--) &#123;</span><br><span class="line">        struct proc *procp;</span><br><span class="line"></span><br><span class="line">        while (true) &#123;</span><br><span class="line">            procp = kill_heaviest_task ?</span><br><span class="line">                proc_get_heaviest(i) : proc_adj_lru(i);</span><br><span class="line"></span><br><span class="line">            if (!procp)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            killed_size = kill_one_process(procp, min_score_adj, level);</span><br><span class="line">            if (killed_size &gt;= 0) &#123;</span><br><span class="line">                pages_freed += killed_size;</span><br><span class="line">                if (pages_freed &gt;= pages_to_free) &#123;</span><br><span class="line">                    return pages_freed;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return pages_freed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们从 oomadj 最大的应用开始回收，直到回收的内存页数达到  <code>pages_to_free</code> 。对  <code>low_ram_device</code>  来说， <code>pages_to_free</code>  为 0，只有一个进程会被回收。</p>
<p><code>kill_heaviest_task</code>  是从系统属性读的，默认为  <code>false</code> 。打开的情况下，在相关 oomadj 的进程里，我们优先回收使用内存最多的那个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">static struct proc *proc_get_heaviest(int oomadj) &#123;</span><br><span class="line">    struct adjslot_list *head = &amp;procadjslot_list[ADJTOSLOT(oomadj)];</span><br><span class="line">    struct adjslot_list *curr = head-&gt;next;</span><br><span class="line">    struct proc *maxprocp = NULL;</span><br><span class="line">    int maxsize = 0;</span><br><span class="line">    while (curr != head) &#123;</span><br><span class="line">        int pid = ((struct proc *)curr)-&gt;pid;</span><br><span class="line">        int tasksize = proc_get_size(pid);</span><br><span class="line">        if (tasksize &lt;= 0) &#123;</span><br><span class="line">            struct adjslot_list *next = curr-&gt;next;</span><br><span class="line">            pid_remove(pid);</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (tasksize &gt; maxsize) &#123;</span><br><span class="line">                maxsize = tasksize;</span><br><span class="line">                maxprocp = (struct proc *)curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return maxprocp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是  <code>false</code> ，调用的则是  <code>proc_adj_lru</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static struct adjslot_list *adjslot_tail(struct adjslot_list *head) &#123;</span><br><span class="line">    struct adjslot_list *asl = head-&gt;prev;</span><br><span class="line"></span><br><span class="line">    return asl == head ? NULL : asl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static struct proc *proc_adj_lru(int oomadj) &#123;</span><br><span class="line">    return (struct proc *)adjslot_tail(&amp;procadjslot_list[ADJTOSLOT(oomadj)]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们取的是列表的尾端；而插入新元素时，我们总是把它放在头端。</p>
<p><code>kill_one_process</code>  通过向应用发送信号  <code>SIGKILL</code>  来杀死对方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">/* Kill one process specified by procp.  Returns the size of the process killed */</span><br><span class="line">static int kill_one_process(struct proc* procp, int min_score_adj,</span><br><span class="line">                            enum vmpressure_level level) &#123;</span><br><span class="line">    int pid = procp-&gt;pid;</span><br><span class="line">    uid_t uid = procp-&gt;uid;</span><br><span class="line">    char *taskname;</span><br><span class="line">    int tasksize;</span><br><span class="line">    int r;</span><br><span class="line"></span><br><span class="line">    taskname = proc_get_name(pid);</span><br><span class="line">    if (!taskname) &#123;</span><br><span class="line">        pid_remove(pid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tasksize = proc_get_size(pid);</span><br><span class="line">    if (tasksize &lt;= 0) &#123;</span><br><span class="line">        pid_remove(pid);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r = kill(pid, SIGKILL);</span><br><span class="line">    ALOGI(</span><br><span class="line">        &quot;Killing &#x27;%s&#x27; (%d), uid %d, adj %d\n&quot;</span><br><span class="line">        &quot;   to free %ldkB because system is under %s memory pressure oom_adj %d\n&quot;,</span><br><span class="line">        taskname, pid, uid, procp-&gt;oomadj, tasksize * page_k,</span><br><span class="line">        level_name[level], min_score_adj);</span><br><span class="line">    pid_remove(pid);</span><br><span class="line"></span><br><span class="line">    if (r) &#123;</span><br><span class="line">        ALOGE(&quot;kill(%d): errno=%d&quot;, pid, errno);</span><br><span class="line">        return -1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return tasksize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return tasksize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们看不是  <code>low_ram_device</code>  的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    if (low_ram_device) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!use_minfree_levels) &#123;</span><br><span class="line">            /* If pressure level is less than critical and enough free swap then ignore */</span><br><span class="line">            if (level &lt; VMPRESS_LEVEL_CRITICAL &amp;&amp;</span><br><span class="line">                mi.field.free_swap &gt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">                if (debug_process_killing) &#123;</span><br><span class="line">                    ALOGI(&quot;Ignoring pressure since %&quot; PRId64</span><br><span class="line">                          &quot; swap pages are available &quot;,</span><br><span class="line">                          mi.field.free_swap);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            /* Free up enough memory to downgrate the memory pressure to low level */</span><br><span class="line">            if (mi.field.nr_free_pages &lt; low_pressure_mem.max_nr_free_pages) &#123;</span><br><span class="line">                pages_to_free = low_pressure_mem.max_nr_free_pages -</span><br><span class="line">                    mi.field.nr_free_pages;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (debug_process_killing) &#123;</span><br><span class="line">                    ALOGI(&quot;Ignoring pressure since more memory is &quot;</span><br><span class="line">                        &quot;available (%&quot; PRId64 &quot;) than watermark (%&quot; PRId64 &quot;)&quot;,</span><br><span class="line">                        mi.field.nr_free_pages, low_pressure_mem.max_nr_free_pages);</span><br><span class="line">                &#125;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            min_score_adj = level_oomadj[level];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们总结过，在  <code>!use_minfree_levels</code>  的情况下，我们只有一个 mp  <code>level</code> ，还需要  <code>min_score_adj</code>  和  <code>pages_to_free</code>  才能开始回收进程。</p>
<p><code>low_pressure_mem.max_nr_free_pages</code>  是前面我们在  <code>record_low_pressure_levels</code>  中记录的， <code>free_swap</code>  是系统 swap 分区空余的大小；如果内存压力不是 critical 并且 swap 分区还足够大，就不回收进程了（lmkd 也是不容易啊，只有在实在没有办法了才杀我们应用）。</p>
<p>此外，在空余内存页比我们遇到过的发生 mp 事件时系统剩余内存最多的那次还要多的时候（比以往最好的情况还要好），也不回收应用。即便真的需要回收内存，我们也只回收到系统（内存）状态跟以往最好的那次为止（ <code>pages_to_free = max_nr_free_pages - nr_free_pages</code> ）。</p>
<p>这里计算出  <code>pages_to_free</code>  和  <code>min_scrore_adj</code>  后，我们下面就该回收进程了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static void mp_event_common(int data, uint32_t events __unused) &#123;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">do_kill:</span><br><span class="line">    if (low_ram_device) &#123;</span><br><span class="line">        ...</span><br><span class="line">        ...</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        if (!use_minfree_levels) &#123;</span><br><span class="line">            // compute pages_to_free &amp; min_score_adj</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pages_freed = find_and_kill_processes(level, min_score_adj, pages_to_free);</span><br><span class="line"></span><br><span class="line">        if (use_minfree_levels) &#123;</span><br><span class="line">            ALOGI(&quot;Killing because cache %ldkB is below &quot;</span><br><span class="line">                  &quot;limit %ldkB for oom_adj %d\n&quot;</span><br><span class="line">                  &quot;   Free memory is %ldkB %s reserved&quot;,</span><br><span class="line">                  other_file * page_k, minfree * page_k, min_score_adj,</span><br><span class="line">                  other_free * page_k, other_free &gt;= 0 ? &quot;above&quot; : &quot;below&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (pages_freed &lt; pages_to_free) &#123;</span><br><span class="line">            ALOGI(&quot;Unable to free enough memory (pages to free=%d, pages freed=%d)&quot;,</span><br><span class="line">                  pages_to_free, pages_freed);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ALOGI(&quot;Reclaimed enough memory (pages to free=%d, pages freed=%d)&quot;,</span><br><span class="line">                  pages_to_free, pages_freed);</span><br><span class="line">            gettimeofday(&amp;last_report_tm, NULL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>find_and_kill_processes</code>  的实现在前面我们已经看了，他根据进程的 oomajd 值从大到小回收那些 oomadj 值比  <code>min_score_adj</code>  大的应用，并且只回收  <code>pages_to_free</code>  个内存页就停止。</p>
<p>最后把当前时间记录在  <code>last_report_tm</code> ，他表示上次成功回收进程的时间（和  <code>kill_timeout_ms</code>  组合使用）。</p>
<h2 id="四-lowermemorykillerc"><a class="markdownIt-Anchor" href="#四-lowermemorykillerc">#</a> （四） lowermemorykiller.c</h2>
<h3 id="1-lmk的驱动加载函数"><a class="markdownIt-Anchor" href="#1-lmk的驱动加载函数">#</a> 1. LMK 的驱动加载函数</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">lowmem_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	register_shrinker(&amp;lowmem_shrinker);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init 方法中注册了一个 shrinker 到内核的 shrinker 链表。当内存不足时，kswapd 线程会遍历一张 shrinker 链表，并回调已注册的 shrinker 函数来回收内存 page，kswapd 还会周期性唤醒来执行内存操作。每个 zone 维护 active_list 和 inactive_list 链表，内核根据页面活动状态将 page 在这两个链表之间移动，最终通过 shrink_slab 和 shrink_zone 来回收内存页。</p>
<h3 id="2-数据结构"><a class="markdownIt-Anchor" href="#2-数据结构">#</a> 2. 数据结构</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">short</span> lowmem_adj[<span class="number">6</span>] = &#123;</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	<span class="number">6</span>,</span><br><span class="line">	<span class="number">12</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lowmem_adj_size = <span class="number">4</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lowmem_minfree[<span class="number">6</span>] = &#123;</span><br><span class="line">	<span class="number">3</span> * <span class="number">512</span>,	<span class="comment">/* 6MB */</span></span><br><span class="line">	<span class="number">2</span> * <span class="number">1024</span>,	<span class="comment">/* 8MB */</span></span><br><span class="line">	<span class="number">4</span> * <span class="number">1024</span>,	<span class="comment">/* 16MB */</span></span><br><span class="line">	<span class="number">16</span> * <span class="number">1024</span>,	<span class="comment">/* 64MB */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个数组 lowmem_adj 最多有 6 个元素（默认只定义了 4 个），它表示可用内存容量处于 “某层级” 时需要被处理的 adj 值；第二个数组则是对 “层级” 的描述。举个例子，lowmwm_minfree 的第一个元素是 3<em>512，即 3</em>512*lowmwm_adj_size=6MB。也就是说，当可用内存小于 6MB 时，Killer 需要清理 adj 值为 0（即 lowmem_adj 的第一个元素）以下的所有进程。其中 adj 的取值范围是 - 17～15，数字越小表示进程级别越高（通常只有 0～15 被使用）。</p>
<p>lowmem_adj 和 lowmem_adj_size 这两个数组只是系统的预定义值，我们还可以根据项目的实际需求来做定制。Android 系统提供了相应的文件来供我们修改这两组值，路径如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/sys/module/lowmemorykiller/parameters/adj</span><br><span class="line">/sys/module/lowmemorykiller/parameters/minfree</span><br></pre></td></tr></table></figure>
<p>也可以在 init.rc 中加入语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">write /sys/module/lowmemorykiller/parameters/adj <span class="number">0</span>,<span class="number">8</span></span><br><span class="line">write /sys/module/lowmemorykiller/parameters/minfree <span class="number">1024</span>,<span class="number">4096</span></span><br></pre></td></tr></table></figure>
<h3 id="3-adj进程规划"><a class="markdownIt-Anchor" href="#3-adj进程规划">#</a> 3. Adj 进程规划</h3>
<table>
<thead>
<tr>
<th>ADJ</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>UNKNOW_ADJ</td>
<td>一般指将要会缓存进程，无法获取确定值</td>
</tr>
<tr>
<td>HIDDEN_APP_MAX_ADJ=15</td>
<td>当前只运行了不可见的 Activity 组件的进程，分别为不可见进程 adj 的最大值、最小值</td>
</tr>
<tr>
<td>HIDDEN_APP_MIN_ADJ=9</td>
<td></td>
</tr>
<tr>
<td>SERVICE_B_ADJ=8</td>
<td>B list of Service。和 A list 相比，它们对用户的黏合度要小一些</td>
</tr>
<tr>
<td>PREVIOUS_APP_ADJ=7</td>
<td>用户前一次交互的进程。按照用户的使用习惯，人们经常会在几个常用进程间切换，所以这类进程得到再次运行的概率比较大</td>
</tr>
<tr>
<td>HOME_APP_ADJ=6</td>
<td>Home 进程</td>
</tr>
<tr>
<td>SERVICE_ADJ=5</td>
<td>当前运行了 application service 的进程</td>
</tr>
<tr>
<td>BACKUP_APP_ADJ=4</td>
<td>用于承载 backup 相关操作的进程</td>
</tr>
<tr>
<td>HEAVY_WEIGHT_APP_ADJ=3</td>
<td>重量级应用程序进程</td>
</tr>
<tr>
<td>PERCEPTIBLE_APP_ADJ=2</td>
<td>这类进程能被用户感觉到不可见，如后台运行的音乐播放器</td>
</tr>
<tr>
<td>VISIBLE_APP_ADJ=1</td>
<td>有前台可见的 Activity 的进程，如果轻易杀死这类进程将严重影响用户的体验。</td>
</tr>
<tr>
<td>FOREGROUND_APP_ADJ=0</td>
<td>当前正在前台运行的进程，也就是用户正在交互的那个程序</td>
</tr>
<tr>
<td>PERSISTENT_PROC_ADJ=-12</td>
<td>Persistent 性质的进程，如 telephony</td>
</tr>
<tr>
<td>SYSTEM_ADJ=-16</td>
<td>系统进程</td>
</tr>
<tr>
<td>NATIVE_ADJ=-17</td>
<td>native 进程（不被系统管理）</td>
</tr>
</tbody>
</table>
<p>通过以下方法，我们可以自己改变进程的 oom_adj 值：</p>
<h4 id="31-写文件"><a class="markdownIt-Anchor" href="#31-写文件">#</a> 3.1 写文件</h4>
<p>和前面的 adj 和 minfree 类似，进程的 oom_adj 也可以通过写文件的形式修改，路径为 /proc/<PID>/oom_adj。比如 init.rc 中就有如下语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">on early-init</span><br><span class="line">    write /proc/<span class="number">1</span>/oom_adj<span class="number">-16</span></span><br></pre></td></tr></table></figure>
<p>PID 值为 1 的进程是 init 程序，这里将此进程的 adj 改为 - 16，以保证它不会被杀死。</p>
<h4 id="32-android-persistent"><a class="markdownIt-Anchor" href="#32-android-persistent">#</a> 3.2 android: persistent</h4>
<p>对于某些非常重要的应用程序，我们不希望它们被系统杀死。一个最简单的方法就是在它的 AndroidManifest.xml 文件中给 “application” 标签添加 “android:persistent==true” 属性。不过将应用程序设置为常驻内存要特别慎重，如果应用程序本身不够完善，而系统又不能通过支持方式回收它的话，则有可能导致意想不到的问题。</p>
<h3 id="4-lowmem_shrinker结构体"><a class="markdownIt-Anchor" href="#4-lowmem_shrinker结构体">#</a> 4. lowmem_shrinker 结构体</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">shrinker</span> <span class="title">lowmem_shrinker</span> =</span> &#123;</span><br><span class="line">	.scan_objects = lowmem_scan,</span><br><span class="line">	.count_objects = lowmem_count,</span><br><span class="line">	.seeks = DEFAULT_SEEKS * <span class="number">16</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="41-lowmem_scan方法"><a class="markdownIt-Anchor" href="#41-lowmem_scan方法">#</a> 4.1 lowmem_scan 方法</h4>
<p>当系统内存不足时会回调 lowmem_scan 方法来 kill 应用以达到释放内存的效果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">lowmem_scan</span><span class="params">(<span class="keyword">struct</span> shrinker *s, <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">selected</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> rem = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tasksize;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">short</span> min_score_adj = OOM_SCORE_ADJ_MAX + <span class="number">1</span>;</span><br><span class="line">	<span class="type">int</span> minfree = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> selected_tasksize = <span class="number">0</span>;</span><br><span class="line">	<span class="type">short</span> selected_oom_score_adj;</span><br><span class="line">	<span class="type">int</span> array_size = ARRAY_SIZE(lowmem_adj);</span><br><span class="line">	<span class="type">int</span> other_free = global_page_state(NR_FREE_PAGES) - totalreserve_pages;</span><br><span class="line">	<span class="type">int</span> other_file = global_page_state(NR_FILE_PAGES) -</span><br><span class="line">						global_page_state(NR_SHMEM) -</span><br><span class="line">						total_swapcache_pages();</span><br><span class="line">    <span class="comment">//获取数组大小</span></span><br><span class="line">	<span class="keyword">if</span> (lowmem_adj_size &lt; array_size)</span><br><span class="line">		array_size = lowmem_adj_size;</span><br><span class="line">	<span class="keyword">if</span> (lowmem_minfree_size &lt; array_size)</span><br><span class="line">		array_size = lowmem_minfree_size;</span><br><span class="line">    <span class="comment">//获取当前内存阈值对应的adj值</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; array_size; i++) &#123;</span><br><span class="line">		minfree = lowmem_minfree[i];</span><br><span class="line">		<span class="keyword">if</span> (other_free &lt; minfree &amp;&amp; other_file &lt; minfree) &#123;</span><br><span class="line">			min_score_adj = lowmem_adj[i];</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	lowmem_print(<span class="number">3</span>, <span class="string">&quot;lowmem_scan %lu, %x, ofree %d %d, ma %hd\n&quot;</span>,</span><br><span class="line">			sc-&gt;nr_to_scan, sc-&gt;gfp_mask, other_free,</span><br><span class="line">			other_file, min_score_adj);</span><br><span class="line">    <span class="comment">//如果当前min_score_adj为最大adj值加1，表明还剩余足够的内存，不需要进行内存释放</span></span><br><span class="line">	<span class="keyword">if</span> (min_score_adj == OOM_SCORE_ADJ_MAX + <span class="number">1</span>) &#123;</span><br><span class="line">		lowmem_print(<span class="number">5</span>, <span class="string">&quot;lowmem_scan %lu, %x, return 0\n&quot;</span>,</span><br><span class="line">			     sc-&gt;nr_to_scan, sc-&gt;gfp_mask);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	selected_oom_score_adj = min_score_adj;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">    <span class="comment">//遍历所有的进程task</span></span><br><span class="line">	for_each_process(tsk) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line">		<span class="type">short</span> oom_score_adj;</span><br><span class="line">		<span class="keyword">if</span> (tsk-&gt;flags &amp; PF_KTHREAD)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		p = find_lock_task_mm(tsk);</span><br><span class="line">		<span class="keyword">if</span> (!p)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果进程已经不包含任何memory则跳过</span></span><br><span class="line">		<span class="keyword">if</span> (test_tsk_thread_flag(p, TIF_MEMDIE) &amp;&amp;</span><br><span class="line">		    time_before_eq(jiffies, lowmem_deathpending_timeout)) &#123;</span><br><span class="line">			task_unlock(p);</span><br><span class="line">			rcu_read_unlock();</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果当前进程的oom_score_adj比当前内存阈值的adj还小，表明当前进程不应该被杀，跳过</span></span><br><span class="line">		oom_score_adj = p-&gt;signal-&gt;oom_score_adj;</span><br><span class="line">		<span class="keyword">if</span> (oom_score_adj &lt; min_score_adj) &#123;</span><br><span class="line">			task_unlock(p);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//如果当前进程的oom_score_adj比当前内存阈值的adj值大，进入进程的被杀候选</span></span><br><span class="line">        <span class="comment">//首先获取当前进程的占用内存大小</span></span><br><span class="line">		tasksize = get_mm_rss(p-&gt;mm);</span><br><span class="line">		task_unlock(p);</span><br><span class="line">		<span class="keyword">if</span> (tasksize &lt;= <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果已经有进程被选为被杀进程</span></span><br><span class="line">		<span class="keyword">if</span> (selected) &#123;</span><br><span class="line">            <span class="comment">//如果当前进程的oom_score_adj值比之前挑选的进程的oom_score_adj值小</span></span><br><span class="line">            <span class="comment">//代表当前进程重要程度比选中要杀的进程高，则跳过</span></span><br><span class="line">			<span class="keyword">if</span> (oom_score_adj &lt; selected_oom_score_adj)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//如果oom_score_adj值一样大，但是进程占用内存比选中要杀的进程小也跳过</span></span><br><span class="line">			<span class="keyword">if</span> (oom_score_adj == selected_oom_score_adj &amp;&amp;</span><br><span class="line">			    tasksize &lt;= selected_tasksize)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//以上判断都不符合，表明当前进程的oom_score_adj值比挑选要杀的进程的oom_score_adj大</span></span><br><span class="line">        <span class="comment">//更新被挑选要杀的进程为当前遍历的进程，并记录相关信息后进入下一轮循环</span></span><br><span class="line">		selected = p;</span><br><span class="line">		selected_tasksize = tasksize;</span><br><span class="line">		selected_oom_score_adj = oom_score_adj;</span><br><span class="line">		lowmem_print(<span class="number">2</span>, <span class="string">&quot;select &#x27;%s&#x27; (%d), adj %hd, size %d, to kill\n&quot;</span>,</span><br><span class="line">			     p-&gt;comm, p-&gt;pid, oom_score_adj, tasksize);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//如果找到需要被杀进程</span></span><br><span class="line">	<span class="keyword">if</span> (selected) &#123;</span><br><span class="line">        <span class="comment">//计算能够释放的内存大小</span></span><br><span class="line">		<span class="type">long</span> cache_size = other_file * (<span class="type">long</span>)(PAGE_SIZE / <span class="number">1024</span>);</span><br><span class="line">		<span class="type">long</span> cache_limit = minfree * (<span class="type">long</span>)(PAGE_SIZE / <span class="number">1024</span>);</span><br><span class="line">		<span class="type">long</span> <span class="built_in">free</span> = other_free * (<span class="type">long</span>)(PAGE_SIZE / <span class="number">1024</span>);</span><br><span class="line">		trace_lowmemory_kill(selected, cache_size, cache_limit, <span class="built_in">free</span>);</span><br><span class="line">		lowmem_print(<span class="number">1</span>, <span class="string">&quot;Killing &#x27;%s&#x27; (%d), adj %hd,\n&quot;</span> \</span><br><span class="line">				<span class="string">&quot; to free %ldkB on behalf of &#x27;%s&#x27; (%d) because\n&quot;</span> \</span><br><span class="line">				<span class="string">&quot; cache %ldkB is below limit %ldkB for oom_score_adj %hd\n&quot;</span> \</span><br><span class="line">				<span class="string">&quot; Free memory is %ldkB above reserved\n&quot;</span>,</span><br><span class="line">			     selected-&gt;comm, selected-&gt;pid,</span><br><span class="line">			     selected_oom_score_adj,</span><br><span class="line">			     selected_tasksize * (<span class="type">long</span>)(PAGE_SIZE / <span class="number">1024</span>),</span><br><span class="line">			     current-&gt;comm, current-&gt;pid,</span><br><span class="line">			     cache_size, cache_limit,</span><br><span class="line">			     min_score_adj,</span><br><span class="line">			     <span class="built_in">free</span>);</span><br><span class="line">		lowmem_deathpending_timeout = jiffies + HZ;</span><br><span class="line">		set_tsk_thread_flag(selected, TIF_MEMDIE);</span><br><span class="line">           <span class="comment">//发送SIGKILL信号到被选中进程</span></span><br><span class="line">		send_sig(SIGKILL, selected, <span class="number">0</span>);</span><br><span class="line">           <span class="comment">//统计释放内存大小</span></span><br><span class="line">		rem += selected_tasksize;</span><br><span class="line">	&#125;</span><br><span class="line">	lowmem_print(<span class="number">4</span>, <span class="string">&quot;lowmem_scan %lu, %x, return %lu\n&quot;</span>,</span><br><span class="line">		     sc-&gt;nr_to_scan, sc-&gt;gfp_mask, rem);</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line">	<span class="keyword">return</span> rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lowmem_scan 方法的主要思想就是首先获取当前内存剩余量，根据剩余量获取对应的 min free adj 值；接着遍历当前系统中的所有进程，从中挑选出进程的 oom adj 最大者，如果存在进程 oom adj 值相同，则挑选出其中占用内存最大的那个进程；最后向这个进程发送 SIGKILL 信息，以达到杀死该进程释放内存的效果。</p>
<h4 id="42-lowmem_count方法"><a class="markdownIt-Anchor" href="#42-lowmem_count方法">#</a> 4.2 lowmem_count 方法</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">lowmem_count</span><span class="params">(<span class="keyword">struct</span> shrinker *s,</span></span><br><span class="line"><span class="params">				  <span class="keyword">struct</span> shrink_control *sc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> global_page_state(NR_ACTIVE_ANON) +</span><br><span class="line">		global_page_state(NR_ACTIVE_FILE) +</span><br><span class="line">		global_page_state(NR_INACTIVE_ANON) +</span><br><span class="line">		global_page_state(NR_INACTIVE_FILE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lowmem_count 方法就是通过 shrinker 链表来判断 lmk 是否可用，如果可用则返回各部分占用的内存大小。</p>
<h3 id="5-整体流程"><a class="markdownIt-Anchor" href="#5-整体流程">#</a> 5. 整体流程</h3>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205141648197.png" alt="image-20220514164809062"></p>
<h1 id="四-oom-adj算法"><a class="markdownIt-Anchor" href="#四-oom-adj算法">#</a> 四、oom adj 算法</h1>
<p>Android 进程在不同的时候处于不同的进程状态，也会根据重要性动态调整进程的 oom score。这样在 lmkd 中可以根据当前的内存使用情况，找到合适的 oom_score_adj，并将其 kill 以满足内存的持续使用。</p>
<p>下面主要分析 oom adj 算法作为 lmkd 机制的补充</p>
<p>Android 系统中计算各进程 adj 算法的核心方法</p>
<ul>
<li>
<p>updateOomAdjLocked：更新 adj，当目标进程为空或者被杀则返回 false；否则返回 true</p>
</li>
<li>
<p>computeOomAdjLocked：计算 adj，返回计算后 RawAdj 值</p>
</li>
<li>
<p>appOomAdjLocked：应用 adj，当需要杀掉目标进程则返回 false；否则返回 true</p>
<p>​		当 Android 四大组件状态改变时会 updataOomAdjLocked () 来同步更新相应进程的 ADJ 优先级。这里需要说明一下，当同一个进程有多个决定其优先级的组件状态时，取优先级最高的 ADJ 最为最终的 ADJ。另外，进程会通过设置 maxAdj 来限定 ADJ 的上限。关于分析进程 ADJ 相关信息，常用命令如下：</p>
</li>
<li>
<p>dumpsys  meminfo</p>
</li>
<li>
<p>dumpsys activity o</p>
</li>
<li>
<p>dumpsys activity p</p>
</li>
</ul>
<h2 id="1-adj-0-的进程"><a class="markdownIt-Anchor" href="#1-adj-0-的进程">#</a> 1. ADJ &lt; 0 的进程</h2>
<ul>
<li>
<p>NATIVE_ADJ (-1000)：是由 init 进程 fork 出来的 Native 进程，并不受 system 管控；</p>
</li>
<li>
<p>SYSTEM_ADJ (-900)：是指 system_server 进程；</p>
</li>
<li>
<p>PERSISTENT_PROC_ADJ (-800): 是指在 AndroidManifest.xml 中声明 android:persistent=”true” 的系统 (即带有 FLAG_SYSTEM 标记) 进程，persistent 进程一般情况并不会被杀，即便被杀或者发生 Crash 系统会立即重新拉起该进程。</p>
</li>
<li>
<p>PERSISTENT_SERVICE_ADJ (-700)：是由 startIsolatedProcess () 方式启动的进程，或者是由 system_server 或者 persistent 进程所绑定 (并且带有 BIND_ABOVE_CLIENT 或者 BIND_IMPORTANT) 的服务进程</p>
</li>
<li>
<p>BACKUP_APP_ADJ (300)：执行 bindBackupAgent () 过程的进程</p>
</li>
<li>
<p>HEAVY_WEIGHT_APP_ADJ (400): realStartActivityLocked () 过程，当应用的 privateFlags 标识 PRIVATE_FLAG_CANT_SAVE_STATE 的进程；</p>
</li>
<li>
<p>HOME_APP_ADJ (600)：当类型为 ACTIVITY_TYPE_HOME 的应用，比如桌面 APP</p>
</li>
<li>
<p>PREVIOUS_APP_ADJ (700)：用户上一个使用的 APP 进程</p>
</li>
</ul>
<h3 id="11-system_adj-900"><a class="markdownIt-Anchor" href="#11-system_adj-900">#</a> 1.1 SYSTEM_ADJ(-900)</h3>
<p>SYSTEM_ADJ: 仅指 system_server 进程。在执行 SystemServer 的 startBootstrapServices () 过程会调用 AMS.setSystemProcess ()，将 system_server 进程的 maxAdj 设置成 SYSTEM_ADJ，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSystemProcess</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">ApplicationInfo</span> <span class="variable">info</span> <span class="operator">=</span> mContext.getPackageManager().getApplicationInfo(</span><br><span class="line">            <span class="string">&quot;android&quot;</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);</span><br><span class="line">    mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="type">ProcessRecord</span> <span class="variable">app</span> <span class="operator">=</span> newProcessRecordLocked(info, info.processName, <span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">        app.persistent = <span class="literal">true</span>;</span><br><span class="line">        app.pid = MY_PID;</span><br><span class="line">        app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">        app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">        &#125;</span><br><span class="line">        updateLruProcessLocked(app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-persistent_proc_adj-800"><a class="markdownIt-Anchor" href="#12-persistent_proc_adj-800">#</a> 1.2 PERSISTENT_PROC_ADJ(-800)</h3>
<p>PERSISTENT_PROC_ADJ：在 AndroidManifest.xml 中申明 android:persistent=”true” 的系统 (即带有 FLAG_SYSTEM 标记) 进程，称之为 persistent 进程。对于 persistent 进程常规情况都不会被杀，一旦被杀或者发生 Crash，进程会立即重启。</p>
<p>场景一：newProcessRecordLocked</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessRecord <span class="title function_">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess, <span class="type">boolean</span> isolated, <span class="type">int</span> isolatedUid)</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">proc</span> <span class="operator">=</span> customProcess != <span class="literal">null</span> ? customProcess : info.processName;</span><br><span class="line">  <span class="keyword">final</span> <span class="type">int</span> <span class="variable">userId</span> <span class="operator">=</span> UserHandle.getUserId(info.uid);</span><br><span class="line">  <span class="type">int</span> <span class="variable">uid</span> <span class="operator">=</span> info.uid;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">final</span> <span class="type">ProcessRecord</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessRecord</span>(stats, info, proc, uid);</span><br><span class="line">  <span class="keyword">if</span> (!mBooted &amp;&amp; !mBooting</span><br><span class="line">          &amp;&amp; userId == UserHandle.USER_SYSTEM</span><br><span class="line">          &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">      r.persistent = <span class="literal">true</span>;</span><br><span class="line">      r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isolated &amp;&amp; isolatedUid != <span class="number">0</span>) &#123;</span><br><span class="line">      r.maxAdj = ProcessList.PERSISTENT_SERVICE_ADJ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景二： addAppLocked</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessRecord <span class="title function_">addAppLocked</span><span class="params">(ApplicationInfo info, String customProcess, <span class="type">boolean</span> isolated, String abiOverride)</span> &#123;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(customProcess != <span class="literal">null</span> ? customProcess : info.processName,</span><br><span class="line">                info.uid, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="literal">null</span>) &#123;</span><br><span class="line">        app = newProcessRecordLocked(info, customProcess, isolated, <span class="number">0</span>);</span><br><span class="line">        updateLruProcessLocked(app, <span class="literal">false</span>, <span class="literal">null</span>);</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        app.persistent = <span class="literal">true</span>;</span><br><span class="line">        app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="literal">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mPersistentStartingProcesses.add(app);</span><br><span class="line">        startProcessLocked(app, <span class="string">&quot;added application&quot;</span>,</span><br><span class="line">                customProcess != <span class="literal">null</span> ? customProcess : app.processName, abiOverride);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-persistent_service_adj-700"><a class="markdownIt-Anchor" href="#13-persistent_service_adj-700">#</a> 1.3 PERSISTENT_SERVICE_ADJ(-700)</h3>
<p>PERSISTENT_SERVICE_ADJ: startIsolatedProcess () 方式启动的进程，或者是由 system_server 或者 persistent 进程所绑定的服务进程。</p>
<p>场景一： newProcessRecordLocked</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">final ProcessRecord <span class="title function_">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess, boolean isolated, <span class="type">int</span> isolatedUid)</span> &#123;</span><br><span class="line">  String proc = customProcess != null ? customProcess : info.processName;</span><br><span class="line">  final <span class="type">int</span> userId = UserHandle.getUserId(info.uid);</span><br><span class="line">  <span class="type">int</span> uid = info.uid;</span><br><span class="line">  ...</span><br><span class="line">  final ProcessRecord r = new ProcessRecord(stats, info, proc, uid);</span><br><span class="line">  <span class="keyword">if</span> (!mBooted &amp;&amp; !mBooting</span><br><span class="line">          &amp;&amp; userId == UserHandle.USER_SYSTEM</span><br><span class="line">          &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">      r.persistent = <span class="literal">true</span>;</span><br><span class="line">      r.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isolated &amp;&amp; isolatedUid != <span class="number">0</span>) &#123; <span class="comment">//startIsolatedProcess</span></span><br><span class="line">      r.maxAdj = ProcessList.PERSISTENT_SERVICE_ADJ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用链如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">startOtherServices</span><br><span class="line">  WebViewUpdateService.prepareWebViewInSystemServer</span><br><span class="line">    WebViewUpdateServiceImpl.prepareWebViewInSystemServer</span><br><span class="line">      WebViewUpdater.prepareWebViewInSystemServer</span><br><span class="line">        WebViewUpdater.onWebViewProviderChanged</span><br><span class="line">          SystemImpl.onWebViewProviderChanged</span><br><span class="line">            WebViewFactory.onWebViewProviderChanged</span><br><span class="line">              WebViewLibraryLoader.prepareNativeLibraries</span><br><span class="line">                WebViewLibraryLoader.createRelros</span><br><span class="line">                  WebViewLibraryLoader.createRelroFile</span><br><span class="line">                    AMS.startIsolatedProcess</span><br></pre></td></tr></table></figure>
<h3 id="14-backup_app_adl300"><a class="markdownIt-Anchor" href="#14-backup_app_adl300">#</a> 1.4 BACKUP_APP_ADL(300)</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mBackupTarget != null &amp;&amp; app == mBackupTarget.app) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.BACKUP_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.BACKUP_APP_ADJ;</span><br><span class="line">        <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND) &#123;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_TRANSIENT_BACKGROUND;</span><br><span class="line">        &#125;</span><br><span class="line">        app.adjType = <span class="string">&quot;backup&quot;</span>;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_BACKUP) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_BACKUP;</span><br><span class="line">        app.adjType = <span class="string">&quot;backup&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>执行 bindBackupAgent () 过程，设置 mBackupTarget 值；</p>
</li>
<li>
<p>执行 clearPendingBackup () 或 unbindBackupAgent () 过程，置空 mBackupTarget 值；</p>
</li>
</ul>
<h3 id="15-heavy_weight_app_adj400"><a class="markdownIt-Anchor" href="#15-heavy_weight_app_adj400">#</a> 1.5 HEAVY_WEIGHT_APP_ADJ(400)</h3>
<ul>
<li>
<p>realStartActivityLocked () 过程，当应用的 privateFlags 标识 PRIVATE_FLAG_CANT_SAVE_STATE，设置 mHeavyWeightProcess 值；</p>
</li>
<li>
<p>finishHeavyWeightApp (), 置空 mHeavyWeightProcess 值；</p>
</li>
</ul>
<h3 id="16-home_app_adj600"><a class="markdownIt-Anchor" href="#16-home_app_adj600">#</a> 1.6 HOME_APP_ADJ(600)</h3>
<p>当类型为 ACTIVITY_TYPE_HOME 的应用启动后会设置 mHomeProcess, 比如桌面 APP</p>
<h3 id="17-previous_app_adj700"><a class="markdownIt-Anchor" href="#17-previous_app_adj700">#</a> 1.7 PREVIOUS_APP_ADJ(700)</h3>
<p>场景 1： 用户上一个使用的包含 UI 的进程，为了给用户在两个 APP 之间更好的切换体验，将上一个进程 ADJ 设置到 PREVOUS_APP_ADJ 的档次。当 activityStoppedLocked () 过程会更新上一个应用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;previous&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">        app.adjType = <span class="string">&quot;previous&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景 2： 当 provider 进程，上一次使用时间不超过 20S 的情况下，优先级不低于 PREVIOUS_APP_ADJ。provider 进程这个是 Android 7.0 以后新增的逻辑 ，这样做的好处是在内存比较低的情况下避免拥有 provider 的进程出现颠簸，也就是启动后杀，然后又被拉。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (app.lastProviderTime &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (app.lastProviderTime+mConstants.CONTENT_PROVIDER_RETAIN_TIME) &gt; now) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">        adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = <span class="literal">false</span>;</span><br><span class="line">        app.adjType = <span class="string">&quot;recent-provider&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">        app.adjType = <span class="string">&quot;recent-provider&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-foreground_app_adj0"><a class="markdownIt-Anchor" href="#2-foreground_app_adj0">#</a> 2. FOREGROUND_APP_ADJ(0)</h2>
<p>场景 1：满足以下任一条件的进程都属于 FOREGROUND_APP_ADJ (0) 优先级：</p>
<ul>
<li>
<p>正处于 resumed 状态的 Activity</p>
</li>
<li>
<p>正执行一个生命周期回调的 Service（比如执行 onCreate,onStartCommand,onDestroy 等）</p>
</li>
<li>
<p>正执行 onReceive () 的 BroadcastReceiver</p>
</li>
<li>
<p>通过 startInstrumentation () 启动的进程</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (PROCESS_STATE_CUR_TOP == ActivityManager.PROCESS_STATE_TOP &amp;&amp; app == TOP_APP) &#123;</span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">    app.adjType = <span class="string">&quot;top-activity&quot;</span>;</span><br><span class="line">    foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">    procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instr != null) &#123;</span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.adjType = <span class="string">&quot;instrumentation&quot;</span>;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (isReceivingBroadcastLocked(app, mTmpBroadcastQueue)) &#123;</span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = (mTmpBroadcastQueue.contains(mFgBroadcastQueue))</span><br><span class="line">            ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">&quot;broadcast&quot;</span>;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_RECEIVER;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.executingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = app.execServicesFg ?</span><br><span class="line">            ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">&quot;exec-service&quot;</span>;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app == TOP_APP) &#123;</span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">&quot;top-sleeping&quot;</span>;</span><br><span class="line">    foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">    procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    adj = cachedAdj;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">    app.cached = <span class="literal">true</span>;</span><br><span class="line">    app.empty = <span class="literal">true</span>;</span><br><span class="line">    app.adjType = <span class="string">&quot;cch-empty&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景 2： 当客户端进程 activity 里面调用 bindService () 方法时 flags 带有 BIND_ADJUST_WITH_ACTIVITY 参数，并且该 activity 处于可见状态，则当前服务进程也属于前台进程，源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> is = app.services.size()<span class="number">-1</span>; is &gt;= <span class="number">0</span>; is--) &#123;</span><br><span class="line">    ServiceRecord s = app.services.valueAt(is);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> conni = s.connections.size()<span class="number">-1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; clist.size(); i++) &#123;</span><br><span class="line">            ConnectionRecord cr = clist.get(i);</span><br><span class="line">            <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span>) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            final ActivityRecord a = cr.activity;</span><br><span class="line">            <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a != null &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp;</span><br><span class="line">                    (a.visible || a.state == ActivityState.RESUMED ||</span><br><span class="line">                     a.state == ActivityState.PAUSING)) &#123;</span><br><span class="line">                    adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</span><br><span class="line">                            schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    app.cached = <span class="literal">false</span>;</span><br><span class="line">                    app.adjType = <span class="string">&quot;service&quot;</span>;</span><br><span class="line">                    app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                            .REASON_SERVICE_IN_USE;</span><br><span class="line">                    app.adjSource = a;</span><br><span class="line">                    app.adjSourceProcState = procState;</span><br><span class="line">                    app.adjTarget = s.name;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景 3： 对于 provider 客户端进程，还有以下两个条件能成为前台进程：</p>
<ul>
<li>
<p>当 Provider 的客户端进程 ADJ&lt;=FOREGROUND_APP_ADJ 时，则 Provider 进程 ADJ 等于 FOREGROUND_APP_ADJ</p>
</li>
<li>
<p>当 Provider 有外部 (非框架) 进程依赖，也就是调用了 getContentProviderExternal () 方法，则 ADJ 至少等于 FOREGROUND_APP_ADJ</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> provi = app.pubProviders.size()<span class="number">-1</span>; provi &gt;= <span class="number">0</span>; provi--) &#123;</span><br><span class="line">    ContentProviderRecord cpr = app.pubProviders.valueAt(provi);</span><br><span class="line">    <span class="comment">//根据client来调整provider进程的adj和procState</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cpr.connections.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderConnection conn = cpr.connections.get(i);</span><br><span class="line">        ProcessRecord client = conn.client;</span><br><span class="line">        <span class="type">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);</span><br><span class="line">        <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                    &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                        ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">                adjType = <span class="string">&quot;provider&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            app.cached &amp;= client.cached;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据provider外部依赖情况来调整adj和schedGroup</span></span><br><span class="line">    <span class="keyword">if</span> (cpr.hasExternalProcessHandles()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (adj &gt; ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">             adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">             schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">             app.cached = <span class="literal">false</span>;</span><br><span class="line">             app.adjType = <span class="string">&quot;ext-provider&quot;</span>;</span><br><span class="line">             app.adjTarget = cpr.name;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-visible_app_adj100"><a class="markdownIt-Anchor" href="#3-visible_app_adj100">#</a> 3. VISIBLE_APP_ADJ(100)</h2>
<p>可见进程：当 ActivityRecord 的 visible=true，也就是 Activity 可见的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123;</span><br><span class="line">        final ActivityRecord r = app.activities.get(j);</span><br><span class="line">        <span class="keyword">if</span> (r.visible) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">                adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">&quot;vis-activity&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123;</span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">                app.adjType = <span class="string">&quot;vis-activity&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">            app.cached = <span class="literal">false</span>;</span><br><span class="line">            app.empty = <span class="literal">false</span>;</span><br><span class="line">            foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">            final TaskRecord task = r.getTask();</span><br><span class="line">            <span class="keyword">if</span> (task != null &amp;&amp; minLayer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                final <span class="type">int</span> layer = task.mLayerRank;</span><br><span class="line">                <span class="keyword">if</span> (layer &gt;= <span class="number">0</span> &amp;&amp; minLayer &gt; layer) &#123;</span><br><span class="line">                    minLayer = layer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (adj == ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">        adj += minLayer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 Android P 开始，进一步细化 ADJ 级别，增加了 VISIBLE_APP_LAYER_MAX (99)，是指 VISIBLE_APP_ADJ (100) 跟 PERCEPTIBLE_APP_ADJ (200) 之间有 99 个槽，则可见级别 ADJ 的取值范围为 [100,199]。 算法会根据其所在 task 的 mLayerRank 来调整其 ADJ，100 加上 mLayerRank 就等于目标 ADJ，layer 越大，则 ADJ 越小。</p>
<p>当 TaskRecord 顶部的 ActivityRecord 为空或者结束或者不可见时，则设置该 TaskRecord 的 mLayerRank 等于 - 1; 每个 ActivityDisplay 的 baseLayer 都是从 0 开始，从最上面的 TaskRecord 开始，第一个 ADJ=100，从上至下依次加 1，直到 199 为上限。</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205092201897.png" alt="image-20220509220115658"></p>
<h2 id="4-perceptible_app_adj200"><a class="markdownIt-Anchor" href="#4-perceptible_app_adj200">#</a> 4. PERCEPTIBLE_APP_ADJ(200)</h2>
<p>可感知进程：当该进程存在不可见的 Activity，但 Activity 正处于 PAUSING、PAUSED、STOPPING 状态，则为 PERCEPTIBLE_APP_ADJ</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123;</span><br><span class="line">        final ActivityRecord r = app.activities.get(j);</span><br><span class="line">        <span class="keyword">if</span> (r.visible) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">&quot;pause-activity&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123;</span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">                app.adjType = <span class="string">&quot;pause-activity&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">            app.cached = <span class="literal">false</span>;</span><br><span class="line">            app.empty = <span class="literal">false</span>;</span><br><span class="line">            foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.STOPPING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">&quot;stop-activity&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!r.finishing) &#123;</span><br><span class="line">                <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">                    procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">                    app.adjType = <span class="string">&quot;stop-activity&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            app.cached = <span class="literal">false</span>;</span><br><span class="line">            app.empty = <span class="literal">false</span>;</span><br><span class="line">            foregroundActivities = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>满足以下任一条件的进程也属于可感知进程:</p>
<ul>
<li>
<p>foregroundServices 非空：前台服务进程，执行 startForegroundService () 方法</p>
</li>
<li>
<p>app.forcingToImportant 非空：执行 setProcessImportant () 方法，比如 Toast 弹出过程。</p>
</li>
<li>
<p>hasOverlayUi 非空：非 activity 的 UI 位于屏幕最顶层，比如显示类型 TYPE_APPLICATION_OVERLAY 的窗口</p>
</li>
</ul>
<h2 id="5-service_adj500"><a class="markdownIt-Anchor" href="#5-service_adj500">#</a> 5. SERVICE_ADJ(500)</h2>
<p>服务进程：没有启动过 Activity，并且 30 分钟之内活跃过的服务进程。 startRequested 为 true，则代表执行 startService () 且没有 stop 的进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> is = app.services.size()<span class="number">-1</span>; is &gt;= <span class="number">0</span>; is--) &#123;</span><br><span class="line">    ServiceRecord s = app.services.valueAt(is);</span><br><span class="line">    <span class="keyword">if</span> (s.startRequested) &#123;</span><br><span class="line">        app.hasStartedServices = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">            app.adjType = <span class="string">&quot;started-services&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                app.adjType = <span class="string">&quot;cch-started-ui-services&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (now &lt; (s.lastActivity + mConstants.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                    adj = ProcessList.SERVICE_ADJ;</span><br><span class="line">                    app.adjType = <span class="string">&quot;started-services&quot;</span>;</span><br><span class="line">                    app.cached = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> conni = s.connections.size()<span class="number">-1</span>; conni &gt;= <span class="number">0</span>; conni--) &#123;</span><br><span class="line">        ... <span class="comment">//根据client情况来调整adj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-service_b_adj800"><a class="markdownIt-Anchor" href="#6-service_b_adj800">#</a> 6. SERVICE_B_ADJ(800)</h2>
<p>进程由 SERVICE_ADJ (500) 降低到 SERVICE_B_ADJ (800)，有以下两种情况：</p>
<ul>
<li>
<p>A 类 Service 占比过高：当 A 类 Service 个数 &gt; Service 总数的 1/3 时，则加入到 B 类 Service。换句话说，B Service 的个数至少是 A Service 的 2 倍。</p>
</li>
<li>
<p>内存紧张并且 A 类 Service 占用内存较高：当系统内存紧张级别 (mLastMemoryLevel) 高于 ADJ_MEM_FACTOR_NORMAL，且该应用所占内存 lastPss 大于或等于 CACHED_APP_MAX_ADJ 级别所对应的内存阈值的 1/3（默认值阈值约等于 110MB）。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (adj == ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (doingAll) &#123;</span><br><span class="line">        app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs/<span class="number">3</span>);</span><br><span class="line">        mNewNumServiceProcs++;</span><br><span class="line">        <span class="keyword">if</span> (!app.serviceb) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL</span><br><span class="line">                    &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) &#123;</span><br><span class="line">                app.serviceHighRam = <span class="literal">true</span>;</span><br><span class="line">                app.serviceb = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mNewNumAServiceProcs++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app.serviceHighRam = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (app.serviceb) &#123;</span><br><span class="line">        adj = ProcessList.SERVICE_B_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-cached_app_min_adj900"><a class="markdownIt-Anchor" href="#7-cached_app_min_adj900">#</a> 7. CACHED_APP_MIN_ADJ(900)</h2>
<p>缓存进程优先级从 CACHED_APP_MIN_ADJ (900) 到 CACHED_APP_MAX_ADJ (906)。</p>
<p>ADJ 的转换算法：</p>
<ul>
<li>cached: 900, 901, 903, 905</li>
<li>empty: 900, 902, 904, 906</li>
</ul>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205092213631.png" alt="image-20220509221346179"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">final <span class="type">int</span> N = mLruProcesses.size();</span><br><span class="line"><span class="comment">//numSlots等于3</span></span><br><span class="line"><span class="type">int</span> numSlots = (ProcessList.CACHED_APP_MAX_ADJ</span><br><span class="line">        - ProcessList.CACHED_APP_MIN_ADJ + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">//mNumNonCachedProcs是指empty和cached之外的进程， mNumCachedHiddenProcs代表的是cached进程个数</span></span><br><span class="line"><span class="type">int</span> numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</span><br><span class="line"><span class="keyword">if</span> (numEmptyProcs &gt; cachedProcessLimit) &#123;</span><br><span class="line">    numEmptyProcs = cachedProcessLimit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//emptyFactor和cachedFactor分别代表每个slot里面包括的进程个数，大于或等于1</span></span><br><span class="line"><span class="type">int</span> emptyFactor = numEmptyProcs/numSlots;</span><br><span class="line"><span class="type">int</span> cachedFactor = (mNumCachedHiddenProcs &gt; <span class="number">0</span> ? mNumCachedHiddenProcs : <span class="number">1</span>)/numSlots;</span><br><span class="line">                    app.curRawAdj = curEmptyAdj;</span><br><span class="line">                    ...</span><br><span class="line">                    <span class="comment">//ADJ阈值</span></span><br><span class="line">                    app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-schedgroup"><a class="markdownIt-Anchor" href="#8-schedgroup">#</a> 8. schedGroup</h2>
<p>Android 进程优先级 ADJ 的每一个 ADJ 级别往往都有多种场景，使用 adjType 完美地区分相同 ADJ 下的不同场景； 不同 ADJ 进程所对应的 schedGroup 不同，从而分配的 CPU 资源也不同，schedGroup 大体分为 TOP (T)、前台 (F)、后台 (B)； ADJ 跟 AMS 中的 procState 有着紧密的联系。</p>
<ul>
<li>
<p>adj：通过调整 oom_score_adj 来影响进程寿命 (Lowmemorykiller 杀进程策略)；</p>
</li>
<li>
<p>schedGroup：影响进程的 CPU 资源调度与分配；</p>
</li>
<li>
<p>procState：从进程所包含的四大组件运行状态来评估进程状态，影响 framework 的内存控制策略。比如控制缓存进程和空进程个数上限依赖于 procState，再比如控制 APP 执行 handleLowMemory () 的触发时机等。</p>
</li>
</ul>
<p>为了说明整体关系，以 ADJ 为中心来讲解跟 adjType,schedGroup,procState 的对应关系，下面以一幅图来诠释整个 ADJ 算法的精髓，几乎涵盖了 ADJ 算法调整的绝大多数场景。</p>
<p><img src="https://raw.githubusercontent.com/y1seco/blog_image/master/img/202205092248406.png" alt="img"></p>
<h2 id="9-syslmkminfree_levels"><a class="markdownIt-Anchor" href="#9-syslmkminfree_levels">#</a> 9. sys.lmk.minfree_levels</h2>
<p>ProcessList.java 会在初始化时将 oom_adj 的 minfree 水位更新给 lmkd，并由 lmkd 配置到 prop sys.lmk.minfree_levels 中。</p>
<p>frameworks/base/services/core/java/com/android/server/am/ProcessList.java</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private <span class="type">void</span> <span class="title function_">updateOomLevels</span><span class="params">(<span class="type">int</span> displayWidth, <span class="type">int</span> displayHeight, boolean write)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        ByteBuffer buf = ByteBuffer.allocate(<span class="number">4</span> * (<span class="number">2</span> * mOomAdj.length + <span class="number">1</span>));</span><br><span class="line">        buf.putInt(LMK_TARGET);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mOomAdj.length; i++) &#123;</span><br><span class="line">            buf.putInt((mOomMinFree[i] * <span class="number">1024</span>)/PAGE_SIZE);</span><br><span class="line">            buf.putInt(mOomAdj[i]);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        writeLmkd(buf, null);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过代码可知，会将 mOomMinFree 的水位数组以 page 形式传递给 lmkd。</p>
<p>mOomAdj 数组是代码固定的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] mOomAdj = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">        FOREGROUND_APP_ADJ, VISIBLE_APP_ADJ, PERCEPTIBLE_APP_ADJ,</span><br><span class="line">        PERCEPTIBLE_LOW_APP_ADJ, CACHED_APP_MIN_ADJ, CACHED_APP_LMK_FIRST_ADJ</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前没有配置的方式，如果需要修改等级，只能修改源码。</p>
<p>mOomMinFree 数组是通过算法计算</p>
<p>上图大致整理了整个水位的计算过程，下面详细剖析这个过程。</p>
<h3 id="91-确定scale"><a class="markdownIt-Anchor" href="#91-确定scale">#</a> 9.1 确定 scale</h3>
<p>​        float scaleMem = ((float) (mTotalMemMb - 350)) / (700 - 350);</p>
<pre><code>    // Scale buckets from screen size.
    int minSize = 480 * 800;  //  384000
    int maxSize = 1280 * 800; // 1024000  230400 870400  .264
    float scaleDisp = ((float)(displayWidth * displayHeight) - minSize) / (maxSize - minSize);
    if (false) &#123;
        Slog.i(&quot;XXXXXX&quot;, &quot;scaleMem=&quot; + scaleMem);
        Slog.i(&quot;XXXXXX&quot;, &quot;scaleDisp=&quot; + scaleDisp + &quot; dw=&quot; + displayWidth
                + &quot; dh=&quot; + displayHeight);
    &#125;
 
    float scale = scaleMem &gt; scaleDisp ? scaleMem : scaleDisp;
    if (scale &lt; 0) scale = 0;
    else if (scale &gt; 1) scale = 1;
</code></pre>
<p>主要分两部分，内存和分辨率。</p>
<p>确认内存是否超过 700M，如果低于 700M，将会有个 scaleMem 百分比；<br>
确认分辨率是否超过 1280*800，如果低于，将会有个 scaleDisp 百分比；<br>
通过 scaleMem 和 scaleDisp，取其中最大百分比，不超过 1；<br>
按照目前设备来说，手机设备的内存基本都是超过 700M 的，所以，无论手机分辨率，scale 都为 1 的。</p>
<h3 id="92-初步计算moomminfree"><a class="markdownIt-Anchor" href="#92-初步计算moomminfree">#</a> 9.2 初步计算 mOomMinFree</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mOomAdj.length; i++) &#123;</span><br><span class="line">​            <span class="type">int</span> low = mOomMinFreeLow[i];</span><br><span class="line">​            <span class="type">int</span> high = mOomMinFreeHigh[i];</span><br><span class="line">​            <span class="keyword">if</span> (is64bit) &#123;</span><br><span class="line">​                <span class="comment">// Increase the high min-free levels for cached processes for 64-bit</span></span><br><span class="line">​                <span class="keyword">if</span> (i == <span class="number">4</span>) high = (high * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">​                <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) high = (high * <span class="number">7</span>) / <span class="number">4</span>;</span><br><span class="line">​            &#125;</span><br><span class="line">​            mOomMinFree[i] = (<span class="type">int</span>)(low + ((high - low) * scale));</span><br><span class="line">​        &#125;</span><br></pre></td></tr></table></figure>
<p>ProcessList.java 中定义了两个数组：</p>
<pre><code>private final int[] mOomMinFreeLow = new int[] &#123;
        12288, 18432, 24576,
        36864, 43008, 49152
&#125;;
// These are the high-end OOM level limits.  This is appropriate for a
// 1280x800 or larger screen with around 1GB RAM.  Values are in KB.
private final int[] mOomMinFreeHigh = new int[] &#123;
        73728, 92160, 110592,
        129024, 147456, 184320
&#125;;
</code></pre>
<p>这个是默认的水位，按照 3.1 节，scale 对于手机设备值是为 1 的，也就是说 mOomMinFree 最终取值是按照 high。而 high 对于 64 位系统对于最后两个等级会进行放大。</p>
<h3 id="93-进一步计算moomminfree"><a class="markdownIt-Anchor" href="#93-进一步计算moomminfree">#</a> 9.3 进一步计算 mOomMinFree</h3>
<pre><code> if (minfree_abs &gt;= 0) &#123;
            for (int i = 0; i &lt; mOomAdj.length; i++) &#123;
                mOomMinFree[i] = (int)((float)minfree_abs * mOomMinFree[i]
                        / mOomMinFree[mOomAdj.length - 1]);
            &#125;
        &#125;
   
   if (minfree_adj != 0) &#123;
        for (int i = 0; i &lt; mOomAdj.length; i++) &#123;
            mOomMinFree[i] += (int)((float) minfree_adj * mOomMinFree[i]
                    / mOomMinFree[mOomAdj.length - 1]);
            if (mOomMinFree[i] &lt; 0) &#123;
                mOomMinFree[i] = 0;
            &#125;
        &#125;
    &#125;
</code></pre>
<p>系统中还提供了两个 config，用以对默认的 minFree 进行一定的缩放：</p>
<pre><code>    int minfree_adj = Resources.getSystem().getInteger(
            com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAdjust);
    int minfree_abs = Resources.getSystem().getInteger(
            com.android.internal.R.integer.config_lowMemoryKillerMinFreeKbytesAbsolute);
</code></pre>
<p>对于设定 minfree_abs 的 config 值时，mOomMinFree 会按照 minfree_abs 进行比例缩放；<br>
对于设定 minfree_adj 的 config 值时，mOomMinFree 是按照 minfree_adj 进行比例增加；<br>
Q1 控制 oom adj 水位策略</p>
<p>当 lmkd 触发，应该是系统中的内存超出了我们设定的界限，需要根据内存的使用情况判断 adj 的 level，进而 kill 相关的进程，而 adj level 和进程状态都是在 AMS 中修改。我们能做的就是控制 mOomMinFree 和 oom_adj 的 6 个 level。</p>
<p>最低 level 的 oom_adj 对应的 minfree 是内存最小的时候，这个时候内存严重紧张，应控制 oom_adj level，使其在此时不要 kill 重要进程。可以根据情况减小 mOomMinFreeHigh [0]、mOomMinFreeHigh [1] 等低等级的内存值，使其在内存很小情况下才触发 lmkd；<br>
最高 level 的 oom_adj 对应 minfree 是内存部分紧张，只是想 lmkd 将不重要的进程 kill 掉，所以，可以放大 mOomMinFreeHigh [4]、mOomMinFreeHigh [5] 使其在内存快要紧张的时候，尽快把不重要的进程 kill；将重要的进程尽量放 mOomAdj 的低 level 中</p>
<h1 id="五-分析结论"><a class="markdownIt-Anchor" href="#五-分析结论">#</a> 五、分析结论</h1>
<p>​		通过对 LMK 源码的分析，对 Android 低内存的管理机制有了更深的了解。LMK 的主要流程是 frameworks 的 ProcessList.java 调整 adj，通过 socket 通信将事件发送给 native 的守护进程 lmkd；lmkd 再根据具体的命令来执行相应操作，其主要功能是用来更新 oom_score_adj 值以及 lowmemorykiller 驱动的 parameters（包括 minfree 和 adj）。最后讲到了 lowmemorykiller 驱动，通过注册 shrinker，借助 linux 标准的内存回收机制，根据系统可用内存以及 parameters 配置参数（adj，minfree）来选取合适的 selected_oom_score_adj，再从所有进程中选择 adj 大于该目标值并占有 rss 内存最大的进程，将其杀掉从而释放出内存。</p>
<p>​		通过查阅资料了解到：Android 使用内核中的低内存终止守护程序（LMK）驱动程序来监控系统内存压力，该驱动程序是一种依赖于硬编码值的严格机制。从内核 4.12 开始，LMK 驱动程序已从上游内核中移除，改由用户空间 lmkd 来执行内存监控和进程终止任务。Android 低内存守护程序 lmkd 进程可监控运行中的 Android 系统的内存状态，并通过终止最不必要的进程来应对内存压力大的问题，使系统以可接受的性能水平运行。</p>
<p>​		Android 采用层次化系统架构，由底层向上分为 4 个主要功能层，分别是 Linux 内核层、系统运行时库层、应用程序框架层和应用程序层。对于 Linux 内核层来说，Android 以 Linux 操作系统内核为基础，借助 Linux 内核服务实现硬件设备驱动、进程和内存管理、网络协议栈、电源管理、无线通信等核心功能。Android4.0 版本之前基于 Linux2.6 系列内核，4.0 及之后的版本使用更新的 Linux3.X 内核，并且两个开源项目有了互通。Linux3.3 内核中正式包括以下 Android 代码，可以直接引导进 Android。Linux3.4 将会增添电源管理等更多功能，以增加与 Android 的硬件兼容性，使 Android 在更多设备上得到支持。Android 对 Linux 内核进行了增强，增加了一些面向移动计算的特有功能。例如，低内存管理器 LMK、匿名共享内存 Ashmem、轻量级的进程间通信 Binder 机制等。这些内核的增强使 Android 在继承 Linux 内核安全机制的同时，进一步提升了内存管理，进程间通信等方面的安全性。</p>
<p>​		内核驱动和用户软件之间还存在一层硬件抽象层（HAL），它是对硬件设备的具体实现加以抽象。鉴于许多硬件设备厂商不希望公开其设备驱动的源代码，如果能将 Android 的应用程序框架层与 Linux 系统内核的设备驱动隔离，使应用程序框架的开发尽量独立于具体的驱动程序，则 Android 将减少对 Linux 内核的依赖。所以 HAL 是对 Linux 内核驱动程序进行的封装，将硬件抽象化，屏蔽掉底层的实现细节。HAL 规定了一套应用层对硬件层读写和配置的统一接口，本质上就是将硬件的驱动分为用户空间和内核空间两个层面；Linux 内核驱动程序运行与内核空间，硬件抽象层运行与用户空间。</p>
<p>​		在系统运行库层，通过一些 C/C++ 库来为 Android 系统提供了主要的特性支持。如 SQLite 提供了数据库的支持，OpenGL|ES 提供了 3D 绘图的支持，Webkit 库提供了浏览器内核的支持等。同样在这一层还有 Android 运行时库，它主要提供了一些核心库，能够允许开发者使用 Java 语言来编写 Android 应用。另外 Android 运行时库中还包含了 Dalvik 虚拟机，它使得每一个 Android 应用都能运行在独立的进程当中，并且拥有一个自己的 Dalvik 虚拟机实例。相较于 Java 虚拟机，Dalvik 是专门为移动设备定制的，它针对手机内存、CPU 性能有限等情况作了优化处理。</p>
<p>​		应用程序框架层提供开发 Android 应用程序所需的一系列类库，构建应用程序时可能用到的 API 等，使开发人员可以进行快速的应用程序开发，方便重用组件，也可以通过继承实现个性化的扩展。而应用层就是 Android 平台上包括各类与用户直接交互的应用程序，或由 java 语言编写的运行与后台的服务程序。例如智能手机上实现的基本功能程序，像 SMS 短信，电话拨号，日历，浏览器等。</p>
</div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/android/">android</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/android/">android</a></div><hr></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"><img class="fill" src="https://w.wallhaven.cc/full/1k/wallhaven-1km5dg.jpg" alt="arm-trusted-firmware可信启动机制"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-04-20  <a class="commentCountImg" href="/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/#comment-container"><span class="display-none-class">3d9981d53f6c0bbc249c97d69eab8dbb</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="3d9981d53f6c0bbc249c97d69eab8dbb">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>28 m  <i class="fas fa-pencil-alt"> </i>4.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">arm-trusted-firmware可信启动机制</a></h1><div class="content"><p>ATF 可信启动调研</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/arm/">arm</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/arm/">arm</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-04-20T02:39:46.127Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-04-20</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/04/10/OPTEE_ATF/"><img class="fill" src="https://w.wallhaven.cc/full/l3/wallhaven-l37vzy.png" alt="基于QEMU的OPTEE/ATF学习"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-04-10  <a class="commentCountImg" href="/2022/04/10/OPTEE_ATF/#comment-container"><span class="display-none-class">f063cad175271c0297f83da6367cb4b7</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="f063cad175271c0297f83da6367cb4b7">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>4 m  <i class="fas fa-pencil-alt"> </i>0.6 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/10/OPTEE_ATF/">基于QEMU的OPTEE/ATF学习</a></h1><div class="content"><p>OPTEE/ATF</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/qemu/">qemu</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/qemu/">qemu</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/04/10/OPTEE_ATF/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-04-10T14:01:46.882Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-04-10</time></div></div></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/"><img class="fill" src="https://w.wallhaven.cc/full/3z/wallhaven-3zy6r3.jpg" alt="vue开发问题总结"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-03-07  <a class="commentCountImg" href="/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/#comment-container"><span class="display-none-class">5d20ec74c09c157f638f9794ba21c9b3</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5d20ec74c09c157f638f9794ba21c9b3">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>22 m  <i class="fas fa-pencil-alt"> </i>3.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/">vue开发问题总结</a></h1><div class="content"><p>vue 开发中遇到的一些问题及解决方法</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/vue/">vue</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/vue/">vue</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-03-07T01:35:27.688Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-03-07</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/"><img class="fill" src="https://w.wallhaven.cc/full/v9/wallhaven-v9v3r5.jpg" alt="BUUOJ PWN EXERCISE(二)"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-03-03  <a class="commentCountImg" href="/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/#comment-container"><span class="display-none-class">0b195601707f5a99300623dc236f0dc2</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="0b195601707f5a99300623dc236f0dc2">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>9 m  <i class="fas fa-pencil-alt"> </i>1.4 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/">BUUOJ PWN EXERCISE(二)</a></h1><div class="content"><p>heap</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/pwn/">pwn</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/pwn/">pwn</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-03-06T16:30:09.823Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-03-07</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/"><img class="fill" src="https://w.wallhaven.cc/full/o3/wallhaven-o3vyk5.jpg" alt="CTFSHOW卷王杯-pwn"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-02-27  <a class="commentCountImg" href="/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/#comment-container"><span class="display-none-class">b6846a5fad9dd2690cb52184d101b5b6</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b6846a5fad9dd2690cb52184d101b5b6">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>21 m  <i class="fas fa-pencil-alt"> </i>3.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/">CTFSHOW卷王杯-pwn</a></h1><div class="content"><p>根据官方 wp 学习了两道好题</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/pwn/">pwn</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/pwn/">pwn</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/02/27/CTFSHOW%E5%8D%B7%E7%8E%8B%E6%9D%AF-%20Incomplete%20Menu/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-02-27T15:36:59.645Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-02-27</time></div></div></div></article></div><!--!--><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/02/27/gyctf_2020_force/"><img class="fill" src="https://w.wallhaven.cc/full/72/wallhaven-72m8ve.jpg" alt="gyctf_2020_force"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-02-27  <a class="commentCountImg" href="/2022/02/27/gyctf_2020_force/#comment-container"><span class="display-none-class">5a3e0a5e575738dd4840f501f229915f</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5a3e0a5e575738dd4840f501f229915f">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>a minute  <i class="fas fa-pencil-alt"> </i>0.2 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/27/gyctf_2020_force/">gyctf_2020_force</a></h1><div class="content"><p>house of force,realloc 调整栈帧</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/pwn/">pwn</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/pwn/">pwn</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/02/27/gyctf_2020_force/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-02-27T14:01:28.076Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-02-27</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/02/18/BUUCTF%20Pwn%20Exercise/"><img class="fill" src="https://w.wallhaven.cc/full/o3/wallhaven-o3wzql.jpg" alt="BUUCTF Pwn Exercise(一)"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-02-18  <a class="commentCountImg" href="/2022/02/18/BUUCTF%20Pwn%20Exercise/#comment-container"><span class="display-none-class">5caf129b406f9d30def7d50113db154d</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="5caf129b406f9d30def7d50113db154d">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>29 m  <i class="fas fa-pencil-alt"> </i>4.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/18/BUUCTF%20Pwn%20Exercise/">BUUCTF Pwn Exercise(一)</a></h1><div class="content"><p>BUUOJ PWN EXERCISE</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/pwn/">pwn</a></div>  <hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/02/18/BUUCTF%20Pwn%20Exercise/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-03-15T07:44:09.622Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-03-15</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/"><img class="fill" src="https://w.wallhaven.cc/full/57/wallhaven-57jge1.jpg" alt="数据结构基础代码总结（树和图）"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-02-17  <a class="commentCountImg" href="/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/#comment-container"><span class="display-none-class">611f469c2c8a42436ca095b28ab2aefd</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="611f469c2c8a42436ca095b28ab2aefd">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>42 m  <i class="fas fa-pencil-alt"> </i>6.3 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/">数据结构基础代码总结（树和图）</a></h1><div class="content"><p>树和图部分</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/02/17/%E3%80%90%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20%E3%80%91%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93%20C%E8%AF%AD%E8%A8%80(%E6%A0%91%E5%92%8C%E5%9B%BE%EF%BC%89/#more">Read more&gt;&gt;</a></div></div><div class="level-start"><div class="level-item has-text-grey is-size-7"><time datetime="2022-02-17T03:39:57.914Z"><i class="far fa-calendar-check"> Last Modified: </i>2022-02-17</time></div></div></div></article></div><div class="card"><div class="card-image"><a class="image is-7by3" href="/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"><img class="fill" src="https://w.wallhaven.cc/full/9m/wallhaven-9mel2k.png" alt="flask配置celery异步任务"></a></div><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2022-02-13  <a class="commentCountImg" href="/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/#comment-container"><span class="display-none-class">7b8f3142496d1c0c91cd70ca386ff2bf</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="7b8f3142496d1c0c91cd70ca386ff2bf">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>12 m  <i class="fas fa-pencil-alt"> </i>1.8 k</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/">flask配置celery异步任务</a></h1><div class="content"><p>flask 配置 celery 异步任务</p></div><div class="index-category-tag"><div class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="article-more button is-small link-muted index-categories" href="/categories/flask/">flask</a></div>  <div class="level-item"><i class="fas fa-tags has-text-grey"> </i><a class="article-more button is-small link-muted index-tags" href="/tags/flask/">flask</a></div><hr></div><div class="level is-mobile is-flex"><div class="level-start"><div class="level-item"><a class="article-more button is-small size-small" href="/2022/02/13/flask%E9%85%8D%E7%BD%AE%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/#more">Read more&gt;&gt;</a></div></div></div></article></div><!--!--><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/./img/avatar1.jpg" alt="y1seco"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">y1seco</p><p class="is-size-6 is-block">Trying to do better</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">27</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/y1seco" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/y1seco"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:K4oer_Xr@bupt.edu.cn"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"From《"+data.from+"》</p><p>Provider-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://P4nda.top" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">P4nda</span></span><span class="level-right"><span class="level-item tag">p4nda.top</span></span></a></li><li><a class="level is-mobile" href="https://ama2in9.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Ama2in9</span></span><span class="level-right"><span class="level-item tag">ama2in9.top</span></span></a></li><li><a class="level is-mobile" href="https://eternalsakura13.com/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Sakura</span></span><span class="level-right"><span class="level-item tag">eternalsakura13.com</span></span></a></li><li><a class="level is-mobile" href="https://p1umer.github.io/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">P1umer</span></span><span class="level-right"><span class="level-item tag">p1umer.github.io</span></span></a></li><li><a class="level is-mobile" href="https://e0hyl.github.io/BLOG-OF-E0/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">E0</span></span><span class="level-right"><span class="level-item tag">e0hyl.github.io</span></span></a></li><li><a class="level is-mobile" href="https://linkleyping.top/" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">EP</span></span><span class="level-right"><span class="level-item tag">linkleyping.top</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><!--!--><div class="card widget"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/2022/05/14/LMK/"><img src="https://w.wallhaven.cc/full/y8/wallhaven-y8oewl.jpg" alt="Android--LMK机制分析"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-05-14T09:26:54.274Z">2022-05-14</time></p><p class="title"><a href="/2022/05/14/LMK/">Android--LMK机制分析</a></p><p class="categories"><a href="/categories/android/">android</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/"><img src="https://w.wallhaven.cc/full/1k/wallhaven-1km5dg.jpg" alt="arm-trusted-firmware可信启动机制"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-04-20T02:36:32.926Z">2022-04-20</time></p><p class="title"><a href="/2022/04/20/ATF%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/">arm-trusted-firmware可信启动机制</a></p><p class="categories"><a href="/categories/arm/">arm</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/04/10/OPTEE_ATF/"><img src="https://w.wallhaven.cc/full/l3/wallhaven-l37vzy.png" alt="基于QEMU的OPTEE/ATF学习"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-04-10T13:52:08.727Z">2022-04-10</time></p><p class="title"><a href="/2022/04/10/OPTEE_ATF/">基于QEMU的OPTEE/ATF学习</a></p><p class="categories"><a href="/categories/qemu/">qemu</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/"><img src="https://w.wallhaven.cc/full/3z/wallhaven-3zy6r3.jpg" alt="vue开发问题总结"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-03-06T16:38:29.355Z">2022-03-07</time></p><p class="title"><a href="/2022/03/07/vue%E5%BC%80%E5%8F%91%20(1)/">vue开发问题总结</a></p><p class="categories"><a href="/categories/vue/">vue</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/"><img src="https://w.wallhaven.cc/full/v9/wallhaven-v9v3r5.jpg" alt="BUUOJ PWN EXERCISE(二)"></a></figure><div class="media-content"><p class="date"><time dateTime="2022-03-03T10:11:18.801Z">2022-03-03</time></p><p class="title"><a href="/2022/03/03/BUUOJ%20PWN%20EXERCISE(%E4%B8%89%EF%BC%89/">BUUOJ PWN EXERCISE(二)</a></p><p class="categories"><a href="/categories/pwn/">pwn</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Kernel/"><span class="level-start"><span class="level-item">Kernel</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/android/"><span class="level-start"><span class="level-item">android</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/arm/"><span class="level-start"><span class="level-item">arm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/flask/"><span class="level-start"><span class="level-item">flask</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/pwn/"><span class="level-start"><span class="level-item">pwn</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/pwnable-tw/"><span class="level-start"><span class="level-item">pwnable.tw</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/qemu/"><span class="level-start"><span class="level-item">qemu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/pwn/"><span class="tag">pwn</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9A%8F%E7%AC%94/"><span class="tag">随笔</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kernel/"><span class="tag">Kernel</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm/"><span class="tag">arm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/flask/"><span class="tag">flask</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/./img/avatar1.jpg" alt="Y1secoのblog" height="28"></a><p class="size-small"><span>&copy; 2022 y1seco</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️Site from <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> has existed <strong>" + dnum + "</strong> d <strong>" + hnum + "</strong> h <strong>" + mnum + "</strong> m <strong>" + snum + "</strong> s！❤️";
        }var now = new Date();setInterval("createTime('2021/12/8 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️Thx <strong><span id="busuanzi_value_site_uv">99+</span></strong> users <strong><span id="busuanzi_value_site_pv">99+</span></strong> visited！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/removeif/hexo-theme-amazing"><i class="fab fa-github"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="2364053447" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('fd76c4da4d218138902f','4e352bc8c73327810c18892ef0a825d8ec6cb020','y1seco','blog_comments',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(false){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('fd76c4da4d218138902f','4e352bc8c73327810c18892ef0a825d8ec6cb020','y1seco','blog_comments',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>